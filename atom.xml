<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Weishu's Notes]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://weishu.me/"/>
  <updated>2016-03-23T08:50:25.000Z</updated>
  <id>http://weishu.me/</id>
  
  <author>
    <name><![CDATA[weishu]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android 插件化原理解析——Activity生命周期管理]]></title>
    <link href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/"/>
    <id>http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/</id>
    <published>2016-03-21T11:43:32.000Z</published>
    <updated>2016-03-23T08:50:25.000Z</updated>
    <content type="html"><![CDATA[<p>之前的 <a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">Android插件化原理解析</a> 系列文章揭开了Hook机制的神秘面纱，现在我们手握倚天屠龙，那么如何通过这种技术完成插件化方案呢？具体来说，插件中的Activity，Service等组件如何在Android系统上运行起来？</p>
<p>在Java平台要做到动态运行模块、热插拔可以使用<code>ClassLoader</code>技术进行动态类加载，比如广泛使用的<code>OSGi</code>技术。在Android上当然也可以使用动态加载技术，但是仅仅把类加载进来就足够了吗？<code>Activity</code>，<code>Service</code>等组件是有生命周期的，它们统一由系统服务<code>AMS</code>管理；使用<code>ClassLoader</code>可以从插件中创建Activity对象，但是，一个没有生命周期的Activity对象有什么用？所以在Android系统上，仅仅完成动态类加载是不够的；我们需要想办法把我们加载进来的Activity等组件交给系统管理，让<code>AMS</code>赋予组件生命周期；这样才算是一个有血有肉的完善的插件化方案。</p>
<p>接下来的系列文章会讲述 DroidPlugin对于Android四大组件的处理方式，我们且看它如何采用Hook技术坑蒙拐骗把系统玩弄于股掌之中，最终赋予Activity，Service等组件生命周期，完成借尸还魂的。</p>
<a id="more"></a>
<p>首先，我们来看看DroidPlugin对于<code>Activity</code>组件的处理方式。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的intercept-activity模块。另外，如果对于Hook技术不甚了解，请先查阅我之前的文章：</p>
<ol>
<li><a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Hook机制之动态代理</a></li>
<li><a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Hook机制之Binder Hook</a></li>
<li><a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Hook机制之AMS&amp;PMS</a></li>
</ol>
<h2 id="AndroidManifest-xml的限制">AndroidManifest.xml的限制</h2><p>读到这里，或许有部分读者觉得疑惑了，启动Activity不就是一个<code>startActivity</code>的事吗，有这么神秘兮兮的？</p>
<p>启动Activity确实非常简单，但是Android却有一个限制：<strong>必须在AndroidManifest.xml中显示声明使用的Activity</strong>；我相信读者肯定会遇到下面这种异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">03</span>-<span class="number">18</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">56.074</span>  <span class="number">20709</span>-<span class="number">20709</span>/com.weishu.intercept_activity.app E/AndroidRuntime﹕ FATAL EXCEPTION: main</span><br><span class="line">    Process: com.weishu.intercept_activity.app, PID: <span class="number">20709</span></span><br><span class="line">    android.content.ActivityNotFoundException: Unable to find explicit activity <span class="class"><span class="keyword">class</span> </span>&#123;com.weishu.intercept_activity.app/com.weishu.intercept_activity.app.TargetActivity&#125;; have you declared <span class="keyword">this</span> activity in your AndroidManifest.xml?</span><br></pre></td></tr></table></figure>
<p>『必须在AndroidManifest.xml中显示声明使用的Activity』这个硬性要求很大程度上限制了插件系统的发挥：假设我们需要启动一个插件的Activity，插件使用的Activity是无法预知的，这样肯定也不会在Manifest文件中声明；如果插件新添加一个Activity，主程序的AndroidManifest.xml就需要更新；既然双方都需要修改升级，何必要使用插件呢？这已经违背了动态加载的初衷：不修改插件框架而动态扩展功能。</p>
<p>能不能想办法绕过这个限制呢？</p>
<p>束手无策啊，怎么办？借刀杀人偷梁换柱无中生有以逸待劳乘火打劫瞒天过海…等等！偷梁换柱瞒天过海？貌似可以一试。</p>
<p>我们可以耍个障眼法：既然AndroidManifest文件中必须声明，那么我就声明一个（或者有限个）替身Activity好了，当需要启动插件的某个Activity的时候，先让系统以为启动的是AndroidManifest中声明的那个替身，暂时骗过系统；然后到合适的时候又替换回我们需要启动的真正的Activity；所谓瞒天过海，莫过如此！</p>
<p>现在有了方案了，但是该如何做呢？兵书又说，知己知彼百战不殆！如果连Activity的启动过程都不熟悉，怎么完成这个瞒天过海的过程？</p>
<h2 id="Activity启动过程">Activity启动过程</h2><p>启动Activity非常简单，一个<code>startActivity</code>就完事了；那么在这个简单调用的背后发生了什么呢？Look the fucking source code！</p>
<p>关于Activity 的启动过程，也不是三言两语能解释清楚的，如果按照源码一步一步走下来，插件化系列文章就不用写了；所以这里我就给出一个大致流程，只列出关键的调用点（以Android 6.0源码为例）；如果读者希望更详细的讲解，可以参考老罗的 <a href="http://blog.csdn.net/luoshengyang/article/details/6685853" target="_blank" rel="external"> Android应用程序的Activity启动过程简要介绍和学习计划</a></p>
<p>首先是Activity类的<code>startActivity</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟着这个方法一步一步跟踪，会发现它最后在<code>startActivityForResult</code>里面调用了Instrument对象的<code>execStartActivity</code>方法；接着在这个函数里面调用了ActivityManagerNative类的<code>startActivity</code>方法；这个过程在前文已经反复举例讲解了，我们知道接下来会通过Binder IPC到<code>AMS</code>所在进程调用<code>AMS</code>的<code>startActivity</code>方法；Android系统的组件生命周期管理就是在<code>AMS</code>里面完成的，那么在<code>AMS</code>里面到底做了什么呢？</p>
<p>ActivityManagerService的<code>startActivity</code>方法如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">int</span> startActivity(IApplicationThread caller, <span class="keyword">String</span> callingPackage,</span><br><span class="line">        Intent intent, <span class="keyword">String</span> resolvedType, IBinder resultTo,</span><br><span class="line">        <span class="keyword">String</span> resultWho, <span class="built_in">int</span> requestCode, <span class="built_in">int</span> startFlags,</span><br><span class="line">        <span class="keyword">String</span> profileFile, ParcelFileDescriptor profileFd, Bundle options) &#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode,</span><br><span class="line">            startFlags, profileFile, profileFd, options, UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，直接调用了<code>startActivityAsUser</code>这个方法；接着是<code>ActivityStackSupervisor</code>类的<code>startActivityMayWait</code>方法。这个ActivityStackSupervisor类到底是个啥？如果仔细查阅，低版本的Android源码上是没有这个类的；后来AMS的代码进行了部分重构，关于Activity栈管理的部分单独提取出来成为了<code>ActivityStackSupervisor</code>类；好了，继续看代码。</p>
<p>startActivityMayWait这个方法前面对参数进行了一系列处理，我们需要知道的是，在这个方法内部对传进来的Intent进行了解析，并尝试从中取出关于启动Activity的信息。</p>
<p>然后这个方法调用了startActivityLocked方法；在startActivityLocked方法内部进行了一系列重要的检查：比如权限检查，Activity的exported属性检查等等；我们上文所述的，启动没有在Manifestfest中显示声明的Activity抛异常也是这里发生的：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">err</span> == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123;</span><br><span class="line">    <span class="comment">// We couldn't find the specific class specified in the Intent.</span></span><br><span class="line">    <span class="comment">// Also the end of the line.</span></span><br><span class="line">    <span class="keyword">err</span> = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里返回ActivityManager.START_CLASS_NOT_FOUND之后，在Instrument的execStartActivity返回之后会检查这个值，然后跑出异常：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">    <span class="keyword">if</span> (intent <span class="keyword">instanceof</span> Intent &amp;&amp; ((Intent)intent).getComponent() != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                <span class="string">"Unable to find explicit activity class "</span></span><br><span class="line">                + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                + <span class="string">"; have you declared this activity in your AndroidManifest.xml?"</span>);</span><br></pre></td></tr></table></figure>
<p>源码看到这里，我们已经确认了『必须在AndroidManifest.xml中显示声明使用的Activity』的原因；然而这个校检过程发生在<code>AMS</code>所在的进程<code>system_server</code>，我们没有办法篡改，只能另寻他路。</p>
<p>OK，我们继续跟踪源码；在startActivityLocked之后处理的都是Activity任务栈相关内容，这一系列ActivityStack和ActivityStackSupervisor纠缠不清的调用看下图就明白了；不明白也没关系: D 目前用处不大。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1458296458099.png" alt="调用流程图"></p>
<p>这一系列调用最终到达了ActivityStackSupervisor的realStartActivityLocked方法；人如其名，这个方法开始了真正的“启动Activity”：它调用了ApplicationThread的scheduleLaunchActivity方法，开始了真正的Activity对象创建以及启动过程。</p>
<p>这个ApplicationThread是什么，是一个线程吗？与ActivityThread有什么区别和联系？</p>
<p>不要被名字迷惑了，这个ApplicationThread实际上是一个Binder对象，是App所在的进程与AMS所在进程system_server通信的桥梁；在Activity启动的过程中，App进程会频繁地与AMS进程进行通信：</p>
<ol>
<li>App进程会委托AMS进程完成Activity生命周期的管理以及任务栈的管理；这个通信过程AMS是Server端，App进程通过持有AMS的client代理ActivityManagerNative完成通信过程；</li>
<li>AMS进程完成生命周期管理以及任务栈管理后，会把控制权交给App进程，让App进程完成Activity类对象的创建，以及生命周期回调；这个通信过程也是通过Binder完成的，App所在server端的Binder对象存在于ActivityThread的内部类ApplicationThread；AMS所在client通过持有IApplicationThread的代理对象完成对于App进程的通信。</li>
</ol>
<p>App进程与AMS进程的通信过程如图所示：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1458300329231.png" width="500"></p>
<p>App进程内部的ApplicationThread server端内部有自己的Binder线程池，它与App主线程的通信通过Handler完成，这个Handler存在于ActivityThread类，它的名字很简单就叫<code>H</code>，这一点我们接下来就会讲到。</p>
<p>现在我们明白了这个ApplicationThread到底是个什么东西，接上文继续跟踪Activity的启动过程；我们查看ApplicationThread的<code>scheduleLaunchActivity</code>方法，这个方法很简单，就是包装了参数最终使用Handler发了一个消息。</p>
<p>正如刚刚所说，ApplicationThread所在的Binder服务端使用Handler与主线程进行通信，这里的scheduleLaunchActivity方法直接把启动Activity的任务通过一个消息转发给了主线程；我们查看Handler类对于这个消息的处理：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart")<span class="comment">;</span></span><br><span class="line">ActivityClientRecord r = (ActivityClientRecord)msg.obj<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">        r.activityInfo.applicationInfo, r.compatInfo)<span class="comment">;</span></span><br><span class="line">handleLaunchActivity(r, null)<span class="comment">;</span></span><br><span class="line">Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里直接调用了ActivityThread的handleLaunchActivity方法，在这个方法内部有一句非常重要：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Activity a = performLaunchActivity<span class="list">(<span class="keyword">r</span>, customIntent)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>绕了这么多弯，我们的Activity终于被创建出来了！继续跟踪这个performLaunchActivity方法看看发生了什么；由于这个方法较长，我就不贴代码了，读者可以自行查阅；要指出的是，这个方法做了两件很重要的事情：</p>
<ol>
<li>使用ClassLoader加载并通过反射创建Activity对象</li>
</ol>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader()<span class="comment">;</span></span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">        cl, component.getClassName(), r.intent)<span class="comment">;</span></span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass())<span class="comment">;</span></span><br><span class="line">r.intent.setExtrasClassLoader(cl)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果Application还没有创建，那么创建Application对象并回调相应的生命周期方法；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity的启动过程到这里就结束了，可能读者还是觉得迷惑：不就是调用了一系列方法吗？具体做了什么还是不太清楚，而且为什么Android要这么设计？</p>
<p>方法调用链再长也木有关系，有两点需要明白：</p>
<ol>
<li>平时我们所说的Application被创建了，onCreate方法被调用了，我们或许并没有意识到我们所说的<code>Application, Activity</code>除了代表Android应用层通常所代表的“组件”之外，它们其实都是普通的Java对象，也是需要被构造函数构造出来的对象的；在这个过程中，我们明白了这些对象到底是如何被创建的。</li>
<li>为什么需要一直与AMS进行通信？哪些操作是在AMS中进行的？其实<code>AMS</code>正如名字所说，管理所有的“活动”，整个系统的Activity堆栈，Activity生命周期回调都是由AMS所在的系统进程system_server帮开发者完成的；Android的Framework层帮忙完成了诸如生命周期管理等繁琐复杂的过程，简化了应用层的开发。</li>
</ol>
<h2 id="瞒天过海——启动不在AndroidManifest-xml中声明的Activity">瞒天过海——启动不在AndroidManifest.xml中声明的Activity</h2><h3 id="简要分析">简要分析</h3><p>通过上文的分析，我们已经对Activity的启动过程了如指掌了；就让我们干点坏事吧 :D</p>
<p>对与『必须在AndroidManifest.xml中显示声明使用的Activity』这个问题，上文给出了思路——瞒天过海；我们可以在AndroidManifest.xml里面声明一个替身Activity，然后<strong>在合适的时候</strong>把这个假的替换成我们真正需要启动的Activity就OK了。</p>
<p>那么问题来了，『合适的时候』到底是什么时候？在前文<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Hook机制之动态代理</a>中我们提到过Hook过程最重要的一步是<strong>寻找Hook点</strong>；如果是在同一个进程，<code>startActivity</code>到Activity真正启动起来这么长的调用链，我们随便找个地方Hook掉就完事儿了；但是问题木有这么简单。</p>
<p>Activity启动过程中很多重要的操作（正如上文分析的『必须在AndroidManifest.xml中显式声明要启动的Activity』)都不是在App进程里面执行的，而是在AMS所在的系统进程system_server完成，由于<strong>进程隔离</strong>的存在，我们对别的进程无能为力；所以这个Hook点就需要花点心思了。</p>
<p>这时候Activity启动过程的知识就派上用场了；虽然整个启动过程非常复杂，但其实一张图就能总结：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1458532084072.png" alt="简要启动过程"></p>
<p>先从App进程调用<code>startActivity</code>；然后通过IPC调用进入系统进程system_server，完成Activity管理以及一些校检工作，最后又回到了APP进程完成真正的Activioty对象创建。</p>
<p>由于这个检验过程是在AMS进程完成的，我们对system_server进程里面的操作无能为力，只有在我们APP进程里面执行的过程才是有可能被Hook掉的，也就是第一步和第三步；具体应该怎么办呢？</p>
<p>既然需要一个显式声明的Activity，那就声明一个！<strong>可以在第一步假装启动一个已经在AndroidManifest.xml里面声明过的替身Activity，让这个Activity进入AMS进程接受检验；最后在第三步的时候换成我们真正需要启动的Activity</strong>；这样就成功欺骗了AMS进程，瞒天过海！</p>
<p>说到这里，是不是有点小激动呢？我们写个demo验证一下：『启动一个并没有在AndroidManifest.xml中显示声明的Activity』</p>
<h3 id="实战过程">实战过程</h3><p>具体来说，我们打算实现如下功能：在MainActivity中启动一个并没有在AndroidManifest.xml中声明的TargetActivity；按照上文分析，我们需要声明一个替身Activity，我们叫它StubActivity；</p>
<p>那么，我们的AndroidManifest.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">          <span class="attribute">package</span>=<span class="value">"com.weishu.intercept_activity.app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span></span><br><span class="line">            <span class="attribute">android:allowBackup</span>=<span class="value">"true"</span></span><br><span class="line">            <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">            <span class="attribute">android:icon</span>=<span class="value">"@mipmap/ic_launcher"</span></span><br><span class="line">            &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 替身Activity, 用来欺骗AMS  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".StubActivity"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>OK，那么我们启动TargetActivity很简单，就是个<code>startActivity</code>调用的事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TargetActivity.class));</span><br></pre></td></tr></table></figure>
<p>如果你直接这么运行，肯定会直接抛出ActivityNotFoundException然后直接退出；我们接下来要做的就是让这个调用成功启动TargetActivity。</p>
<h4 id="狸猫换太子——使用替身Activity绕过AMS">狸猫换太子——使用替身Activity绕过AMS</h4><p>由于<code>AMS</code>进程会对Activity做显式声明验证，因此在<br>启动Activity的控制权转移到<code>AMS</code>进程之前，我们需要想办法<strong>临时</strong>把TargetActivity替换成替身StubActivity；在这之间有很长的一段调用链，我们可以轻松Hook掉；选择什么地方Hook是一个很自由的事情，但是Hook的步骤越后越可靠——Hook得越早，后面的调用就越复杂，越容易出错。</p>
<p>我们可以选择在进入<code>AMS</code>进程的入口进行Hook，具体来说也就是Hook <code>AMS</code>在本进程的代理对象ActivityManagerNative。如果你不知道如何Hook掉这个AMS的代理对象，请查阅我之前的文章 <a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Hook机制之AMS&amp;PMS</a> </p>
<p>我们Hook掉ActivityManagerNative对于startActivity方法的调用，替换掉交给AMS的intent对象，将里面的TargetActivity的暂时替换成已经声明好的替身StubActivity；这种Hook方式 <a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">前文</a> 讲述的很详细，不赘述；替换的关键代码如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="comment">// 只拦截这个方法</span></span><br><span class="line">    <span class="comment">// 替换参数, 任你所为;甚至替换原始Activity启动别的Activity偷梁换柱</span></span><br><span class="line">    <span class="comment">// API 23:</span></span><br><span class="line">    <span class="comment">// public final Activity startActivityNow(Activity parent, String id,</span></span><br><span class="line">    <span class="comment">// Intent intent, ActivityInfo activityInfo, IBinder token, Bundle state,</span></span><br><span class="line">    <span class="comment">// Activity.NonConfigurationInstances lastNonConfigurationInstances) &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到参数里面的第一个Intent 对象</span></span><br><span class="line"></span><br><span class="line">    Intent raw;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    raw = (Intent) args[index];</span><br><span class="line"></span><br><span class="line">    Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里包名直接写死,如果再插件里,不同的插件有不同的包  传递插件的包名即可</span></span><br><span class="line">    String targetPackage = <span class="string">"com.weishu.intercept_activity.app"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里我们把启动的Activity临时替换为 StubActivity</span></span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(targetPackage, StubActivity.class.getCanonicalName());</span><br><span class="line">    newIntent.setComponent(componentName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把我们原始要启动的TargetActivity先存起来</span></span><br><span class="line">    newIntent.putExtra(HookHelper.EXTRA_TARGET_INTENT, raw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换掉Intent, 达到欺骗AMS的目的</span></span><br><span class="line">    args[index] = newIntent;</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"hook success"</span>);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> method.invoke(mBase, args);</span><br></pre></td></tr></table></figure>
<p>通过这个替换过程，在ActivityManagerNative的startActivity调用之后，system_server端收到Binder驱动的消息，开始执行ActivityManagerService里面真正的<code>startActivity</code>方法；这时候AMS看到的<code>intent</code>参数里面的组件已经是<code>StubActivity</code>了，因此可以成功绕过检查，这时候如果不做后面的Hook，直接调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TargetActivity.class));</span><br></pre></td></tr></table></figure>
<p>也不会出现上文的ActivityNotFoundException</p>
<h4 id="借尸还魂——拦截Callback从恢复真身">借尸还魂——拦截Callback从恢复真身</h4><p>行百里者半九十。现在我们的<code>startActivity</code>启动一个没有显式声明的Activity已经不会抛异常了，但是要真正正确地把TargetActivity启动起来，还有一些事情要做。其中最重要的一点是，我们用替身StubActivity临时换了TargetActivity，肯定需要在『合适的』时候替换回来；接下来我们就完成这个过程。</p>
<p>在AMS进程里面我们是没有办法换回来的，因此我们要等AMS把控制权交给App所在进程，也就是上面那个『Activity启动过程简图』的第三步。AMS进程转移到App进程也是通过Binder调用完成的，承载这个功能的Binder对象是IApplicationThread；在App进程它是Server端，在Server端接受Binder远程调用的是Binder线程池，Binder线程池通过Handler将消息转发给App的主线程；（我这里不厌其烦地叙述Binder调用过程，希望读者不要反感，其一加深印象，其二懂Binder真的很重要）我们可以在这个<strong>Handler里面将替身恢复成真身</strong>。</p>
<p>这里不打算讲述Handler 的原理，我们简单看一下Handler是如何处理接收到的Message的，如果我们能拦截这个Message的接收过程，就有可能完成替身恢复工作；Handler类的<code>dispathMesage</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个方法可以看出来，Handler类消息分发的过程如下：</p>
<ol>
<li>如果传递的Message本身就有callback，那么直接使用Message对象的callback方法；</li>
<li>如果Handler类的成员变量<code>mCallback</code>存在，那么首先执行这个<code>mCallback</code>回调；</li>
<li>如果<code>mCallback</code>的回调返回<code>true</code>，那么表示消息已经成功处理；直接结束。</li>
<li>如果<code>mCallback</code>的回调返回<code>false</code>，那么表示消息没有处理完毕，会继续使用Handler类的<code>handleMessage</code>方法处理消息。</li>
</ol>
<p>那么，ActivityThread中的Handler类<code>H</code>是如何实现的呢？<code>H</code>的部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">            ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line"></span><br><span class="line">            r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                    r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">            handleLaunchActivity(r, <span class="keyword">null</span>);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RELAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityRestart"</span>);</span><br><span class="line">            ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line">            handleRelaunchActivity(r);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下略</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>H</code>类仅仅重载了<code>handleMessage</code>方法；通过dispathMessage的消息分发过程得知，我们可以拦截这一过程：<strong>把这个<code>H</code>类的<code>mCallback</code>替换为我们的自定义实现</strong>，这样<code>dispathMessage</code>就会首先使用这个自定义的<code>mCallback</code>，然后看情况使用<code>H</code>重载的<code>handleMessage</code>。</p>
<p>这个<code>Handler.Callback</code>是一个接口，我们可以使用动态代理或者普通代理完成Hook，这里我们使用普通的静态代理方式；创建一个自定义的Callback类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* package */</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThreadHandlerCallback</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Handler mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActivityThreadHandlerCallback</span><span class="params">(Handler base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="comment">// ActivityThread里面 "LAUNCH_ACTIVITY" 这个字段的值是100</span></span><br><span class="line">            <span class="comment">// 本来使用反射的方式获取最好, 这里为了简便直接使用硬编码</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">                handleLaunchActivity(msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mBase.handleMessage(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里简单起见,直接取出TargetActivity;</span></span><br><span class="line"></span><br><span class="line">        Object obj = msg.obj;</span><br><span class="line">        <span class="comment">// 根据源码:</span></span><br><span class="line">        <span class="comment">// 这个对象是 ActivityClientRecord 类型</span></span><br><span class="line">        <span class="comment">// 我们修改它的intent字段为我们原来保存的即可.</span></span><br><span class="line"><span class="comment">/*        switch (msg.what) &#123;</span><br><span class="line">/             case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">/                 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart");</span><br><span class="line">/                 final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">/</span><br><span class="line">/                 r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">/                         r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">/                 handleLaunchActivity(r, null);</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把替身恢复成真身</span></span><br><span class="line">            Field intent = obj.getClass().getDeclaredField(<span class="string">"intent"</span>);</span><br><span class="line">            intent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Intent raw = (Intent) intent.get(obj);</span><br><span class="line"></span><br><span class="line">            Intent target = raw.getParcelableExtra(HookHelper.EXTRA_TARGET_INTENT);</span><br><span class="line">            raw.setComponent(target.getComponent());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Callback类的使命很简单：<strong>把替身StubActivity恢复成真身TargetActivity</strong>；有了这个自定义的Callback之后我们需要把ActivityThread里面处理消息的Handler类<code>H</code>的的<code>mCallback</code>修改为自定义callback类的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Field currentActivityThreadField = activityThreadClass.getDeclaredField(<span class="string">"sCurrentActivityThread"</span>);</span><br><span class="line">currentActivityThreadField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于ActivityThread一个进程只有一个,我们获取这个对象的mH</span></span><br><span class="line">Field mHField = activityThreadClass.getDeclaredField(<span class="string">"mH"</span>);</span><br><span class="line">mHField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Handler mH = (Handler) mHField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置它的回调, 根据源码:</span></span><br><span class="line"><span class="comment">// 我们自己给他设置一个回调,就会替代之前的回调;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        public void dispatchMessage(Message msg) &#123;</span></span><br><span class="line"><span class="comment">//            if (msg.callback != null) &#123;</span></span><br><span class="line"><span class="comment">//                handleCallback(msg);</span></span><br><span class="line"><span class="comment">//            &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                if (mCallback != null) &#123;</span></span><br><span class="line"><span class="comment">//                    if (mCallback.handleMessage(msg)) &#123;</span></span><br><span class="line"><span class="comment">//                        return;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                handleMessage(msg);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">Field mCallBackField = Handler.class.getDeclaredField(<span class="string">"mCallback"</span>);</span><br><span class="line">mCallBackField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">mCallBackField.set(mH, <span class="keyword">new</span> ActivityThreadHandlerCallback(mH));</span><br></pre></td></tr></table></figure>
<p>到这里，我们已经成功地绕过<code>AMS</code>，完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的过程；瞒天过海，这种玩弄系统与股掌之中的快感你们能体会到吗？</p>
<h4 id="僵尸or活人？——能正确收到生命周期回调吗">僵尸or活人？——能正确收到生命周期回调吗</h4><p>虽然我们完成了『启动没有在AndroidManifest.xml中显式声明的Activity 』，但是启动的TargetActivity是否有自己的生命周期呢，我们还需要额外的处理过程吗？</p>
<p>实际上TargetActivity已经是一个有血有肉的Activity了：它具有自己正常的生命周期；可以运行<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">Demo代码</a>验证一下。</p>
<p>这个过程是如何完成的呢？我们以<code>onDestroy</code>为例简要分析一下：</p>
<blockquote>
<p>从Activity的<code>finish</code>方法开始跟踪，最终会通过ActivityManagerNative到<code>AMS</code>然后接着通过ApplicationThread到ActivityThread，然后通过<code>H</code>转发消息到ActivityThread的handleDestroyActivity，接着这个方法把任务交给performDestroyActivity完成。</p>
</blockquote>
<p>在真正分析这个方法之前，需要说明一点的是：不知读者是否感受得到，App进程与<code>AMS</code>交互几乎都是这么一种模式，几个角色 ActivityManagerNative, ApplicationThread, ActivityThread以及Handler类<code>H</code>分工明确，读者可以按照这几个角色的功能分析<code>AMS</code>的任何调用过程，屡试不爽；这也是我的初衷——希望分析插件框架的过程中能帮助深入理解Android Framework。</p>
<p>好了继续分析performDestroyActivity，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityClientRecord r = mActivities.get(token);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line">mInstrumentation.callActivityOnDestroy(r.activity);</span><br></pre></td></tr></table></figure>
<p>这里通过<code>mActivities</code>拿到了一个ActivityClientRecord，然后直接把这个record里面的Activity交给Instrument类完成了onDestroy的调用。</p>
<p>在我们这个demo的场景下，r.activity是TargetActivity还是StubActivity？按理说，由于我们欺骗了<code>AMS</code>，<code>AMS</code>应该只知道<code>StubActivity</code>的存在，它压根儿就不知道TargetActivity是什么，为什么它能正确完成对TargetActivity生命周期的回调呢？</p>
<p>一切的秘密在<code>token</code>里面。<code>AMS</code>与<code>ActivityThread</code>之间对于Activity的生命周期的交互，并没有直接使用Activity对象进行交互，而是使用一个token来标识，这个token是binder对象，因此可以方便地跨进程传递。Activity里面有一个成员变量<code>mToken</code>代表的就是它，token可以唯一地标识一个Activity对象，它在Activity的<code>attach</code>方法里面初始化；</p>
<p>在<code>AMS</code>处理Activity的任务栈的时候，使用这个token标记Activity，因此在我们的demo里面，<code>AMS</code>进程里面的token对应的是StubActivity，也就是<code>AMS</code>还在傻乎乎地操作StubActivity（关于这一点，你可以dump出任务栈的信息，可以观察到dump出的确实是StubActivity）。但是在我们App进程里面，token对应的却是TargetActivity！因此，在ActivityThread执行回调的时候，能正确地回调到TargetActivity相应的方法。</p>
<p>为什么App进程里面，token对应的是TargetActivity呢？</p>
<p>回到代码，ActivityClientRecord是在<code>mActivities</code>里面取出来的，确实是根据token取；那么这个token是什么时候添加进去的呢？我们看performLaunchActivity就完成明白了：它通过classloader加载了TargetActivity，然后完成一切操作之后把这个activity添加进了<code>mActivities</code>！另外，在这个方法里面我们还能看到对Ativity<code>attact</code>方法的调用，它传递给了新创建的Activity一个token对象，而这个token是在ActivityClientRecord构造函数里面初始化的。</p>
<p>至此我们已经可以确认，通过这种方式启动的Activity有它自己完整而独立的生命周期！</p>
<h2 id="小节">小节</h2><p>本文讲述了『启动一个并没有在AndroidManifest.xml中显示声明的Activity』的解决办法，我们成功地绕过了Android的这个限制，这个是插件Activity管理技术的基础；但是要做到启动一个插件Activity问题远没有这么简单。</p>
<p>首先，在Android中，Activity有不同的启动模式；我们声明了一个替身StubActivity，肯定没有满足所有的要求；因此，我们需要在AndroidManifest.xml中声明一系列的有不同launchMode的Activity，还需要完成替身与真正Activity launchMode的匹配过程；这样才能完成启动各种类型Activity的需求，关于这一点，在 DroidPlugin 的com.morgoo.droidplugin.stub包下面可以找到。</p>
<p>另外，每启动一个插件的Activity都需要一个StubActivity，但是AndroidManifest.xml中肯定只能声明有限个，如果一直<code>startActivity</code>而不finish的话，那么理论上就需要无限个StubActivity；这个问题该如何解决呢？事实上，这个问题在技术上没有好的解决办法。但是，如果你的App startActivity了十几次，而没有finish任何一个Activity，这样在Activity的回退栈里面有十几个Activity，用户难道按back十几次回到主页吗？有这种需求说明你的产品设计有问题；一个App一级页面，二级页面..到五六级的页面已经影响体验了，所以，每种LauchMode声明十个StubActivity绝对能满足需求了。</p>
<p>最后，在本文所述例子中，TargetActivity与StubActivity存在于同一个Apk，因此系统的ClassLoader能够成功加载并创建TargetActivity的实例。但是在实际的插件系统中，要启动的目标Activity肯定存在于一个单独的文件中，系统默认的ClassLoader无法加载插件中的Activity类——系统压根儿就不知道要加载的插件在哪，谈何加载？因此还有一个很重要的问题需要处理：</p>
<p><strong>我们要完成插件系统中类的加载</strong>，这可以通过自定义ClassLoader实现。解决了『启动没有在AndroidManifest.xml中显式声明的，并且存在于外部文件中的Activity』的问题，插件系统对于Activity的管理才算得上是一个完全体。篇幅所限，欲知后事如何，请听下回分解！</p>
<p>喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>和我的 <a href="http://weishu.me">博客</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前的 <a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">Android插件化原理解析</a> 系列文章揭开了Hook机制的神秘面纱，现在我们手握倚天屠龙，那么如何通过这种技术完成插件化方案呢？具体来说，插件中的Activity，Service等组件如何在Android系统上运行起来？</p>
<p>在Java平台要做到动态运行模块、热插拔可以使用<code>ClassLoader</code>技术进行动态类加载，比如广泛使用的<code>OSGi</code>技术。在Android上当然也可以使用动态加载技术，但是仅仅把类加载进来就足够了吗？<code>Activity</code>，<code>Service</code>等组件是有生命周期的，它们统一由系统服务<code>AMS</code>管理；使用<code>ClassLoader</code>可以从插件中创建Activity对象，但是，一个没有生命周期的Activity对象有什么用？所以在Android系统上，仅仅完成动态类加载是不够的；我们需要想办法把我们加载进来的Activity等组件交给系统管理，让<code>AMS</code>赋予组件生命周期；这样才算是一个有血有肉的完善的插件化方案。</p>
<p>接下来的系列文章会讲述 DroidPlugin对于Android四大组件的处理方式，我们且看它如何采用Hook技术坑蒙拐骗把系统玩弄于股掌之中，最终赋予Activity，Service等组件生命周期，完成借尸还魂的。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 插件化原理解析——Hook机制之AMS&PMS]]></title>
    <link href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/"/>
    <id>http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/</id>
    <published>2016-03-07T08:35:46.000Z</published>
    <updated>2016-03-09T02:51:05.000Z</updated>
    <content type="html"><![CDATA[<p>在前面的文章中我们介绍了DroidPlugin的Hook机制，也就是<strong>代理方式</strong>和<strong>Binder Hook</strong>；插件框架通过AOP实现了插件使用和开发的透明性。在讲述DroidPlugin如何实现四大组件的插件化之前，有必要说明一下它对ActivityManagerServiche以及PackageManagerService的Hook方式（以下简称AMS，PMS）。</p>
<p>ActivityManagerService对于FrameWork层的重要性不言而喻，Android的四大组件无一不与它打交道：</p>
<ol>
<li><code>startActivity</code>最终调用了AMS的<code>startActivity</code>系列方法，实现了Activity的启动；Activity的生命周期回调，也在AMS中完成；</li>
<li><code>startService,bindService</code>最终调用到AMS的startService和bindService方法；</li>
<li>动态广播的注册和接收在<code>AMS</code>中完成（静态广播在<code>PMS</code>中完成）</li>
<li><code>getContentResolver</code>最终从<code>AMS</code>的<code>getContentProvider</code>获取到ContentProvider</li>
</ol>
<p>而<code>PMS</code>则完成了诸如权限校捡(<code>checkPermission,checkUidPermission</code>)，Apk meta信息获取(<code>getApplicationInfo</code>等)，四大组件信息获取(<code>query</code>系列方法)等重要功能。</p>
<p>在上文<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Android插件化原理解析——Hook机制之Binder Hook</a>中讲述了DroidPlugin的Binder Hook机制；我们知道<code>AMS</code>和<code>PMS</code>就是以Binder方式提供给应用程序使用的系统服务，理论上我们也可以采用这种方式Hook掉它们。但是由于这两者使用得如此频繁，Framework给他们了一些“特别优待”，这也给了我们相对于Binder Hook更加稳定可靠的hook方式。</p>
<a id="more"></a>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的<code>ams-pms-hook</code>模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<h2 id="AMS获取过程">AMS获取过程</h2><p>前文提到Android的四大组件无一不与<code>AMS</code>相关，也许读者还有些许疑惑；这里我就挑一个例子，依据Android源码来说明，一个简单的<code>startActivity</code>是如何调用<code>AMS</code>最终通过IPC到system_server的。</p>
<p>不论读者是否知道，我们使用<code>startActivity</code>有两种形式：</p>
<ol>
<li>直接调用<code>Context</code>类的<code>startActivity</code>方法；这种方式启动的Activity没有Activity栈，因此不能以standard方式启动，必须加上<code>FLAG_ACTIVITY_NEW_TASK</code>这个Flag。</li>
<li>调用被<code>Activity</code>类重载过的<code>startActivity</code>方法，通常在我们的Activity中直接调用这个方法就是这种形式；</li>
</ol>
<h3 id="Context-startActivity">Context.startActivity</h3><p>我们查看<code>Context</code>类的<code>startActivity</code>方法，发现这竟然是一个抽象类；查看<code>Context</code>的类继承关系图如下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1457322345547.png" width="329"></p>
<p>我们看到诸如<code>Activity</code>，<code>Service</code>等并没有直接继承<code>Context</code>，而是继承了<code>ContextWrapper</code>；继续查看<code>ContextWrapper</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    mBase.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WTF!! 果然人如其名，只是一个wrapper而已；这个<code>mBase</code>是什么呢？这里我先直接告诉你，它的真正实现是<code>ContextImpl</code>类；至于为什么，有一条思路：<em>mBase是在ContextWrapper构造的时候传递进来的，那么在ContextWrapper构造的时候可以找到答案</em><br>什么时候会构造ContextWrapper呢？它的子类<code>Application</code>，<code>Service</code>等被创建的时候。</p>
<p>可以在App的主线程<code>AcitivityThread</code>的<code>performLaunchActivit</code>方法里面找到答案；更详细的解析可以参考老罗的<a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="external"> Android应用程序启动过程源代码分析</a></p>
<p>好了，我们姑且当作已经知道Context.startActivity最终使用了ContextImpl里面的方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                <span class="string">"Calling startActivity() from outside of an Activity "</span></span><br><span class="line">                + <span class="string">" context requires the FLAG_ACTIVITY_NEW_TASK flag."</span></span><br><span class="line">                + <span class="string">" Is this really what you want?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">        getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">        (Activity)<span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码相当简单；我们知道了两件事：</p>
<ol>
<li>其一，我们知道了在Service等非Activity的Context里面启动Activity为什么需要添加<code>FLAG_ACTIVITY_NEW_TASK</code>；</li>
<li>其二，真正的<code>startActivity</code>使用了<code>Instrumentation</code>类的<code>execStartActivity</code>方法；继续跟踪：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ... 省略无关代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess();</span><br><span class="line">        <span class="comment">// ----------------look here!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们发现真正调用的是<code>ActivityManagerNative</code>的<code>startActivity</code>方法；如果你不清楚<code>ActivityManager</code>，<code>ActivityManagerService</code>以及<code>ActivityManagerNative</code>之间的关系；建议先仔细阅读我之前关于Binder的文章 <a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a>。</p>
<h3 id="Activity-startActivity">Activity.startActivity</h3><p>Activity类的<code>startActivity</code>方法相比Context而言直观了很多；这个<code>startActivity</code>通过若干次调用辗转到达<code>startActivityForResult</code>这个方法，在这个方法内部有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instrumentation.ActivityResult ar =</span><br><span class="line">    mInstrumentation.execStartActivity(</span><br><span class="line">        <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">        intent, requestCode, options);</span><br></pre></td></tr></table></figure>
<p>可以看到，其实通过Activity和ContextImpl类启动Activity并无本质不同，他们都通过<code>Instrumentation</code>这个辅助类调用到了<code>ActivityManagerNative</code>的方法。</p>
<h2 id="Hook_AMS">Hook AMS</h2><p>OK，我们到现在知道；其实<code>startActivity</code>最终通过<code>ActivityManagerNative</code>这个方法远程调用了<code>AMS</code>的<code>startActivity</code>方法。那么这个<code>ActivityManagerNative</code>是什么呢？</p>
<p>ActivityManagerNative实际上就是<code>ActivityManagerService</code>这个远程对象的Binder代理对象；每次需要与AMS打交道的时候，需要借助这个代理对象通过驱动进而完成IPC调用。</p>
<p>我们继续看<code>ActivityManagerNative</code>的<code>getDefault()</code>方法做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gDefault</code>这个静态变量的定义如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    protected IActivityManager create() &#123;</span><br><span class="line">        IBinder b = ServiceManager.getService("activity</span><br><span class="line">        IActivityManager am = asInterface(</span><br><span class="line">        return am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于整个Framework与AMS打交道是如此频繁，framework使用了一个单例把这个<code>AMS</code>的代理对象保存了起来；这样只要需要与<code>AMS</code>进行IPC调用，获取这个单例即可。这是<code>AMS</code>这个系统服务与其他普通服务的不同之处，也是我们不通过Binder Hook的原因——我们只需要简单地Hook掉这个单例即可。</p>
<p>这里还有一点小麻烦：Android不同版本之间对于如何保存这个单例的代理对象是不同的；Android 2.x系统直接使用了一个简单的静态变量存储，Android 4.x以上抽象出了一个Singleton类；具体的差异可以使用<code>grepcode</code>进行比较：<a href="http://grepcode.com/file_/repository.grepcode.com/java/ext/com.google.android/android/4.0.1_r1/android/app/ActivityManagerNative.java/?v=diff&amp;id2=2.3.3_r1" target="_blank" rel="external">差异</a></p>
<p>我们以4.x以上的代码为例说明如何Hook掉<code>AMS</code>；方法使用的动态代理，如果有不理解的，可以参考之前的系列文章<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Android插件化原理解析——Hook机制之动态代理</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; activityManagerNativeClass = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 gDefault 这个字段, 想办法替换它</span></span><br><span class="line">Field gDefaultField = activityManagerNativeClass.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">gDefaultField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object gDefault = gDefaultField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.x以上的gDefault是一个 android.util.Singleton对象; 我们取出这个单例里面的字段</span></span><br><span class="line">Class&lt;?&gt; singleton = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line">Field mInstanceField = singleton.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityManagerNative 的gDefault对象里面原始的 IActivityManager对象</span></span><br><span class="line">Object rawIActivityManager = mInstanceField.get(gDefault);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个这个对象的代理对象, 然后替换这个字段, 让我们的代理对象帮忙干活</span></span><br><span class="line">Class&lt;?&gt; iActivityManagerInterface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line">Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iActivityManagerInterface &#125;, <span class="keyword">new</span> IActivityManagerHandler(rawIActivityManager));</span><br><span class="line">mInstanceField.set(gDefault, proxy);</span><br></pre></td></tr></table></figure>
<p>好了，我们hook成功之后启动Activity看看会发生什么：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ <span class="function"><span class="keyword">method</span>:</span>activityResumed called <span class="keyword">with</span> args:[android.os.BinderProxy@<span class="number">9</span>bc71b2]</span><br><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ <span class="function"><span class="keyword">method</span>:</span>activityIdle called <span class="keyword">with</span> args:[android.os.BinderProxy@<span class="number">9</span>bc71b2, null, <span class="keyword">false</span>]</span><br><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ <span class="function"><span class="keyword">method</span>:</span>startActivity called <span class="keyword">with</span> args:[android.app.ActivityThread$ApplicationThread@<span class="number">17</span>e750c, com.weishu.upf.ams_pms_hook.app, Intent <span class="comment">&#123; act=android.intent.action.VIEW dat=http://wwww.baidu.com/... &#125;</span>, null, android.os.BinderProxy@<span class="number">9</span>bc71b2, null, -<span class="number">1</span>, <span class="number">0</span>, null, null]</span><br><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ <span class="function"><span class="keyword">method</span>:</span>activityPaused called <span class="keyword">with</span> args:[android.os.BinderProxy@<span class="number">9</span>bc71b2]</span><br></pre></td></tr></table></figure>
<p>可以看到，简单的几行代码，<code>AMS</code>已经被我们完全劫持了!! 至于劫持了能干什么，自己发挥想象吧~ </p>
<p>DroidPlugin关于<code>AMS</code>的Hook，可以查看<code>IActivityManagerHook</code>这个类，它处理了我上述所说的兼容性问题，其他原理相同。另外，也许有童鞋有疑问了，你用<code>startActivity</code>为例怎么能确保Hook掉这个静态变量之后就能保证所有使用<code>AMS</code>的入口都被Hook了呢？</p>
<p>答曰：无他，唯手熟尔。</p>
<p>Android Framewrok层对于四大组件的处理，调用<code>AMS</code>服务的时候，全部都是通过使用这种方式；若有疑问可以自行查看源码。你可以从<code>Context</code>类的startActivity, startService,bindService, registerBroadcastReceiver, getContentResolver 等等入口进行跟踪，最终都会发现它们都会使用ActivityManagerNative的这个<code>AMS</code>代理对象来完成对远程AMS的访问。</p>
<h2 id="PMS获取过程">PMS获取过程</h2><p><code>PMS</code>的获取也是通过Context完成的，具体就是<code>getPackageManager</code>这个方法；我们姑且当作已经知道了Context的实现在ContextImpl类里面，直奔<code>ContextImpl</code>类的<code>getPackageManager</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    <span class="keyword">if</span> (pm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Doesn't matter if we make more than one instance.</span></span><br><span class="line">        <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> ApplicationPackageManager(<span class="keyword">this</span>, pm));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里干了两件事：</p>
<ol>
<li>真正的<code>PMS</code>的代理对象在<code>ActivityThread</code>类里面</li>
<li><code>ContextImpl</code>通过<code>ApplicationPackageManager</code>对它还进行了一层包装</li>
</ol>
<p>我们继续查看<code>ActivityThread</code>类的<code>getPackageManager</code>方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder b = ServiceManager.getService(<span class="string">"package"</span>);</span><br><span class="line">    sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">    <span class="keyword">return</span> sPackageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，和<code>AMS</code>一样，<code>PMS</code>的Binder代理对象也是一个全局变量存放在一个静态字段中；我们可以如法炮制，Hook掉PMS。</p>
<p>现在我们的目的很明切，如果需要Hook <code>PMS</code>有两个地方需要Hook掉：</p>
<ol>
<li><code>ActivityThread</code>的静态字段<code>sPackageManager</code></li>
<li>通过Context类的<code>getPackageManager</code>方法获取到的<code>ApplicationPackageManager</code>对象里面的<code>mPM</code>字段。</li>
</ol>
<h2 id="Hook_PMS">Hook PMS</h2><p>现在使用代理Hook应该是轻车熟路了吧，通过上面的分析，我们Hook两个地方；代码信手拈来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取全局的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ActivityThread里面原始的 sPackageManager</span></span><br><span class="line">Field sPackageManagerField = activityThreadClass.getDeclaredField(<span class="string">"sPackageManager"</span>);</span><br><span class="line">sPackageManagerField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备好代理对象, 用来替换原始的对象</span></span><br><span class="line">Class&lt;?&gt; iPackageManagerInterface = Class.forName(<span class="string">"android.content.pm.IPackageManager"</span>);</span><br><span class="line">Object proxy = Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iPackageManagerInterface &#125;,</span><br><span class="line">        <span class="keyword">new</span> HookHandler(sPackageManager));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 替换掉ActivityThread里面的 sPackageManager 字段</span></span><br><span class="line">sPackageManagerField.set(currentActivityThread, proxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 替换 ApplicationPackageManager里面的 mPM对象</span></span><br><span class="line">PackageManager pm = context.getPackageManager();</span><br><span class="line">Field mPmField = pm.getClass().getDeclaredField(<span class="string">"mPM"</span>);</span><br><span class="line">mPmField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">mPmField.set(pm, proxy);</span><br></pre></td></tr></table></figure>
<p>好了，Hook完毕我们验证以下结论；调用一下<code>PMS</code>的<code>getInstalledApplications</code>方法，打印日志如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">03</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">27.187</span>    <span class="number">8306</span>-<span class="number">8306</span>/com.weishu.upf.ams_pms_hook.app D/IActivityManagerHandler﹕ hey, baby; you are hook!!</span><br><span class="line"><span class="number">03</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">27.187</span>    <span class="number">8306</span>-<span class="number">8306</span>/com.weishu.upf.ams_pms_hook.app D/IActivityManagerHandler﹕ method:getInstalledApplications called with args:[<span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>OK，我们又成功劫持了<code>PackageManager</code>！！DroidPlugin 处理PMS的代码可以在<code>IPackageManagerHook</code>查看。</p>
<p>在结束讲解PackageManager的Hook之前，我们需要说明一点；那就是<code>Context</code>的实现类里面没有使用静态全局变量来保存<code>PMS</code>的代理对象，而是每拥有一个<code>Context</code>的实例就持有了一个<code>PMS</code>代理对象的引用；所以这里有个很蛋疼的事情，那就是我们如果想要完全Hook住<code>PMS</code>，需要精确控制整个进程内部创建的<code>Context</code>对象；所幸，插件框架中，插件的Activity，Service，ContentProvider，Broadcast等所有使用到Context的地方，都是由框架控制创建的；因此我们要小心翼翼地替换掉所有这些对象持有的<code>PMS</code>代理对象。</p>
<p>我前面也提到过，<strong>静态变量和单例</strong>都是良好的Hook点，这里很好地反证了这句话：想要Hook掉一个实例变量该是多么麻烦!</p>
<h2 id="小结">小结</h2><p>写到这里，关于DroidPlugin的Hook技术的讲解已经完结了；我相信读者或多或少地认识到，其实Hook并不是一项神秘的技术；一个干净，透明的框架少不了AOP，而AOP也少不了Hook。</p>
<p>我所讲解的Hook仅仅使用反射和动态代理技术，更加强大的Hook机制可以进行<strong>字节码编织</strong>，比如J2EE广泛使用了cglib和asm进行AOP编程；而Android上现有的插件框架还是加载编译时代码，采用动态生成类的技术理论上也是可行的；之前有一篇文章<a href="https://segmentfault.com/a/1190000004077469" target="_blank" rel="external">Android动态加载黑科技 动态创建Activity模式</a>，就讲述了这种方式；现在全球的互联网公司不排除有用这种技术实现插件框架的可能 ；我相信不远的未来，这种技术也会在Android上大放异彩。</p>
<p>了解完Hook技术之后，接下来的系列文章会讲述DroidPlugin对Android四大组件在插件系统上的处理，插件框架对于这一部分的实现是DroidPlugin的精髓，Hook只不过是工具而已。学习这部分内容需要对于Activity，Service，Broadcast以及ContentProvider的工作机制有一定的了解，因此我也会在必要的时候穿插讲解一些Android Framework的知识；我相信这一定会对读者大有裨益。</p>
<p>喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>和我的 <a href="http://weishu.me">博客</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在前面的文章中我们介绍了DroidPlugin的Hook机制，也就是<strong>代理方式</strong>和<strong>Binder Hook</strong>；插件框架通过AOP实现了插件使用和开发的透明性。在讲述DroidPlugin如何实现四大组件的插件化之前，有必要说明一下它对ActivityManagerServiche以及PackageManagerService的Hook方式（以下简称AMS，PMS）。</p>
<p>ActivityManagerService对于FrameWork层的重要性不言而喻，Android的四大组件无一不与它打交道：</p>
<ol>
<li><code>startActivity</code>最终调用了AMS的<code>startActivity</code>系列方法，实现了Activity的启动；Activity的生命周期回调，也在AMS中完成；</li>
<li><code>startService,bindService</code>最终调用到AMS的startService和bindService方法；</li>
<li>动态广播的注册和接收在<code>AMS</code>中完成（静态广播在<code>PMS</code>中完成）</li>
<li><code>getContentResolver</code>最终从<code>AMS</code>的<code>getContentProvider</code>获取到ContentProvider</li>
</ol>
<p>而<code>PMS</code>则完成了诸如权限校捡(<code>checkPermission,checkUidPermission</code>)，Apk meta信息获取(<code>getApplicationInfo</code>等)，四大组件信息获取(<code>query</code>系列方法)等重要功能。</p>
<p>在上文<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Android插件化原理解析——Hook机制之Binder Hook</a>中讲述了DroidPlugin的Binder Hook机制；我们知道<code>AMS</code>和<code>PMS</code>就是以Binder方式提供给应用程序使用的系统服务，理论上我们也可以采用这种方式Hook掉它们。但是由于这两者使用得如此频繁，Framework给他们了一些“特别优待”，这也给了我们相对于Binder Hook更加稳定可靠的hook方式。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android插件化原理解析——Hook机制之Binder Hook]]></title>
    <link href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/"/>
    <id>http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/</id>
    <published>2016-02-16T11:22:45.000Z</published>
    <updated>2016-02-18T03:24:50.000Z</updated>
    <content type="html"><![CDATA[<p>Android系统通过Binder机制给应用程序提供了一系列的系统服务，诸如<code>ActivityManagerService</code>，<code>ClipboardManager</code>， <code>AudioManager</code>等；这些广泛存在系统服务给应用程序提供了诸如任务管理，音频，视频等异常强大的功能。</p>
<p>插件框架作为各个插件的管理者，为了使得插件能够<strong>无缝地</strong>使用这些系统服务，自然会对这些系统服务做出一定的改造(Hook)，使得插件的开发和使用更加方便，从而大大降低插件的开发和维护成本。比如，Hook住<code>ActivityManagerService</code>可以让插件无缝地使用<code>startActivity</code>方法而不是使用特定的方式(比如that语法)来启动插件或者主程序的任意界面。</p>
<p>我们把这种Hook系统服务的机制称之为Binder Hook，因为本质上这些服务提供者都是存在于系统各个进程的Binder对象。因此，要理解接下来的内容必须了解Android的Binder机制，可以参考我之前的文章<a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a></p>
<a id="more"></a>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的<code>binder-hook</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<h2 id="系统服务的获取过程">系统服务的获取过程</h2><p>我们知道系统的各个远程service对象都是以Binder的形式存在的，而这些Binder有一个管理者，那就是<code>ServiceManager</code>；我们要Hook掉这些service，自然要从这个<code>ServiceManager</code>下手，不然星罗棋布的Binder广泛存在于系统的各个角落，要一个个找出来还真是大海捞针。</p>
<p>回想一下我们使用系统服务的时候是怎么干的，想必这个大家一定再熟悉不过了：通过<code>Context</code>对象的<code>getSystemService</code>方法；比如要使用<code>ActivityManager</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br></pre></td></tr></table></figure>
<p>可是这个貌似跟<code>ServiceManager</code>没有什么关系啊？我们再查看<code>getSystemService</code>方法；(Context的实现在<code>ContextImpl</code>里面)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name);</span><br><span class="line">    <span class="keyword">return</span> fetcher == <span class="keyword">null</span> ? <span class="keyword">null</span> : fetcher.getService(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，所有的service对象都保存在一张<code>map</code>里面，我们再看这个map是怎么初始化的：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registerService<span class="list">(<span class="keyword">ACCOUNT_SERVICE</span>, new ServiceFetcher<span class="list">()</span> &#123;</span><br><span class="line">                public Object createService<span class="list">(<span class="keyword">ContextImpl</span> ctx)</span> &#123;</span><br><span class="line">                    IBinder b = ServiceManager.getService<span class="list">(<span class="keyword">ACCOUNT_SERVICE</span>)</span><span class="comment">;</span></span><br><span class="line">                    IAccountManager service = IAccountManager.Stub.asInterface<span class="list">(<span class="keyword">b</span>)</span><span class="comment">;</span></span><br><span class="line">                    return new AccountManager<span class="list">(<span class="keyword">ctx</span>, service)</span><span class="comment">;</span></span><br><span class="line">                &#125;&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在<code>ContextImpl</code>的静态初始化块里面，有的Service是像上面这样初始化的；可以看到，确实使用了<code>ServiceManager</code>；当然还有一些service并没有直接使用<code>ServiceManager</code>，而是做了一层包装并返回了这个包装对象，比如我们的<code>ActivityManager</code>，它返回的是<code>ActivityManager</code>这个包装对象：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">registerService<span class="list">(<span class="keyword">ACTIVITY_SERVICE</span>, new ServiceFetcher<span class="list">()</span> &#123;</span><br><span class="line">                public Object createService<span class="list">(<span class="keyword">ContextImpl</span> ctx)</span> &#123;</span><br><span class="line">                    return new ActivityManager<span class="list">(<span class="keyword">ctx</span>.getOuterContext<span class="list">()</span>, ctx.mMainThread.getHandler<span class="list">()</span>)</span><span class="comment">;</span></span><br><span class="line">                &#125;&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>但是在<code>ActivityManager</code>这个类内部，也使用了<code>ServiceManager</code>；具体来说，因为ActivityManager里面所有的核心操作都是使用<code>ActivityManagerNative.getDefault()</code>完成的。那么这个语句干了什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line">            IActivityManager am = asInterface(b);</span><br><span class="line">            <span class="keyword">return</span> am;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>因此，通过分析我们得知，系统Service的使用其实就分为两步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IBinder b = ServiceManager.getService(<span class="string">"service_name"</span>); <span class="comment">// 获取原始的IBinder对象</span></span><br><span class="line">IXXInterface in = IXXInterface.Stub.asInterface(b); <span class="comment">// 转换为Service接口</span></span><br></pre></td></tr></table></figure>
<h2 id="寻找Hook点">寻找Hook点</h2><p>在<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">插件框架原理解析——Hook机制之动态代理</a>里面我们说过，Hook分为三步，最关键的一步就是寻找Hook点。我们现在已经搞清楚了系统服务的使用过程，那么就需要找出在这个过程中，在哪个环节是最合适hook的。</p>
<p>由于系统服务的使用者都是对第二步获取到的<code>IXXInterface</code>进行操作，因此如果我们要hook掉某个系统服务，<strong>只需要把第二步的<code>asInterface</code>方法返回的对象修改为为我们Hook过的对象就可以了。</strong></p>
<h3 id="asInterface过程">asInterface过程</h3><p>接下来我们分析<code>asInterface</code>方法，然后想办法把这个方法的返回值修改为我们Hook过的系统服务对象。这里我们以系统剪切版服务为例，源码位置为<code>android.content.IClipboard</code>,<code>IClipboard.Stub.asInterface</code>方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.content.<span class="function">IClipboard <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); <span class="comment">// Hook点</span></span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> android.content.IClipboard))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.content.IClipboard) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android.content.IClipboard.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的意思就是：先查看本进程是否存在这个Binder对象，如果有那么直接就是本进程调用了；如果不存在那么创建一个代理对象，让代理对象委托驱动完成跨进程调用。</p>
<p>观察这个方法，前面的那个if语句判空返回肯定动不了手脚；最后一句调用构造函数然后直接返回我们也是无从下手，要修改<code>asInterface</code>方法的返回值，我们唯一能做的就是从这一句下手：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); <span class="comment">// Hook点</span></span><br></pre></td></tr></table></figure>
<p>我们可以尝试修改这个<code>obj</code>对象的<code>queryLocalInterface</code>方法的返回值，并保证这个返回值符合接下来的<code>if</code>条件检测，那么就达到了修改<code>asInterface</code>方法返回值的目的。</p>
<p>而这个<code>obj</code>对象刚好是我们第一步返回的<code>IBinder</code>对象，接下来我们尝试对这个<code>IBinder</code>对象的<code>queryLocalInterface</code>方法进行hook。</p>
<h3 id="getService过程">getService过程</h3><p>上文分析得知，我们想要修改<code>IBinder</code>对象的<code>queryLocalInterface</code>方法；获取<code>IBinder</code>对象的过程如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">IBinder</span> <span class="keyword">b </span>= ServiceManager.getService(<span class="string">"service_name"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>因此，我们希望能修改这个<code>getService</code>方法的返回值，让这个方法返回一个我们伪造过的<code>IBinder</code>对象；这样，我们可以在自己伪造的<code>IBinder</code>对象的<code>queryLocalInterface</code>方法作处理，进而使得<code>asInterface</code>方法返回在<code>queryLocalInterface</code>方法里面处理过的值，最终实现hook系统服务的目的。</p>
<p>在跟踪这个<code>getService</code>方法之前我们思考一下，由于系统服务是一系列的远程Service，它们的本体，也就是Binder本地对象一般都存在于某个单独的进程，在这个进程之外的其他进程存在的都是这些Binder本地对象的代理。因此在我们的进程里面，存在的也只是这个Binder代理对象，我们也只能对这些Binder代理对象下手。(如果这一段看不懂，建议不要往下看了，先看<a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a>)</p>
<p>然后，这个<code>getService</code>是一个静态方法，如果此方法什么都不做，拿到Binder代理对象之后直接返回；那么我们就无能为力了：我们没有办法拦截一个静态方法，也没有办法获取到这个静态方法里面的局部变量(即我们希望修改的那个Binder代理对象)。</p>
<p>接下来就可以看这个<code>getService</code>的代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder service = sCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getIServiceManager().getService(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"error in getService"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>天无绝人之路！<code>ServiceManager</code>为了避免每次都进行跨进程通信，把这些Binder代理对象缓存在一张<code>map</code>里面。</p>
<p>我们可以替换这个map里面的内容为Hook过的<code>IBinder</code>对象，由于系统在<code>getService</code>的时候每次都会优先查找缓存，因此返回给使用者的都是被我们修改过的对象，从而达到瞒天过海的目的。</p>
<p>总结一下，要达到修改系统服务的目的，我们需要如下两步：</p>
<ol>
<li>首先肯定需要<strong>伪造一个系统服务对象</strong>，接下来就要想办法让<code>asInterface</code>能够返回我们的这个伪造对象而不是原始的系统服务对象。</li>
<li>通过上文分析我们知道，只要让<code>getService</code>返回<code>IBinder</code>对象的<code>queryLocalInterface</code>方法直接返回我们伪造过的系统服务对象就能达到目的。所以，我们需要<strong>伪造一个IBinder对象</strong>，主要是修改它的<code>queryLocalInterface</code>方法，让它返回我们伪造的系统服务对象；然后把这个伪造对象放置在<code>ServiceManager</code>的缓存<code>map</code>里面即可。</li>
</ol>
<p>我们通过Binder机制的<em>优先查找本地Binder对象</em>的这个特性达到了Hook掉系统服务对象的目的。因此<code>queryLocalInterface</code>也失去了它原本的意义(只查找本地Binder对象，没有本地对象返回null)，这个方法只是一个傀儡，是我们实现hook系统对象的桥梁：我们通过这个“漏洞”让<code>asInterface</code>永远都返回我们伪造过的对象。由于我们接管了<code>asInterface</code>这个方法的全部，我们伪造过的这个系统服务对象不能是只拥有本地Binder对象(原始<code>queryLocalInterface</code>方法返回的对象)的能力，还要有Binder代理对象操纵驱动的能力。</p>
<p>接下来我们就以Hook系统的剪切版服务为例，用实际代码来说明，如何Hook掉系统服务。</p>
<h2 id="Hook系统剪切版服务">Hook系统剪切版服务</h2><h3 id="伪造剪切版服务对象">伪造剪切版服务对象</h3><p>首先我们用代理的方式伪造一个剪切版服务对象，关于如何使用代理的方式进行hook以及其中的原理，可以查看<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">插件框架原理解析——Hook机制之动态代理</a>。</p>
<p>具体代码如下，我们用动态代理的方式Hook掉了<code>hasPrimaryClip()</code>，<code>getPrimaryClip()</code>这两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderHookHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BinderHookHandler"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始的Service对象 (IInterface)</span></span><br><span class="line">    Object base;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinderHookHandler</span><span class="params">(IBinder base, Class&lt;?&gt; stubClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method asInterfaceMethod = stubClass.getDeclaredMethod(<span class="string">"asInterface"</span>, IBinder.class);</span><br><span class="line">            <span class="comment">// IClipboard.Stub.asInterface(base);</span></span><br><span class="line">            <span class="keyword">this</span>.base = asInterfaceMethod.invoke(<span class="keyword">null</span>, base);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"hooked failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@TargetApi</span>(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把剪切版的内容替换为 "you are hooked"</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"getPrimaryClip"</span>.equals(method.getName())) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"hook getPrimaryClip"</span>);</span><br><span class="line">            <span class="keyword">return</span> ClipData.newPlainText(<span class="keyword">null</span>, <span class="string">"you are hooked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 欺骗系统,使之认为剪切版上一直有内容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"hasPrimaryClip"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method.invoke(base, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，我们拿到原始的<code>IBinder</code>对象之后，如果我们希望使用被Hook之前的系统服务，并不能直接使用这个<code>IBinder</code>对象，而是需要使用<code>asInterface</code>方法将它转换为<code>IClipboard</code>接口；因为<code>getService</code>方法返回的<code>IBinder</code>实际上是一个<strong>裸Binder代理对象</strong>，它只有与驱动打交道的能力，但是它并不能独立工作，需要人指挥它；<code>asInterface</code>方法返回的<code>IClipboard.Stub.Proxy</code>类的对象通过操纵这个裸<code>BinderProxy</code>对象从而实现了具体的<code>IClipboard</code>接口定义的操作。</p>
<h3 id="伪造IBinder_对象">伪造<code>IBinder</code> 对象</h3><p>在上一步中，我们已经伪造好了系统服务对象，现在要做的就是想办法让<code>asInterface</code>方法返回我们伪造的对象了；我们伪造一个<code>IBinder</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxyHookHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BinderProxyHookHandler"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绝大部分情况下,这是一个BinderProxy对象</span></span><br><span class="line">    <span class="comment">// 只有当Service和我们在同一个进程的时候才是Binder本地对象</span></span><br><span class="line">    <span class="comment">// 这个基本不可能</span></span><br><span class="line">    IBinder base;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; stub;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; iinterface;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinderProxyHookHandler</span><span class="params">(IBinder base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.base = base;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.stub = Class.forName(<span class="string">"android.content.IClipboard$Stub"</span>);</span><br><span class="line">            <span class="keyword">this</span>.iinterface = Class.forName(<span class="string">"android.content.IClipboard"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"queryLocalInterface"</span>.equals(method.getName())) &#123;</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, <span class="string">"hook queryLocalInterface"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里直接返回真正被Hook掉的Service接口</span></span><br><span class="line">            <span class="comment">// 这里的 queryLocalInterface 就不是原本的意思了</span></span><br><span class="line">            <span class="comment">// 我们肯定不会真的返回一个本地接口, 因为我们接管了 asInterface方法的作用</span></span><br><span class="line">            <span class="comment">// 因此必须是一个完整的 asInterface 过的 IInterface对象, 既要处理本地对象,也要处理代理对象</span></span><br><span class="line">            <span class="comment">// 这只是一个Hook点而已, 它原始的含义已经被我们重定义了; 因为我们会永远确保这个方法不返回null</span></span><br><span class="line">            <span class="comment">// 让 IClipboard.Stub.asInterface 永远走到if语句的else分支里面</span></span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(proxy.getClass().getClassLoader(),</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// asInterface 的时候会检测是否是特定类型的接口然后进行强制转换</span></span><br><span class="line">                    <span class="comment">// 因此这里的动态代理生成的类型信息的类型必须是正确的</span></span><br><span class="line">                    <span class="keyword">new</span> Class[] &#123; IBinder.class, IInterface.class, <span class="keyword">this</span>.iinterface &#125;,</span><br><span class="line">                    <span class="keyword">new</span> BinderHookHandler(base, stub));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"method:"</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> method.invoke(base, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用动态代理的方式伪造了一个跟原始<code>IBinder</code>一模一样的对象，然后在这个伪造的<code>IBinder</code>对象的<code>queryLocalInterface</code>方法里面返回了我们第一步创建的<strong>伪造过的系统服务对象</strong>；注意看注释，详细解释可以看<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">代码</a></p>
<h3 id="替换ServiceManager的IBinder对象">替换ServiceManager的<code>IBinder</code>对象</h3><p>现在就是万事具备，只欠东风了；我们使用反射的方式修改<code>ServiceManager</code>类里面缓存的Binder对象，使得<code>getService</code>方法返回我们伪造的<code>IBinder</code>对象，进而<code>asInterface</code>方法使用伪造<code>IBinder</code>对象的<code>queryLocalInterface</code>方法返回了我们伪造的系统服务对象。代码较简单，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String CLIPBOARD_SERVICE = <span class="string">"clipboard"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这一段的意思实际就是: ServiceManager.getService("clipboard");</span></span><br><span class="line"><span class="comment">// 只不过 ServiceManager这个类是@hide的</span></span><br><span class="line">Class&lt;?&gt; serviceManager = Class.forName(<span class="string">"android.os.ServiceManager"</span>);</span><br><span class="line">Method getService = serviceManager.getDeclaredMethod(<span class="string">"getService"</span>, String.class);</span><br><span class="line"><span class="comment">// ServiceManager里面管理的原始的Clipboard Binder对象</span></span><br><span class="line"><span class="comment">// 一般来说这是一个Binder代理对象</span></span><br><span class="line">IBinder rawBinder = (IBinder) getService.invoke(<span class="keyword">null</span>, CLIPBOARD_SERVICE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook 掉这个Binder代理对象的 queryLocalInterface 方法</span></span><br><span class="line"><span class="comment">// 然后在 queryLocalInterface 返回一个IInterface对象, hook掉我们感兴趣的方法即可.</span></span><br><span class="line">IBinder hookedBinder = (IBinder) Proxy.newProxyInstance(serviceManager.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; IBinder.class &#125;,</span><br><span class="line">        <span class="keyword">new</span> BinderProxyHookHandler(rawBinder));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把这个hook过的Binder代理对象放进ServiceManager的cache里面</span></span><br><span class="line"><span class="comment">// 以后查询的时候 会优先查询缓存里面的Binder, 这样就会使用被我们修改过的Binder了</span></span><br><span class="line">Field cacheField = serviceManager.getDeclaredField(<span class="string">"sCache"</span>);</span><br><span class="line">cacheField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Map&lt;String, IBinder&gt; cache = (Map) cacheField.get(<span class="keyword">null</span>);</span><br><span class="line">cache.put(CLIPBOARD_SERVICE, hookedBinder);</span><br></pre></td></tr></table></figure>
<p>接下来，在app里面使用剪切版，比如长按进行粘贴之后，剪切版的内容永远都是<code>you are hooked</code>了；这样，我们Hook系统服务的目的宣告完成！详细的代码参见 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">github</a>。</p>
<p>也许你会问，插件框架会这么hook吗？如果不是那么插件框架hook这些干什么？插件框架当然不会做替换文本这么无聊的事情，DroidPlugin插件框架管理插件使得插件就像是主程序一样，因此插件需要使用主程序的剪切版，插件之间也会共用剪切版；其他的一些系统服务也类似，这样就可以达到插件和宿主程序之间的天衣服缝，水乳交融！另外，<code>ActivityManager</code>以及<code>PackageManager</code>这两个系统服务虽然也可以通过这种方式hook，但是由于它们的重要性和特殊性，DroidPlugin使用了另外一种方式，我们会单独讲解。</p>
<p>喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a> 和我的 <a href="http://weishu.me/">博客</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android系统通过Binder机制给应用程序提供了一系列的系统服务，诸如<code>ActivityManagerService</code>，<code>ClipboardManager</code>， <code>AudioManager</code>等；这些广泛存在系统服务给应用程序提供了诸如任务管理，音频，视频等异常强大的功能。</p>
<p>插件框架作为各个插件的管理者，为了使得插件能够<strong>无缝地</strong>使用这些系统服务，自然会对这些系统服务做出一定的改造(Hook)，使得插件的开发和使用更加方便，从而大大降低插件的开发和维护成本。比如，Hook住<code>ActivityManagerService</code>可以让插件无缝地使用<code>startActivity</code>方法而不是使用特定的方式(比如that语法)来启动插件或者主程序的任意界面。</p>
<p>我们把这种Hook系统服务的机制称之为Binder Hook，因为本质上这些服务提供者都是存在于系统各个进程的Binder对象。因此，要理解接下来的内容必须了解Android的Binder机制，可以参考我之前的文章<a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a></p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="binder" scheme="http://weishu.me/tags/binder/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[提升markdown的中文输入效率]]></title>
    <link href="http://weishu.me/2016/02/01/avoid-switching-keyboard-in-markdown/"/>
    <id>http://weishu.me/2016/02/01/avoid-switching-keyboard-in-markdown/</id>
    <published>2016-02-01T08:15:56.000Z</published>
    <updated>2016-02-16T11:37:47.000Z</updated>
    <content type="html"><![CDATA[<p>Markdown这种格式的出现大大提升了写作的效率，但是它对于非英文的用户其实并不友好：每当我们需要使用<code>#[-</code>等标志符的时候，需要不断地切换输入法。</p>
<p>首先，切换输入法(就算是按<code>shift</code>键)让我们的思维不连贯；其次，一旦中间有一次切换出错，那么又有撤销的成本；我相信每一个非英文markdown的使用者都有这种困惑；实际想要达到的效果如下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201602markdown_keymap_remapping.gif" alt="效果图"></p>
<a id="more"></a>
<p>避免输入法切换最简单的办法就是把markdown使用的那些特定字符<code>!-[]#*()</code>，直接使用半角符号代替全角符号；完成这个功能最好的角色是输入法；但目前除了可以定制的鼠须管等能完成，其他的国产输入以及系统输入法都不支持；在第三方输入法支持这个功能之前，我这里给出一个简单的方案。</p>
<h3 id="如果你使用鼠须管">如果你使用鼠须管</h3><p>鼠须管/小狼嚎 输入法是可以定制的，如果你是这种输入法的用户，那么恭喜你，实现方式非常简单；修改一下配置即可，具体做法见<a href="http://irising.me/2013/07/17627/" target="_blank" rel="external">调整「鼠须管」实现高效的Markdown输入</a></p>
<h3 id="如果你使用Mac">如果你使用Mac</h3><p>如果你使用第三方输入法或者mac的系统输入法，那么我们可以通过修改键盘映射来解决这个问题：把全角的markdown映射为半角符号。具体做法如下：</p>
<h5 id="安装Karabiner软件">安装Karabiner软件</h5><p>下载地址点<a href="https://pqrs.org/osx/karabiner/" target="_blank" rel="external">这里</a>；按照步骤安装，注意开启之后需要在系统设置里面给它使用辅助功能权限</p>
<h5 id="设置键盘映射">设置键盘映射</h5><p>首先，打开Karabiner软件，选择<code>Misc&amp;Uninstall</code>选项卡，如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1454310098796.png" width="740"></p>
<p>然后，点击上图标识的<code>open private.xml</code>那个按钮，用文本编辑器打开这个文件：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1454310263101.png" width="574"></p>
<p>接着去 <a href="https://gist.github.com/tiann/9068fd34f44337e8dcfb" target="_blank" rel="external">gist</a>上把<code>markdown_keyboard_remapping.xml</code>里面的代码copy到这个文件里面，全部替换即可(代码有点长，我就不贴了，自行<a href="https://gist.github.com/tiann/9068fd34f44337e8dcfb" target="_blank" rel="external">下载</a>)：</p>
<p>最后，打开Karabiner软件的第一个选项卡，重新加载配置就完成了，如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1454310388700.png" width="771"></p>
<h3 id="如果你使用Windows">如果你使用Windows</h3><p>Windows下面有神器<code>AutoHotKey</code>，解决这个完全不在话下；与Mac下面简单粗暴地直接把全角符号替换为半角符号不同，AHK可以保留原来的方案，用<code>alt ＋ 符号</code>来输入需要的半角符号；这样两种可以共存。</p>
<ol>
<li>首先，安装AHK软件，下载点<a href="https://gist.github.com/tiann/9068fd34f44337e8dcfb" target="_blank" rel="external">这里</a></li>
<li>然后下载文件<a href="https://gist.github.com/tiann/9068fd34f44337e8dcfb" target="_blank" rel="external">markdown_keyboard_remapping.ahk</a></li>
</ol>
<p>接着双击这个文件，整个过程就完成了；最好把这个文件加入开机启动，这样每次开机就能用了。</p>
<p>Windows下面的使用方法是<code>alt ＋ 数字键/符号键</code>；比如想输入<code>[</code>，可以在任何输入法下直接使用<code>alt ＋ [</code>；如果想输入<code>#</code>，可以直接使用<code>alt ＋ 3</code>。</p>
<p>通过这种设置，我们使用markdown写作的时候就流畅多了!避免了繁琐的各种切换，真正享受到markdown格式的好处，Have Fun!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Markdown这种格式的出现大大提升了写作的效率，但是它对于非英文的用户其实并不友好：每当我们需要使用<code>#[-</code>等标志符的时候，需要不断地切换输入法。</p>
<p>首先，切换输入法(就算是按<code>shift</code>键)让我们的思维不连贯；其次，一旦中间有一次切换出错，那么又有撤销的成本；我相信每一个非英文markdown的使用者都有这种困惑；实际想要达到的效果如下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201602markdown_keymap_remapping.gif" alt="效果图"></p>]]>
    
    </summary>
    
      <category term="markdown" scheme="http://weishu.me/tags/markdown/"/>
    
      <category term="实用技巧" scheme="http://weishu.me/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android插件化原理解析——Hook机制之动态代理]]></title>
    <link href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/"/>
    <id>http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/</id>
    <published>2016-01-28T12:27:13.000Z</published>
    <updated>2016-03-28T01:46:08.000Z</updated>
    <content type="html"><![CDATA[<p>使用代理机制进行API Hook进而达到方法增强是框架的常用手段，比如J2EE框架Spring通过动态代理优雅地实现了AOP编程，极大地提升了Web开发效率；同样，插件框架也广泛使用了代理机制来增强系统API从而达到插件化的目的。本文将带你了解基于动态代理的Hook机制。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的<code>dynamic-proxy-hook</code>模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<h2 id="代理是什么">代理是什么</h2><p>为什么需要代理呢？其实这个代理与日常生活中的“代理”，“中介”差不多；比如你想海淘买东西，总不可能亲自飞到国外去购物吧，这时候我们使用第三方海淘服务比如惠惠购物助手等；同样拿购物为例，有时候第三方购物会有折扣比如当初的米折网，这时候我们可以少花点钱；当然有时候这个“代理”比较坑，坑我们的钱，坑我们的货。</p>
<p>从这个例子可以看出来，代理可以实现<strong>方法增强</strong>，比如常用的<em>日志</em>,<em>缓存</em>等；也可以实现方法拦截，通过代理方法修改原方法的参数和返回值，从而实现某种不可告人的目的～接下来我们用代码解释一下。<br><a id="more"></a></p>
<h2 id="静态代理">静态代理</h2><p>静态代理，是最原始的代理方式；假设我们有一个购物的接口，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    Object[] doShopping(<span class="keyword">long</span> money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它有一个原始的实现，我们可以理解为亲自，直接去商店购物：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingImpl</span> <span class="keyword">implements</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] doShopping(<span class="keyword">long</span> money) &#123;</span><br><span class="line">        System.out.println(<span class="string">"逛淘宝 ,逛商场,买买买!!"</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"花了%s块钱"</span>, money));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object[] &#123; <span class="string">"鞋子"</span>, <span class="string">"衣服"</span>, <span class="string">"零食"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，现在我们自己没时间但是需要买东西，于是我们就找了个代理帮我们买：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyShopping</span> <span class="keyword">implements</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Shopping base;</span><br><span class="line"></span><br><span class="line">    ProxyShopping(Shopping base) &#123;</span><br><span class="line">        <span class="keyword">this</span>.base = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] doShopping(<span class="keyword">long</span> money) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先黑点钱(修改输入参数)</span></span><br><span class="line">        <span class="keyword">long</span> readCost = (<span class="keyword">long</span>) (money * <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="string">"花了%s块钱"</span>, readCost));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帮忙买东西</span></span><br><span class="line">        Object[] things = base.doShopping(readCost);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偷梁换柱(修改返回值)</span></span><br><span class="line">        <span class="keyword">if</span> (things != <span class="keyword">null</span> &amp;&amp; things.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            things[<span class="number">0</span>] = <span class="string">"被掉包的东西!!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> things;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很不幸，我们找的这个代理有点坑，坑了我们的钱还坑了我们的货；先忍忍。</p>
<h2 id="动态代理">动态代理</h2><p>传统的静态代理模式需要为每一个需要代理的类写一个代理类，如果需要代理的类有几百个那不是要累死？为了更优雅地实现代理模式，JDK提供了动态代理方式，可以简单理解为JVM可以在运行时帮我们动态生成一系列的代理类，这样我们就不需要手写每一个静态的代理类了。依然以购物为例，用动态代理实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Shopping women = <span class="keyword">new</span> ShoppingImpl();</span><br><span class="line">    <span class="comment">// 正常购物</span></span><br><span class="line">    System.out.println(Arrays.toString(women.doShopping(<span class="number">100</span>)));</span><br><span class="line">    <span class="comment">// 招代理</span></span><br><span class="line">    women = (Shopping) Proxy.newProxyInstance(Shopping.class.getClassLoader(),</span><br><span class="line">            women.getClass().getInterfaces(), <span class="keyword">new</span> ShoppingHandler(women));</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(women.doShopping(<span class="number">100</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态代理主要处理<code>InvocationHandler</code>和<code>Proxy</code>类；完整代码可以见<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">github</a></p>
<h2 id="代理Hook">代理Hook</h2><p>我们知道代理有比原始对象更强大的能力，比如飞到国外买东西，比如坑钱坑货；那么很自然，如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，那么就可以在这个代理对象为所欲为了；修改参数，替换返回值，我们称之为Hook。</p>
<p>下面我们Hook掉<code>startActivity</code>这个方法，使得每次调用这个方法之前输出一条日志；（当然，这个输入日志有点点弱，只是为了展示原理；只要你想，你想可以替换参数，拦截这个<code>startActivity</code>过程，使得调用它导致启动某个别的Activity，指鹿为马！）</p>
<p>首先我们得找到被Hook的对象，我称之为Hook点；什么样的对象比较好Hook呢？自然是<strong>容易找到的对象</strong>。什么样的对象容易找到？<strong>静态变量和单例</strong>；在一个进程之内，静态变量和单例变量是相对不容易发生变化的，因此非常容易定位，而普通的对象则要么无法标志，要么容易改变。我们根据这个原则找到所谓的Hook点。</p>
<p>然后我们分析一下<code>startActivity</code>的调用链，找出合适的Hook点。我们知道对于<code>Context.startActivity</code>（Activity.startActivity的调用链与之不同），由于<code>Context</code>的实现实际上是<code>ContextImpl</code>;我们看<code>ConetxtImpl</code>类的<code>startActivity</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                <span class="string">"Calling startActivity() from outside of an Activity "</span></span><br><span class="line">                + <span class="string">" context requires the FLAG_ACTIVITY_NEW_TASK flag."</span></span><br><span class="line">                + <span class="string">" Is this really what you want?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">        getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">        (Activity)<span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，实际上使用了<code>ActivityThread</code>类的<code>mInstrumentation</code>成员的<code>execStartActivity</code>方法；注意到，<code>ActivityThread</code> 实际上是主线程，而主线程一个进程只有一个，因此这里是一个良好的Hook点。</p>
<p>接下来就是想要Hook掉我们的主线程对象，也就是把这个主线程对象里面的<code>mInstrumentation</code>给替换成我们修改过的代理对象；要替换主线程对象里面的字段，首先我们得拿到主线程对象的引用，如何获取呢？<code>ActivityThread</code>类里面有一个静态方法<code>currentActivityThread</code>可以帮助我们拿到这个对象类；但是<code>ActivityThread</code>是一个隐藏类，我们需要用反射去获取，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>拿到这个<code>currentActivityThread</code>之后，我们需要修改它的<code>mInstrumentation</code>这个字段为我们的代理对象，我们先实现这个代理对象，由于JDK动态代理只支持接口，而这个<code>Instrumentation</code>是一个类，没办法，我们只有手动写静态代理类，覆盖掉原始的方法即可。（<code>cglib</code>可以做到基于类的动态代理，这里先不介绍）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilInstrumentation</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"EvilInstrumentation"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ActivityThread中原始的对象, 保存起来</span></span><br><span class="line">    Instrumentation mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilInstrumentation</span><span class="params">(Instrumentation base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook之前, <span class="label">XXX到此一游!</span></span></span><br><span class="line">        Log.d(TAG, <span class="string">"\n执行了startActivity, 参数如下: \n"</span> + <span class="string">"who = ["</span> + who + <span class="string">"], "</span> +</span><br><span class="line">                <span class="string">"\ncontextThread = ["</span> + contextThread + <span class="string">"], \ntoken = ["</span> + token + <span class="string">"], "</span> +</span><br><span class="line">                <span class="string">"\ntarget = ["</span> + target + <span class="string">"], \nintent = ["</span> + intent +</span><br><span class="line">                <span class="string">"], \nrequestCode = ["</span> + requestCode + <span class="string">"], \noptions = ["</span> + options + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始调用原始的方法, 调不调用随你,但是不调用的话, 所有的startActivity都失效了.</span></span><br><span class="line">        <span class="comment">// 由于这个方法是隐藏的,因此需要使用反射调用;首先找到这个方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method execStartActivity = Instrumentation.class.getDeclaredMethod(</span><br><span class="line">                    <span class="string">"execStartActivity"</span>,</span><br><span class="line">                    Context.class, IBinder.class, IBinder.class, Activity.class, </span><br><span class="line">                    Intent.class, <span class="keyword">int</span>.class, Bundle.class);</span><br><span class="line">            execStartActivity.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (ActivityResult) execStartActivity.invoke(mBase, who, </span><br><span class="line">                    contextThread, token, target, intent, requestCode, options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 某该死的rom修改了  需要手动适配</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"do not support!!! pls adapt it"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ok，有了代理对象，我们要做的就是偷梁换柱！代码比较简单，采用反射直接修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attactContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">        Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">        Field currentActivityThreadField = activityThreadClass.getDeclaredField(<span class="string">"sCurrentActivityThread"</span>);</span><br><span class="line">        currentActivityThreadField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object currentActivityThread = currentActivityThreadField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到原始的 mInstrumentation字段</span></span><br><span class="line">        Field mInstrumentationField = activityThreadClass.getField(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">        mInstrumentationField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(currentActivityThread);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        Instrumentation evilInstrumentation = <span class="keyword">new</span> EvilInstrumentation(mInstrumentation);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 偷梁换柱</span></span><br><span class="line">        mInstrumentationField.set(currentActivityThread, evilInstrumentation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好了，我们启动一个Activity测试一下，结果如下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1453981415720.png" width="866"></p>
<p>可见，Hook确实成功了！这就是使用代理进行Hook的原理——偷梁换柱。整个Hook过程简要总结如下：</p>
<ol>
<li>寻找Hook点，原则是静态变量或者单例对象，尽量Hook pulic的对象和方法，非public不保证每个版本都一样，需要适配。</li>
<li>选择合适的代理方式，如果是接口可以用动态代理；如果是类可以手动写代理也可以使用cglib。</li>
<li>偷梁换柱——用代理对象替换原始对象</li>
</ol>
<p>完整代码参照：<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>；里面留有一个作业：我们目前仅Hook了<code>Context</code>类的<code>startActivity</code>方法，但是<code>Activity</code>类却使用了自己的<code>mInstrumentation</code>；你可以尝试Hook掉Activity类的<code>startActivity</code>方法。</p>
<p>喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>和我的 <a href="http://weishu.me">博客</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用代理机制进行API Hook进而达到方法增强是框架的常用手段，比如J2EE框架Spring通过动态代理优雅地实现了AOP编程，极大地提升了Web开发效率；同样，插件框架也广泛使用了代理机制来增强系统API从而达到插件化的目的。本文将带你了解基于动态代理的Hook机制。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework">understand-plugin-framework</a>，参考此项目的<code>dynamic-proxy-hook</code>模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<h2 id="代理是什么">代理是什么</h2><p>为什么需要代理呢？其实这个代理与日常生活中的“代理”，“中介”差不多；比如你想海淘买东西，总不可能亲自飞到国外去购物吧，这时候我们使用第三方海淘服务比如惠惠购物助手等；同样拿购物为例，有时候第三方购物会有折扣比如当初的米折网，这时候我们可以少花点钱；当然有时候这个“代理”比较坑，坑我们的钱，坑我们的货。</p>
<p>从这个例子可以看出来，代理可以实现<strong>方法增强</strong>，比如常用的<em>日志</em>,<em>缓存</em>等；也可以实现方法拦截，通过代理方法修改原方法的参数和返回值，从而实现某种不可告人的目的～接下来我们用代码解释一下。<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android插件化原理解析——概要]]></title>
    <link href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/"/>
    <id>http://weishu.me/2016/01/28/understand-plugin-framework-overview/</id>
    <published>2016-01-28T03:07:36.000Z</published>
    <updated>2016-03-22T02:50:06.000Z</updated>
    <content type="html"><![CDATA[<p>2015年是Android插件化技术突飞猛进的一年，随着业务的发展各大厂商都碰到了Android Native平台的瓶颈：</p>
<ol>
<li>从技术上讲，业务逻辑的复杂导致代码量急剧膨胀，各大厂商陆续出到65535方法数的天花板；同时，运营为王的时代对于模块热更新提出了更高的要求。</li>
<li>在业务层面上，功能模块的解耦以及维护团队的分离也是大势所趋；各个团队维护着同一个App的不同模块，如果每个模块升级新功能都需要对整个app进行升级，那么发布流程不仅复杂而且效率低下；在讲究小步快跑和持续迭代的移动互联网必将遭到淘汰。</li>
</ol>
<p>H5和Hybird可以解决这些问题，但是始终比不上native的用户体验；于是，国外的FaceBook推出了<code>react-native</code>；而国内各大厂商几乎都选择纯native的插件化技术。可以说，Android的未来必将是<code>react-native</code>和插件化的天下。</p>
<a id="more"></a>
<p><code>react-native</code>资料很多，但是讲述插件化的却凤毛菱角；插件化技术听起来高深莫测，实际上要解决的就是两个问题：</p>
<ol>
<li>代码加载</li>
<li>资源加载</li>
</ol>
<h2 id="代码加载">代码加载</h2><p>类的加载可以使用Java的<code>ClassLoader</code>机制，但是对于Android来说，并不是说类加载进来就可以用了，很多组件都是有“生命”的；因此对于这些有血有肉的类，必须给它们注入活力，也就是所谓的<strong>组件生命周期管理</strong>；</p>
<p>另外，如何管理加载进来的类也是一个问题。假设多个插件依赖了相同的类，是抽取公共依赖进行管理还是插件单独依赖？这就是<strong>ClassLoader的管理问题</strong>；</p>
<h2 id="资源加载">资源加载</h2><p>资源加载方案大家使用的原理都差不多，都是用<code>AssetManager</code>的隐藏方法<code>addAssetPath</code>；但是，不同插件的资源如何管理？是公用一套资源还是插件独立资源？共用资源如何避免资源冲突？对于资源加载，有的方案共用一套资源并采用资源分段机制解决冲突（要么修改<code>aapt</code>要么添加编译插件）；有的方案选择独立资源，不同插件管理自己的资源。</p>
<p>目前国内开源的较成熟的插件方案有<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">DL</a>和<a href="https://github.com/Qihoo360/DroidPlugin" target="_blank" rel="external">DroidPlugin</a>；但是DL方案仅仅对Frameworl的表层做了处理，严重依赖<code>that</code>语法，编写插件代码和主程序代码需单独区分；而DroidPlugin通过Hook增强了Framework层的很多系统服务，开发插件就跟开发独立app差不多；就拿Activity生命周期的管理来说，DL的代理方式就像是牵线木偶，插件只不过是操纵傀儡而已；而DroidPlugin则是借尸还魂，插件是有血有肉的系统管理的真正组件；DroidPlugin Hook了系统几乎所有的Sevice，欺骗了大部分的系统API；掌握这个Hook过程需要掌握很多系统原理，因此学习DroidPlugin对于整个Android FrameWork层大有裨益。</p>
<p>接下来的一系列文章将以DroidPlugin为例讲解插件框架的原理，揭开插件化的神秘面纱；同时还能帮助深入理解Android Framewrok；主要内容如下：</p>
<ul>
<li><a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Hook机制之动态代理</a></li>
<li><a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Hook机制之Binder Hook</a></li>
<li><a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Hook机制之AMS&amp;PMS</a></li>
<li><a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a></li>
<li>插件的广播机制，静态广播非静态</li>
<li>Service组件的管理，占坑和Hook</li>
<li>ContentProvider的管理</li>
<li>插件加载解析之自定义包管理服务(PackageManager)</li>
<li>插件进程管理机制（ActivityManager）</li>
<li>插件机制之资源管理</li>
<li>DroidPlugin插件通信机制</li>
<li>DroidPlugin框架缺陷</li>
<li>不同插件框架方案对比</li>
<li>插件化的未来</li>
</ul>
<p>另外，对于每一章内容都会有详细的demo，具体见<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>；喜欢就点个关注吧～定期更新，敬请期待！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015年是Android插件化技术突飞猛进的一年，随着业务的发展各大厂商都碰到了Android Native平台的瓶颈：</p>
<ol>
<li>从技术上讲，业务逻辑的复杂导致代码量急剧膨胀，各大厂商陆续出到65535方法数的天花板；同时，运营为王的时代对于模块热更新提出了更高的要求。</li>
<li>在业务层面上，功能模块的解耦以及维护团队的分离也是大势所趋；各个团队维护着同一个App的不同模块，如果每个模块升级新功能都需要对整个app进行升级，那么发布流程不仅复杂而且效率低下；在讲究小步快跑和持续迭代的移动互联网必将遭到淘汰。</li>
</ol>
<p>H5和Hybird可以解决这些问题，但是始终比不上native的用户体验；于是，国外的FaceBook推出了<code>react-native</code>；而国内各大厂商几乎都选择纯native的插件化技术。可以说，Android的未来必将是<code>react-native</code>和插件化的天下。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你真的了解AsyncTask？]]></title>
    <link href="http://weishu.me/2016/01/18/dive-into-asynctask/"/>
    <id>http://weishu.me/2016/01/18/dive-into-asynctask/</id>
    <published>2016-01-18T07:41:08.000Z</published>
    <updated>2016-01-18T07:47:21.000Z</updated>
    <content type="html"><![CDATA[<p>虽说现在做网络请求有了Volley全家桶和OkHttp这样好用的库，但是在处理其他后台任务以及与UI交互上，还是需要用到AsyncTask。但是你真的了解AsyncTask吗？</p>
<p>AsyncTask的实现几经修改，因此在不同版本的Android系统上表现各异；我相信，任何一个用户量上千万的产品绝对不会在代码里面使用系统原生的AsynTask，因为它蛋疼的兼容性以及极高的崩溃率实在让人不敢恭维。本文将带你了解AsyncTask背后的原理，并给出一个久经考验的AsyncTask修改版。</p>
<a id="more"></a>
<h2 id="AsyncTask是什么？">AsyncTask是什么？</h2><p>AsyncTask到底是什么呢？很简单，<strong>它不过是对线程池和Handler的封装</strong>；用线程池来处理后台任务，用Handler来处理与UI的交互。线程池使用的是<code>Executor</code>接口，我们先了解一下线程池的特性。</p>
<h2 id="线程池ThreadPoolExecutor">线程池ThreadPoolExecutor</h2><p>JDK5带来的一大改进就是Java的并发能力，它提供了三种并发武器：并发框架Executor，并发集合类型如ConcurrentHashMap，并发控制类如CountDownLatch等；圣经《Effective Java》也说，尽量使用Exector而不是直接用Thread类进行并发编程。</p>
<p>AsyncTask内部也使用了线程池处理并发；线程池通过<code>ThreadPoolExector</code>类构造，这个构造函数参数比较多，它允许开发者对线程池进行定制，我们先看看这每个参数是什么意思，然后看看Android是以何种方式定制的。</p>
<p>ThreadPoolExecutor的其他构造函数最终都会调用如下的构造函数完成对象创建工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                          <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                          <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize: 核心线程数目，即使线程池没有任务，核心线程也不会终止（除非设置了allowCoreThreadTimeOut参数）可以理解为“常驻线程”</li>
<li>maximumPoolSize: 线程池中允许的最大线程数目；一般来说，线程越多，线程调度开销越大；因此一般都有这个限制。</li>
<li>keepAliveTime: 当线程池中的线程数目比核心线程多的时候，如果超过这个keepAliveTime的时间，多余的线程会被回收；这些与核心线程相对的线程通常被称为<em>缓存线程</em></li>
<li>unit: keepAliveTime的时间单位</li>
<li>workQueue: 任务执行前保存任务的队列；这个队列仅保存由execute提交的Runnable任务</li>
<li>threadFactory: 用来构造线程池的工厂；一般都是使用默认的；</li>
<li>handler: 当线程池由于线程数目和队列限制而导致后续任务阻塞的时候，线程池的处理方式。</li>
</ul>
<p>那么，当一个新的任务到达的时候，线程池中的线程是如何调度的呢？（别慌，讲这么一大段线程池的知识，是为了理解AsyncTask；Be Patient）</p>
<ol>
<li>如果线程池中线程的数目少于corePoolSize，就算线程池中有其他的没事做的核心线程，线程池还是会重新创建一个核心线程；直到核心线程数目到达corePoolSize（常驻线程就位）</li>
<li>如果线程池中线程的数目大于或者等于corePoolSize，但是工作队列workQueue没有满，那么新的任务会放在队列workQueue中，按照FIFO的原则依次等待执行；（当有核心线程处理完任务空闲出来后，会检查这个工作队列然后取出任务默默执行去）</li>
<li>如果线程池中线程数目大于等于corePoolSize，并且工作队列workQueue满了，但是总线程数目小于maximumPoolSize，那么直接创建一个线程处理被添加的任务。</li>
<li>如果工作队列满了，并且线程池中线程的数目到达了最大数目maximumPoolSize，那么就会用最后一个构造参数<code>handler</code>处理；**默认的处理方式是直接丢掉任务，然后抛出一个异常。</li>
</ol>
<p>总结起来，也即是说，当有新的任务要处理时，<strong>先看线程池中的线程数量是否大于 corePoolSize，再看缓冲队列 workQueue 是否满，最后看线程池中的线程数量是否大于 maximumPoolSize</strong>。另外，当线程池中的线程数量大于 corePoolSize 时，如果里面有线程的空闲时间超过了 keepAliveTime，就将其移除线程池，这样，可以动态地调整线程池中线程的数量。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/20161-18.jpg" alt="风景"></p>
<p>我们以API 22为例，看一看AsyncTask里面的线程池是以什么参数构造的；AsyncTask里面有“两个”线程池；一个<code>THREAD_POOL_EXECUTOR</code>一个<code>SERIAL_EXECUTOR</code>；之所以打引号，是因为其实<code>SERIAL_EXECUTOR</code>也使用<code>THREAD_POOL_EXECUTOR</code>实现的，只不过加了一个队列弄成了串行而已，那么这个<code>THREAD_POOL_EXECUTOR</code>是如何构造的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</span><br><span class="line">            = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</span><br><span class="line">                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</span><br></pre></td></tr></table></figure>
<p>可以看到，AsyncTask里面线程池是一个核心线程数为<code>CPU + 1</code>，最大线程数为<code>CPU * 2 + 1</code>，工作队列长度为<strong>128</strong>的线程池；并且没有传递<code>handler</code>参数，那么使用的就是默认的Handler（拒绝执行).</p>
<p>那么问题来了：</p>
<ol>
<li><p>如果任务过多，那么超过了工作队列以及线程数目的限制导致这个线程池发生阻塞，那么悲剧发生，默认的处理方式会直接抛出一个异常导致进程挂掉。假设你自己写一个异步图片加载的框架，然后用AsyncTask实现的话，当你快速滑动ListView的时候很容易发生这种异常；这也是为什么各大ImageLoader都是自己写线程池和Handlder的原因。</p>
</li>
<li><p>这个线程池是一个静态变量；那么在同一个进程之内，所有地方使用到的AsyncTask默认构造函数构造出来的AsyncTask都使用的是同一个线程池，如果App模块比较多并且不加控制的话，很容易满足第一条的崩溃条件；如果你不幸在不同的AsyncTask的doInBackgroud里面访问了共享资源，那么就会发生各种并发编程问题。</p>
</li>
<li><p>在AsyncTask全部执行完毕之后，进程中还是会常驻corePoolSize个线程；在Android 4.4 （API 19）以下，这个corePoolSize是hardcode的，数值是5；API 19改成了<code>cpu + 1</code>；也就是说，在Android 4.4以前；如果你执行了超过五个AsyncTask；然后啥也不干了，进程中还是会有5个AsyncTask线程；不信，你看：</p>
</li>
</ol>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1453101991064.png" width="277"></p>
<h3 id="Handler">Handler</h3><p>AsyncTask里面的handler很简单，如下（API 22代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalHandler sHandler = <span class="keyword">new</span> InternalHandler();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Looper.getMainLooper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里直接用的主线程的Looper；如果去看API 22以下的代码，会发现它没有这个构造函数，而是使用默认的；默认情况下，Handler会使用当前线程的Looper，如果你的AsyncTask是在子线程创建的，那么很不幸，你的<code>onPreExecute</code>和<code>onPostExecute</code>并非在UI线程执行，而是被Handler post到创建它的那个线程执行；如果你在这两个线程更新了UI，那么直接导致崩溃。这也是大家口口相传的<strong>AsyncTask必须在主线程创建</strong>的原因。</p>
<p>另外，AsyncTask里面的这个Handler是一个静态变量，也就是说它是在类加载的时候创建的；如果在你的APP进程里面，以前从来没有使用过AsyncTask，然后在子线程使用AsyncTask的相关变量，那么导致静态Handler初始化，如果在API 16以下，那么会出现上面同样的问题；这就是<strong>AsyncTask必须在主线程初始化</strong> 的原因。</p>
<p>事实上，在Android 4.1(API 16)以后，在APP主线程ActivityThread的main函数里面，直接调用了<code>AscynTask.init</code>函数确保这个类是在主线程初始化的；另外，init这个函数里面获取了<code>InternalHandler</code>的Looper，由于是在主线程执行的，因此，AsyncTask的Handler用的也是主线程的Looper。这个问题从而得到彻底的解决。</p>
<h2 id="AsyncTask是并行执行的吗？">AsyncTask是并行执行的吗？</h2><p>现在知道AsyncTask内部有一个线程池，那么派发给AsyncTask的任务是并行执行的吗？</p>
<p>答案是不确定。在Android 1.5刚引入的时候，AsyncTask的<code>execute</code>是串行执行的；到了Android 1.6直到Android 2.3.2，又被修改为并行执行了，这个执行任务的线程池就是<code>THREAD_POOL_EXECUTOR</code>，因此在一个进程内，所有的AsyncTask都是并行执行的；但是在Android 3.0以后，如果你使用<code>execute</code>函数直接执行AsyncTask，那么<strong>这些任务是串行执行的</strong>；（你说蛋疼不）源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>sDefaultExecutor</code>就是用来执行任务的线程池，那么它的值是什么呢？继续看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br></pre></td></tr></table></figure>
<p>因此结论就来了：<strong>Android 3.0以上，AsyncTask默认并不是并行执行的</strong>；</p>
<h3 id="为什么默认不并行执行？">为什么默认不并行执行？</h3><p>也许你不理解，为什么AsyncTask默认把它设计为串行执行的呢？</p>
<p>由于一个进程内所有的AsyncTask都是使用的同一个线程池执行任务；如果同时有几个AsyncTask一起并行执行的话，恰好AysncTask的使用者在<code>doInbackgroud</code>里面访问了相同的资源，但是自己没有处理同步问题；那么就有可能导致灾难性的后果！</p>
<p>由于开发者通常不会意识到需要对他们创建的所有的AsyncTask对象里面的<code>doInbackgroud</code>做同步处理，因此，API的设计者为了避免这种无意中访问并发资源的问题，干脆把这个API设置为默认所有串行执行的了。如果你明确知道自己需要并行处理任务，那么你需要使用<code>executeOnExecutor(Executor exec,Params... params)</code>这个函数来指定你用来执行任务的线程池，同时为自己的行为负责。（处理同步问题）</p>
<p>实际上《Effective Java》里面有一条原则说的就是这种情况：不要在同步块里面调用不可信的外来函数。这里明显违背了这个原则：AsyncTask这个类并不知道使用者会在<code>doInBackgroud</code>这个函数里面做什么，但是对它的行为做了某种假设。</p>
<h3 id="如何让AsyncTask并行执行？">如何让AsyncTask并行执行？</h3><p>正如上面所说，如果你确定自己做好了同步处理，或者你没有在不同的AsyncTask里面访问共享资源，需要AsyncTask能够并行处理任务的话，你可以用带有两个参数的<code>executeOnExecutor</code>执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AsyncTask&lt;Void, Void, Vo</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</span><br></pre></td></tr></table></figure>
<h2 id="更好的AsyncTask">更好的AsyncTask</h2><p>从上面的分析得知，AsyncTask有如下问题：</p>
<ol>
<li>默认的AsyncTask如果处理的任务过多，会导致程序直接崩溃；</li>
<li>AsyncTask类必须在主线程初始化，必须在主线程创建，不然在API 16以下很大概率崩溃。</li>
<li>如果你曾经使用过AsyncTask，以后不用了；在Android 4.4以下，进程内也默认有5个AsyncTask线程；在Android 4.4以上，默认有<code>CPU + 1</code>个线程。</li>
<li>Android 3.0以上的AsyncTask默认是串行执行任务的；如果要并行执行需要调用低版本没有的API，处理麻烦。</li>
</ol>
<p>因此我们对系统的AsyncTask做了一些修改，在不同Android版本提供一致的行为，并且提高了使用此类的安全性，主要改动如下：</p>
<ol>
<li>添加对于任务过多导致崩溃的异常保护；在这里进行必要的数据统计上报工作；如果出现这个问题，说明AsyncTask不适合这种场景了，需要考虑重构；</li>
<li>移植API 22对于Handler的处理；这样就算在线程创建异步任务，也不会有任何问题；</li>
<li>提供串行执行和并行执行的<code>execute</code>方法；默认串行执行，如果明确知道自己在干什么，可以使用<code>executeParallel</code>并行执行。</li>
<li>在<code>doInbackgroud</code>里面频繁崩溃的地方加上<code>try..catch</code>；自己处理数据上报工作。</li>
</ol>
<p>完整代码见gist，<a href="https://gist.github.com/tiann/8860bcc514f067ab4291" target="_blank" rel="external">BetterAsyncTask</a></p>
<p>原文地址：<a href="http://weishu.me/2016/01/18/dive-into-asynctask/">http://weishu.me/2016/01/18/dive-into-asynctask/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽说现在做网络请求有了Volley全家桶和OkHttp这样好用的库，但是在处理其他后台任务以及与UI交互上，还是需要用到AsyncTask。但是你真的了解AsyncTask吗？</p>
<p>AsyncTask的实现几经修改，因此在不同版本的Android系统上表现各异；我相信，任何一个用户量上千万的产品绝对不会在代码里面使用系统原生的AsynTask，因为它蛋疼的兼容性以及极高的崩溃率实在让人不敢恭维。本文将带你了解AsyncTask背后的原理，并给出一个久经考验的AsyncTask修改版。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binder学习指南]]></title>
    <link href="http://weishu.me/2016/01/12/binder-index-for-newer/"/>
    <id>http://weishu.me/2016/01/12/binder-index-for-newer/</id>
    <published>2016-01-12T13:26:09.000Z</published>
    <updated>2016-03-08T01:57:45.000Z</updated>
    <content type="html"><![CDATA[<p>毫不夸张地说，Binder是Android系统中最重要的特性之一；正如其名“粘合剂”所喻，它是系统间各个组件的桥梁，Android系统的开放式设计也很大程度上得益于这种及其方便的跨进程通信机制。</p>
<p>理解Binder对于理解整个Android系统有着非常重要的作用，Android系统的四大组件，AMS，PMS等系统服务无一不与Binder挂钩；如果对Binder不甚了解，那么就很难了解这些系统机制，从而仅仅浮游与表面，不懂Binder你都不好意思说自己会Android开发；要深入Android，Binder是必须迈出的一步。</p>
<p>现在网上有不少资料介绍Binder，个人觉得最好的两篇如下：</p>
<ol>
<li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Binder设计与实现</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external"> Android进程间通信（IPC）机制Binder简要介绍和学习计划</a>系列</li>
</ol>
<p>其中, 《Binder设计与实现》以一种宏观的角度解释了Android系统中的Binder机制，文章如行云流水；如果对于Binder有一定的了解再来看着篇文章，有一种打通任督二脉的感觉；每看一次理解就深一层。老罗的系列文章则从系统源码角度深入分析了Binder的实现细节；具有很大的参考意义；每当对于Binder细节有疑惑，看一看他的书就迎刃而解。</p>
<p>但是遗憾的是，Binder机制终究不是三言两语就能解释清楚的，一上来就扒出源码很可能深陷细节无法自拔，老罗的文章那不是一般的长，如果看不懂强行看很容易睡着；勉强看完还是云里雾里；相反如果直接大谈特谈Binder的设计，那么完全就是不知所云；因此上述两篇文章对于初学者并不友好，本文不会深入源码细节，也不会对于Binder的设计高谈阔论；重点如下：<br><a id="more"></a></p>
<ol>
<li>一些Linux的预备知识</li>
<li>Binder到底是什么？</li>
<li>Binder机制是如何跨进程的？</li>
<li>一次Binder通信的基本流程是什么样？</li>
<li>深入理解Java层的Binder</li>
</ol>
<p>读完本文，你应该对于Java层的AIDL了如指掌，对于Binder也会有一个大体上的认识；再深入学习就得靠自己了，本人推荐的Binder学习路径如下：</p>
<ol>
<li>先学会熟练使用AIDL进行跨进程通信（简单来说就是远程Service）</li>
<li>看完本文</li>
<li>看Android文档，<code>Parcel, IBinder, Binder</code>等涉及到跨进程通信的类</li>
<li>不依赖AIDL工具，手写远程Service完成跨进程通信</li>
<li>看《Binder设计与实现》</li>
<li>看老罗的博客或者书（书结构更清晰）</li>
<li>再看《Binder设计与实现》</li>
<li>学习Linux系统相关知识；自己看源码。</li>
</ol>
<h2 id="背景知识">背景知识</h2><p>为了理解Binder我们先澄清一些概念。为什么需要跨进程通信（IPC），怎么做到跨进程通信？为什么是Binder？</p>
<p>由于Android系统基于Linux内核，因此有必要了解相关知识。</p>
<h3 id="进程隔离">进程隔离</h3><blockquote>
<p>进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。</p>
</blockquote>
<p>以上来自维基百科；操作系统的不同进程之间，数据不共享；对于每个进程来说，它都天真地以为自己独享了整个系统，完全不知道其他进程的存在；(有关虚拟地址，请自行查阅）因此一个进程需要与另外一个进程通信，需要某种系统机制才能完成。</p>
<h3 id="用户空间/内核空间">用户空间/内核空间</h3><p>详细解释可以参考<a href="http://www.linfo.org/kernel_space.html" target="_blank" rel="external">Kernel Space Definition</a>；简单理解如下：</p>
<p>Linux Kernel是操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</p>
<p>对于Kernel这么一个高安全级别的东西，显然是不容许其它的应用程序随便调用或访问的，所以需要对Kernel提供一定的保护机制，这个保护机制用来告诉那些应用程序，你只可以访问某些许可的资源，不许可的资源是拒绝被访问的，于是就把Kernel和上层的应用程序抽像的隔离开，分别称之为Kernel Space和User Space。</p>
<h3 id="系统调用/内核态/用户态">系统调用/内核态/用户态</h3><p>虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？</p>
<blockquote>
<p>Kernel space can be accessed by user processes only through the use of system calls. </p>
</blockquote>
<p>用户空间访问内核空间的唯一方式就是<strong>系统调用</strong>；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。</p>
<h3 id="内核模块/驱动">内核模块/驱动</h3><p>通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的Linux通信机制，比如Socket，管道等都是内核支持的；但是Binder并不是Linux内核的一部分，它是怎么做到访问内核空间的呢？Linux的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。</p>
<p>在Android系统中，这个运行在内核空间的，负责各个用户进程通过Binder通信的内核模块叫做<strong>Binder驱动</strong>; </p>
<blockquote>
<p>驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作；</p>
</blockquote>
<p>驱动就是操作硬件的接口，为了支持Binder通信过程，Binder使用了一种“硬件”，因此这个模块被称之为驱动。</p>
<p>好了，说了这么多枯燥的概念，看张美图缓解一下。</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/20161-8.jpg" alt=""></p>
<h3 id="为什么使用Binder？">为什么使用Binder？</h3><p>Android使用的Linux内核拥有着非常多的跨进程通信机制，比如管道，System V，Socket等；为什么还需要单独搞一个Binder出来呢？主要有两点，性能和安全。在移动设备上，广泛地使用跨进程通信肯定对通信机制本身提出了严格的要求；Binder相对出传统的Socket方式，更加高效；另外，传统的进程通信方式对于通信双方的身份并没有做出严格的验证，只有在上层协议上进行架设；比如Socket通信ip地址是客户端手动填入的，都可以进行伪造；而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。这个也是Android权限模型的基础。</p>
<h2 id="Binder通信模型">Binder通信模型</h2><p>对于跨进程通信的双方，我们姑且叫做Server进程（简称Server），Client进程（简称Client）；由于进程隔离的存在，它们之间没办法通过简单的方式进行通信，那么Binder机制是如何进行的呢？</p>
<p>回想一下日常生活中我们通信的过程：假设A和B要进行通信，通信的媒介是打电话（A是Client，B是Server）；A要给B打电话，必须知道B的号码，这个号码怎么获取呢？<strong>通信录</strong>. </p>
<p>这个通信录就是一张表；内容大致是：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B -&gt; 12345676</span><br><span class="line">C -&gt; 12334354</span><br></pre></td></tr></table></figure>
<p>先查阅通信录，拿到B的号码；才能进行通信；否则，怎么知道应该拨什么号码？回想一下古老的电话机，如果A要给B打电话，必须先连接通话中心，说明给我接通B的电话；这时候通话中心帮他呼叫B；连接建立，就完成了通信。</p>
<p>另外，光有电话和通信录是不可能完成通信的，没有基站支持；信息根本无法传达。</p>
<p>我们看到，一次电话通信的过程除了通信的双方还有两个隐藏角色：通信录和基站。Binder通信机制也是一样：两个运行在用户空间的进程要完成通信，必须借助内核的帮助，这个运行在内核里面的程序叫做<strong>Binder驱动</strong>，它的功能类似于基站；通信录呢，就是一个叫做<strong>ServiceManager</strong>的东西（简称SM）</p>
<p>OK，Binder的通信模型就是这么简单，如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/binder-model.png" alt=""></p>
<p>整个通信步骤如下：</p>
<ol>
<li>SM建立(建立通信录)；首先有一个进程向驱动提出申请为SM；驱动同意之后，SM进程负责管理Service（注意这里是Service而不是Server，因为如果通信过程反过来的话，那么原来的客户端Client也会成为服务端Server）不过这时候通信录还是空的，一个号码都没有。</li>
<li>各个Server向SM注册(完善通信录)；每个Server端进程启动之后，向SM报告，我是zhangsan, 要找我请返回0x1234(这个地址没有实际意义，类比)；其他Server进程依次如此；这样SM就建立了一张表，对应着各个Server的名字和地址；就好比B与A见面了，说存个我的号码吧，以后找我拨打10086；</li>
<li>Client想要与Server通信，首先询问SM；请告诉我如何联系zhangsan，SM收到后给他一个号码0x1234；Client收到之后，开心滴用这个号码拨通了Server的电话，于是就开始通信了。</li>
</ol>
<p>那么Binder驱动干什么去了呢？这里Client与SM的通信，以及Client与Server的通信，都会经过驱动，驱动在背后默默无闻，但是做着最重要的工作。驱动是整个通信过程的核心，因此完成跨进程通信的秘密全部隐藏在驱动里面；这个我们稍后讨论。</p>
<p>OK，上面就是整个Binder通信的基本模型；做了一个简单的类比，当然也有一些不恰当的地方，(比如通信录现实中每个人都有一个，但是SM整个系统只有一个；基站也有很多个，但是驱动只有一个）；但是整体上就是这样的；我们看到其实整个通信模型非常简单。</p>
<h2 id="Binder机制跨进程原理">Binder机制跨进程原理</h2><p>上文给出了Binder的通信模型，指出了通信过程的四个角色: Client, Server, SM, driver; 但是我们仍然不清楚<strong>Client到底是如何与Server完成通信的</strong>。</p>
<p>两个运行在用户空间的进程A和进程B如何完成通信呢？内核可以访问A和B的所有数据；所以，最简单的方式是通过内核做中转；假设进程A要给进程B发送数据，那么就先把A的数据copy到内核空间，然后把内核空间对应的数据copy到B就完成了；用户空间要操作内核空间，需要通过系统调用；刚好，这里就有两个系统调用：<code>copy_from_user</code>, <code>copy_to_user</code>。</p>
<p>但是，Binder机制并不是这么干的。讲这么一段，是说明进程间通信并不是什么神秘的东西。那么，Binder机制是如何实现跨进程通信的呢？</p>
<p>Binder驱动为我们做了一切。</p>
<p>假设Client进程想要调用Server进程的<code>object</code>对象的一个方法<code>add</code>;对于这个跨进程通信过程，我们来看看Binder机制是如何做的。 （通信是一个广泛的概念，只要一个进程能调用另外一个进程里面某对象的方法，那么具体要完成什么通信内容就很容易了。）</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/2016binder-procedure.png" alt="Alt text"></p>
<p>首先，Server进程要向SM注册；告诉自己是谁，自己有什么能力；在这个场景就是Server告诉SM，它叫<code>zhangsan</code>，它有一个<code>object</code>对象，可以执行<code>add</code> 操作；于是SM建立了一张表：<code>zhangsan</code>这个名字对应进程Server; </p>
<p>然后Client向SM查询：我需要联系一个名字叫做<code>zhangsan</code>的进程里面的<code>object</code>对象；这时候关键来了：进程之间通信的数据都会经过运行在内核空间里面的驱动，驱动在数据流过的时候做了一点手脚，它并不会给Client进程返回一个真正的<code>object</code>对象，而是返回一个看起来跟<code>object</code>一模一样的代理对象<code>objectProxy</code>，这个<code>objectProxy</code>也有一个<code>add</code>方法，但是这个<code>add</code>方法没有Server进程里面<code>object</code>对象的<code>add</code>方法那个能力；<code>objectProxy</code>的<code>add</code>只是一个傀儡，它唯一做的事情就是把参数包装然后交给驱动。(这里我们简化了SM的流程，见下文)</p>
<p>但是Client进程并不知道驱动返回给它的对象动过手脚，毕竟伪装的太像了，如假包换。Client开开心心地拿着<code>objectProxy</code>对象然后调用<code>add</code>方法；我们说过，这个<code>add</code>什么也不做，直接把参数做一些包装然后直接转发给Binder驱动。</p>
<p>驱动收到这个消息，发现是这个<code>objectProxy</code>；一查表就明白了：我之前用<code>objectProxy</code>替换了<code>object</code>发送给Client了，它真正应该要访问的是<code>object</code>对象的<code>add</code>方法；于是Binder驱动通知Server进程，<em>调用你的object对象的<code>add</code>方法，然后把结果发给我</em>，Sever进程收到这个消息，照做之后将结果返回驱动，驱动然后把结果返回给<code>Client</code>进程；于是整个过程就完成了。</p>
<p>由于驱动返回的<code>objectProxy</code>与Server进程里面原始的<code>object</code>是如此相似，给人感觉好像是<strong>直接把Server进程里面的对象object传递到了Client进程</strong>；因此，我们可以说<strong>Binder对象是可以进行跨进程传递的对象</strong></p>
<p>但事实上我们知道，Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用Binder驱动最终让真身完成操作。</p>
<p>理解这一点非常重要；务必仔细体会。另外，Android系统实现这种机制使用的是<em>代理模式</em>, 对于Binder的访问，如果是在同一个进程（不需要跨进程），那么直接返回原始的Binder实体；如果在不同进程，那么就给他一个代理对象（影子）；我们在系统源码以及AIDL的生成代码里面可以看到很多这种实现。</p>
<p>另外我们为了简化整个流程，隐藏了SM这一部分驱动进行的操作；实际上，由于SM与Server通常不在一个进程，Server进程向SM注册的过程也是跨进程通信，驱动也会对这个过程进行暗箱操作：SM中存在的Server端的对象实际上也是代理对象，后面Client向SM查询的时候，驱动会给Client返回另外一个代理对象。Sever进程的本地对象仅有一个，其他进程所拥有的全部都是它的代理。</p>
<p>一句话总结就是：<strong>Client进程只不过是持有了Server端的代理；代理对象协助驱动完成了跨进程通信。</strong></p>
<p>OK，该休息一下了。</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/20161-12.jpg" alt=""></p>
<h2 id="Binder到底是什么？">Binder到底是什么？</h2><p>我们经常提到Binder，那么Binder到底是什么呢？</p>
<p>Binder的设计采用了面向对象的思想，在Binder通信模型的四个角色里面；他们的代表都是“Binder”，这样，对于Binder通信的使用者而言，Server里面的Binder和Client里面的Binder没有什么不同，一个Binder对象就代表了所有，它不用关心实现的细节，甚至不用关心驱动以及SM的存在；这就是抽象。</p>
<ul>
<li>通常意义下，Binder指的是一种通信机制；我们说AIDL使用Binder进行通信，指的就是<strong>Binder这种IPC机制</strong>。</li>
<li>对于Server进程来说，Binder指的是<strong>Binder本地对象</strong></li>
<li>对于Client来说，Binder指的是<strong>Binder代理对象</strong>，它只是<strong>Binder本地对象</strong>的一个远程代理；对这个Binder代理对象的操作，会通过驱动最终转发到Binder本地对象上去完成；对于一个拥有Binder对象的使用者而言，它无须关心这是一个Binder代理对象还是Binder本地对象；对于代理对象的操作和对本地对象的操作对它来说没有区别。</li>
<li>对于传输过程而言，Binder是可以进行跨进程传递的对象；Binder驱动会对具有跨进程传递能力的对象做特殊处理：自动完成代理对象和本地对象的转换。</li>
</ul>
<blockquote>
<p>面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体（本地对象）位于一个进程中，而它的引用（代理对象）却遍布于系统的各个进程之中。最诱人的是，这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。</p>
</blockquote>
<h3 id="驱动里面的Binder">驱动里面的Binder</h3><p>我们现在知道，Server进程里面的Binder对象指的是Binder本地对象，Client里面的对象值得是Binder代理对象；在Binder对象进行跨进程传递的时候，Binder驱动会自动完成这两种类型的转换；因此Binder驱动必然保存了每一个跨越进程的Binder对象的相关信息；在驱动中，Binder本地对象的代表是一个叫做<code>binder_node</code>的数据结构，Binder代理对象是用<code>binder_ref</code>代表的；有的地方把Binder本地对象直接称作Binder实体，把Binder代理对象直接称作Binder引用（句柄），其实指的是Binder对象在驱动里面的表现形式；读者明白意思即可。</p>
<p>OK，现在大致了解Binder的通信模型，也了解了Binder这个对象在通信过程中各个组件里面到底表示的是什么。</p>
<h2 id="深入理解Java层的Binder">深入理解Java层的Binder</h2><h3 id="IBinder/IInterface/Binder/BinderProxy/Stub">IBinder/IInterface/Binder/BinderProxy/Stub</h3><p>我们使用AIDL接口的时候，经常会接触到这些类，那么这每个类代表的是什么呢？</p>
<ul>
<li>IBinder是一个接口，它代表了<strong>一种跨进程传输的能力</strong>；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。</li>
<li>IBinder负责数据传输，那么client与server端的调用契约（这里不用接口避免混淆）呢？这里的IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。</li>
<li>Java层的Binder类，代表的其实就是<strong>Binder本地对象</strong>。BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。</li>
<li>在使用AIDL的时候，编译工具会给我们生成一个Stub的静态内部类；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。</li>
</ul>
<h3 id="AIDL过程分析">AIDL过程分析</h3><p>现在我们通过一个AIDL的使用，分析一下整个通信过程中，各个角色到底做了什么，AIDL到底是如何完成通信的。（如果你连AIDL都不熟悉，请先查阅官方文档）</p>
<p>首先定一个一个简单的aidl接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ICompute.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.test.app;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICompute</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用编译工具编译之后，可以得到对应的ICompute.java类，看看系统给我们生成的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICompute</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Local-side IPC implementation stub class.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">test</span>.<span class="title">app</span>.<span class="title">ICompute</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.example.test.app.ICompute"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Construct the stub at attach it to the interface.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Cast an IBinder object into an com.example.test.app.ICompute interface,</span><br><span class="line">         * generating a proxy if needed.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.example.test.app.<span class="function">ICompute <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.test.app.ICompute))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.example.test.app.ICompute) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.example.test.app.ICompute.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">int</span> _arg0;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    <span class="keyword">int</span> _arg1;</span><br><span class="line">                    _arg1 = data.readInt();</span><br><span class="line">                    <span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeInt(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">test</span>.<span class="title">app</span>.<span class="title">ICompute</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Demonstrates some basic types that you can use as parameters</span><br><span class="line">             * and return values in AIDL.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">int</span> _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeInt(a);</span><br><span class="line">                    _data.writeInt(b);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.readInt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统帮我们生成了这个文件之后，我们只需要继承ICompute.Stub这个抽象类，实现它的方法，然后在Service 的onBind方法里面返回就实现了AIDL。这个Stub类非常重要，具体看看它做了什么。</p>
<p>Stub类继承自Binder，意味着这个Stub其实自己是一个Binder本地对象，然后实现了ICompute接口，ICompute本身是一个IInterface，因此他携带某种客户端需要的能力（这里是方法<code>add</code>)。此类有一个内部类Proxy，也就是Binder代理对象；</p>
<p>然后看看<code>asInterface</code>方法，我们在bind一个Service之后，在onServiceConnecttion的回调里面，就是通过这个方法拿到一个远程的service的，这个方法做了什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Cast an IBinder object into an com.example.test.app.ICompute interface,</span><br><span class="line"> * generating a proxy if needed.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.example.test.app.<span class="function">ICompute <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.test.app.ICompute))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.example.test.app.ICompute) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.example.test.app.ICompute.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看函数的参数<code>IBinder</code>类型的obj，这个对象是驱动给我们的，如果是Binder本地对象，那么它就是Binder类型，如果是Binder代理对象，那就是<code>BinderProxy</code>类型；然后，正如上面自动生成的文档所说，它会试着查找Binder本地对象，如果找到，说明Client和Server都在同一个进程，这个参数直接就是本地对象，直接强制类型转换然后返回，如果找不到，说明是远程对象（处于另外一个进程）那么就需要创建一个Binde代理对象，让这个Binder代理实现对于远程对象的访问。一般来说，如果是与一个远程Service对象进行通信，那么这里返回的一定是一个Binder代理对象，这个IBinder参数的实际上是BinderProxy;</p>
<p>再看看我们对于aidl的<code>add</code> 方法的实现；在Stub类里面，<code>add</code>是一个抽象方法，我们需要继承这个类并实现它；如果Client和Server在同一个进程，那么直接就是调用这个方法；那么，如果是远程调用，这中间发生了什么呢？Client是如何调用到Server的方法的？</p>
<p>我们知道，对于远程方法的调用，是通过Binder代理完成的，在这个例子里面就是<code>Proxy</code>类；<code>Proxy</code>对于<code>add</code>方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">int</span> _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeInt(a);</span><br><span class="line">        _data.writeInt(b);</span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.readInt();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它首先用<code>Parcel</code>把数据序列化了，然后调用了<code>transact</code>方法；这个<code>transact</code>到底做了什么呢？这个<code>Proxy</code>类在<code>asInterface</code>方法里面被创建，前面提到过，如果是Binder代理那么说明驱动返回的IBinder实际是<code>BinderProxy</code>, 因此我们的<code>Proxy</code>类里面的<code>mRemote</code>实际类型应该是<code>BinderProxy</code>；我们看看<code>BinderProxy</code>的<code>transact</code>方法：(Binder.java的内部类)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span><br><span class="line">            <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个本地方法；它的实现在native层，具体来说在frameworks/base/core/jni/android_util_Binder.cpp文件，里面进行了一系列的函数调用，调用链实在太长这里就不给出了；要知道的是它最终调用到了<code>talkWithDriver</code>函数；看这个函数的名字就知道，通信过程要交给驱动完成了；这个函数最后通过<code>ioctl</code>系统调用，Client进程陷入内核态，Client调用<code>add</code>方法的线程挂起等待返回；驱动完成一系列的操作之后唤醒Server进程，调用了Server进程本地对象的<code>onTransact</code>函数（实际上由Server端线程池完成）。我们再看Binder本地对象的<code>onTransact</code>方法（这里就是<code>Stub</code>类里面的此方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            reply.writeString(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">int</span> _arg0;</span><br><span class="line">            _arg0 = data.readInt();</span><br><span class="line">            <span class="keyword">int</span> _arg1;</span><br><span class="line">            _arg1 = data.readInt();</span><br><span class="line">            <span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            reply.writeInt(_result);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Server进程里面，<code>onTransact</code>根据调用号（每个AIDL函数都有一个编号，在跨进程的时候，不会传递函数，而是传递编号指明调用哪个函数）调用相关函数；在这个例子里面，调用了Binder本地对象的<code>add</code>方法；这个方法将结果返回给驱动，驱动唤醒挂起的Client进程里面的线程并将结果返回。于是一次跨进程调用就完成了。</p>
<p>至此，你应该对AIDL这种通信方式里面的各个类以及各个角色有了一定的了解；它总是那么一种固定的模式：一个需要跨进程传递的对象一定继承自IBinder，如果是Binder本地对象，那么一定继承Binder实现IInterface，如果是代理对象，那么就实现了IInterface并持有了IBinder引用；</p>
<p>Proxy与Stub不一样，虽然他们都既是Binder又是IInterface，不同的是Stub采用的是继承（is 关系），Proxy采用的是组合（has 关系）。他们均实现了所有的IInterface函数，不同的是，Stub又使用策略模式调用的是虚函数（待子类实现），而Proxy则使用组合模式。为什么Stub采用继承而Proxy采用组合？事实上，Stub本身is一个IBinder（Binder），它本身就是一个能跨越进程边界传输的对象，所以它得继承IBinder实现transact这个函数从而得到跨越进程的能力（这个能力由驱动赋予）。Proxy类使用组合，是因为他不关心自己是什么，它也不需要跨越进程传输，它只需要拥有这个能力即可，要拥有这个能力，只需要保留一个对IBinder的引用。如果把这个过程做一个类比，在封建社会，Stub好比皇帝，可以号令天下，他生而具有这个权利（不要说宣扬封建迷信。。）如果一个人也想号令天下，可以，“挟天子以令诸侯”。为什么不自己去当皇帝，其一，一般情况没必要，当了皇帝其实限制也蛮多的是不是？我现在既能掌管天下，又能不受约束（Java单继承）；其二，名不正言不顺啊，我本来特么就不是（Binder），你非要我是说不过去，搞不好还会造反。最后呢，如果想当皇帝也可以，那就是asBinder了。在Stub类里面，asBinder返回this，在Proxy里面返回的是持有的组合类IBinder的引用。</p>
<p>再去翻阅系统的ActivityManagerServer的源码，就知道哪一个类是什么角色了：IActivityManager是一个IInterface，它代表远程Service具有什么能力，ActivityManagerNative指的是Binder本地对象（类似AIDL工具生成的Stub类），这个类是抽象类，它的实现是<code>ActivityManagerService</code>；因此对于AMS的最终操作都会进入<code>ActivityManagerService</code>这个真正实现；同时如果仔细观察，ActivityManagerNative.java里面有一个非公开类ActivityManagerProxy, 它代表的就是Binder代理对象；是不是跟AIDL模型一模一样呢？那么<code>ActivityManager</code>是什么？他不过是一个管理类而已，可以看到真正的操作都是转发给<code>ActivityManagerNative</code>进而交给他的实现<code>ActivityManagerService</code> 完成的。</p>
<p>OK，本文就讲到这里了，要深入理解Binder，需要自己下功夫；那些native层以及驱动里面的调用过程，用文章写出来根本没有意义，需要自己去跟踪；接下来你可以：</p>
<ol>
<li>看Android文档，<code>Parcel, IBinder, Binder</code>等涉及到跨进程通信的类；</li>
<li>不依赖AIDL工具，手写远程Service完成跨进程通信</li>
<li>看<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">《Binder设计与实现》</a></li>
<li>看老罗的博客或者书（书结构更清晰）</li>
<li>再看<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">《Binder设计与实现》</a></li>
<li>学习Linux系统相关知识；自己看源码。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>毫不夸张地说，Binder是Android系统中最重要的特性之一；正如其名“粘合剂”所喻，它是系统间各个组件的桥梁，Android系统的开放式设计也很大程度上得益于这种及其方便的跨进程通信机制。</p>
<p>理解Binder对于理解整个Android系统有着非常重要的作用，Android系统的四大组件，AMS，PMS等系统服务无一不与Binder挂钩；如果对Binder不甚了解，那么就很难了解这些系统机制，从而仅仅浮游与表面，不懂Binder你都不好意思说自己会Android开发；要深入Android，Binder是必须迈出的一步。</p>
<p>现在网上有不少资料介绍Binder，个人觉得最好的两篇如下：</p>
<ol>
<li><a href="http://blog.csdn.net/universus/article/details/6211589">Binder设计与实现</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6618363"> Android进程间通信（IPC）机制Binder简要介绍和学习计划</a>系列</li>
</ol>
<p>其中, 《Binder设计与实现》以一种宏观的角度解释了Android系统中的Binder机制，文章如行云流水；如果对于Binder有一定的了解再来看着篇文章，有一种打通任督二脉的感觉；每看一次理解就深一层。老罗的系列文章则从系统源码角度深入分析了Binder的实现细节；具有很大的参考意义；每当对于Binder细节有疑惑，看一看他的书就迎刃而解。</p>
<p>但是遗憾的是，Binder机制终究不是三言两语就能解释清楚的，一上来就扒出源码很可能深陷细节无法自拔，老罗的文章那不是一般的长，如果看不懂强行看很容易睡着；勉强看完还是云里雾里；相反如果直接大谈特谈Binder的设计，那么完全就是不知所云；因此上述两篇文章对于初学者并不友好，本文不会深入源码细节，也不会对于Binder的设计高谈阔论；重点如下：<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="binder" scheme="http://weishu.me/tags/binder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ASCII Art：使用纯文本流程图]]></title>
    <link href="http://weishu.me/2016/01/03/use-pure-ascii-present-graph/"/>
    <id>http://weishu.me/2016/01/03/use-pure-ascii-present-graph/</id>
    <published>2016-01-03T15:17:24.000Z</published>
    <updated>2016-01-05T01:54:35.000Z</updated>
    <content type="html"><![CDATA[<p>我们使用纯文本写代码，有了Markdown又可以使用纯文本写文档，那么对于更直观的信息表达方式——图片，能不能使用纯文本描述呢？</p>
<p>另外，你是否见到过这样的注释：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451834573842.png" alt="ASCII art图像" width="463"></p>
<p>没错，这种逼格极高的ASCII图片注释方式就是我们要讨论的话题。</p>
<a id="more"></a>
<p>使用纯ASCII文本表达图像的方式有什么好处呢？大致有下面几点：</p>
<ol>
<li>装B；没啥好解释的。</li>
<li>可以在代码注释里面用图像充分表达信息；没图say个jb？一图胜千言。迄今为止好像没有什么IDE可以支持直接在代码编辑里面放图片的，在另外一些纯文本的场合也是如此。比如RFC的文档都是txt，里面很多图都是纯ASCII表达。</li>
<li>你以为仅仅是一个纯文本图片这么简单？它可以转换为普通的诸如png格式的真正的图片，还支持SVG矢量图！</li>
</ol>
<p>好了，也许有人说markdown的一些拓展格式不也是支持流程图的吗？它使用的<code>flowchart.js</code> 确实可以很好滴完成一些漂亮的流程图，还有 <code>plantuml</code>和图片DSL语言 <code>dot</code>及它的软件包<code>graphviz</code>等；没错，它们可以使用纯文本表达图像，但它们不是真正的图像；无法嵌入文本代码中，只有在经过渲染之后才能直观地看到图。</p>
<p>又有人说，我知道 <code>asciiflow</code> 这个网站，可以绘制这种流程图，完美解决我的需求。但是，你在手动绘制的时候，是不是要考虑图像的各种细节？大小，放置位置，对齐方式？我们关注的应该是图像本身，而不是如何绘制这个图。markdown为什么这么易用？就是因为我们不用关心文档的格式，不用考虑什么字体，几级标题等等繁琐的格式，可以专注于创作本身。</p>
<p>姑且你已经认同了这种使用ASCII表达图像方式的优点，但是…这种图难道要使用手一个个字符地敲出来吗？？如果真的这么做，简直不要太麻烦！光在前面添加一个空格，后面的所有行都需要改；我们需要一个自动化工具。</p>
<h2 id="Graph::Easy">Graph::Easy</h2><p><strong>Graph::Easy</strong> 就是今天要介绍的主角；它是 <code>perl</code>的一个软件包，可以使用<code>perl</code>代码直接描述图像；当然，我们肯定不会为了画个图专门去学习<code>perl</code>;</p>
<p>这个软件包的强大之处在于: 它定义了一套非常简单易用的专门用来描述图像的DSL（领域专用语言）,我们可以像写代码一样表达我们需要描述的图像（放心，这个语法非常简单）；不用关心图像里面如何布局；这种语言经过处理可以得到ASCII图像，直接放在代码注释中；如果需要还可以转换成png或者矢量图等格式。</p>
<p>先举个简单的例子，感受一下:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ Bonn ] --&gt; [ Koblenz ] --&gt; [ Frankfurt ] --&gt; [ Dresden ]</span></span><br><span class="line"></span><br><span class="line">[ Koblenz ] --&gt; [ Trier ] &#123; origin: Koblenz; offset: 2, 2; &#125;</span><br><span class="line"><span class="code">  --&gt; [ Frankfurt ]</span></span><br></pre></td></tr></table></figure>
<p>这种DSL经过渲染之后得到的ASCII图是这样的：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+------+</span>     <span class="code">+---------+</span>                   <span class="code">+-----------+</span>     <span class="code">+---------+</span></span><br><span class="line">| Bonn | --&gt; | Koblenz | ----------------&gt; | Frankfurt | --&gt; | Dresden |</span><br><span class="line"><span class="code">+------+</span>     <span class="code">+---------+</span>                   <span class="code">+-----------+</span>     <span class="code">+---------+</span></span><br><span class="line"><span class="code">               |                             ^</span></span><br><span class="line"><span class="code">               |                             |</span></span><br><span class="line"><span class="code">               |                             |</span></span><br><span class="line"><span class="code">               |             +-------+       |</span></span><br><span class="line"><span class="code">               +-----------&gt; | Trier | ------+</span></span><br><span class="line"><span class="code">                             +-------+</span></span><br></pre></td></tr></table></figure>
<h2 id="安装">安装</h2><ol>
<li>首先需要安装 <code>graphviz</code> 软件包，可以在<a href="http://www.graphviz.org/" target="_blank" rel="external">graphviz官网</a>下载；mac用户可以 <code>brew install graphviz</code>；其他linux发行版参考<a href="http://www.graphviz.org/" target="_blank" rel="external">官网</a>。</li>
<li>安装<code>perl</code>；mac和linux用户可以略过；一般系统自带，没有的话和windows一起去<a href="http://www.perl.org" target="_blank" rel="external">perl官网</a>查询如何安装; 据说windows下有傻瓜包<code>activeperl</code>；请自行搜索。</li>
<li>安装<code>cpan</code>; 这个是<code>perl</code>的软件包管理，类似<code>npm</code>, <code>pip</code>, <code>apt-get</code>; mac下直接在命令行输入 <code>cpan</code> 命令，一路next即可。其他系统参考<a href="http://www.cpan.org/modules/INSTALL.html" target="_blank" rel="external">cpan官网</a></li>
<li>安装<code>Graph::Easy</code> ;这一步就很容易了；在命令行输入<code>cpan</code>进入cpan shell；然后输入 <code>install Graph::Easy</code>即可。</li>
</ol>
<h2 id="使用">使用</h2><p>使用分为两步</p>
<ol>
<li>使用Graph::Easy DSL的语法描述图像，存为文本文件，比如 <code>simple.txt</code></li>
<li>使用 <code>graph-easy</code> 命令处理这个文件： <code>graph-easy simple.txt</code></li>
</ol>
<p>最简单的使用方式就是这样；当然，<code>Graph::Easy</code> 不仅仅支持自己的DSL语法，它还支持诸如<code>dot</code> 这种较为通用的图像描述语言；可以直接读取<code>dot</code> 格式的输入，产生其他的诸如 ascii，png，svg格式的图像。</p>
<h3 id="语法">语法</h3><h4 id="注释">注释</h4><p>注释用 <code>#</code> 表达；注意 <code>#</code> 之后，一定需要加空格；由于历史原因；Graph::Easy的颜色也使用了 <code>#</code> ，不加空格会解析失败。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##############################################################</span><br><span class="line"># 合法的注释</span><br><span class="line"></span><br><span class="line">##############################################################</span><br><span class="line">#有问题的注释</span><br><span class="line"></span><br><span class="line">node &#123; label: \#5; &#125;	  # 注意转义！</span><br><span class="line">edge &#123; color: #aabbcc; &#125;  # 可以使用颜色值</span><br></pre></td></tr></table></figure></p>
<h4 id="空格">空格</h4><p>空格通常没有什么影响，多个空字符会合并成一个，换行的空字符会忽略；下面的表述是等价的。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[A]-&gt;[B][C]-&gt;[D]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ A ] -&gt; [ B ]</span></span><br><span class="line"><span class="attribute">[ C ] -&gt; [ D ]</span></span><br></pre></td></tr></table></figure>
<h4 id="节点(Node)">节点(Node)</h4><p>用中括号括起来的就是节点，我们简单可以理解为一些形状；比如流程图里面的矩形，圆等；</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ Single node ]</span></span><br><span class="line"><span class="attribute">[ Node A ] --&gt; [ Node B ]</span></span><br></pre></td></tr></table></figure>
<p>可以用逗号分割多个节点：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ A ], [ B ], [ C ] --&gt; [ D ]</span></span><br></pre></td></tr></table></figure>
<p>上面的代码图像如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+---+</span>     <span class="code">+---+</span>     <span class="code">+---+</span></span><br><span class="line">| A | --&gt; | D | &lt;-- | C |</span><br><span class="line"><span class="code">+---+</span>     <span class="code">+---+</span>     <span class="code">+---+</span></span><br><span class="line"><span class="code">            ^</span></span><br><span class="line"><span class="code">            |</span></span><br><span class="line"><span class="code">            |</span></span><br><span class="line"><span class="code">          +---+</span></span><br><span class="line"><span class="code">          | B |</span></span><br><span class="line"><span class="code">          +---+</span></span><br></pre></td></tr></table></figure>
<h4 id="边(Edges)">边(Edges)</h4><p>将节点连接起来的就是边；Graph::Easy 的DSL支持这几种风格的边：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt;              实线</span><br><span class="line">=&gt;              双实线</span><br><span class="line">.&gt;              点线</span><br><span class="line">~&gt;              波浪线</span><br><span class="line"><span class="bullet">- </span>&gt;             虚线</span><br><span class="line">.-&gt;             点虚线</span><br><span class="line">..-&gt;            dot-dot-dash</span><br><span class="line"><span class="header">= &gt;             double-dash</span></span><br></pre></td></tr></table></figure></p>
<p>可以给边加标签，如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ client ] - request -&gt; [ server ]</span></span><br><span class="line"><span class="code">```</span> </span><br><span class="line">结果如下：</span><br><span class="line"></span><br><span class="line"><span class="code">```</span>asciidoc</span><br><span class="line"><span class="code">+--------+</span>  request   <span class="code">+--------+</span></span><br><span class="line">| client | ---------&gt; | server |</span><br><span class="line"><span class="code">+--------+</span>            <span class="code">+--------+</span></span><br></pre></td></tr></table></figure>
<h4 id="属性(Attributes)">属性(Attributes)</h4><p>可以给节点和边添加属性；比如标签，方向等；使用大括号 <code>{}</code>表示，里面的内容类似css，<code>attribute: value</code>。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ "Monitor Size" ] --&gt; &#123; label: 21"; &#125; [ Big ] &#123; label: "Huge"; &#125;</span><br></pre></td></tr></table></figure>
<p>上面的DSL输入如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------------+</span>  21"   <span class="code">+------+</span></span><br><span class="line">| "Monitor Size" | -----&gt; | Huge |</span><br><span class="line"><span class="code">+----------------+</span>        <span class="code">+------+</span></span><br></pre></td></tr></table></figure></p>
<p>Graph::Easy提供了非常多的属性; 另外，<code>Graph::Easy</code>的<a href="http://bloodgate.com/perl/graph/manual/index.html" target="_blank" rel="external">文档</a>非常详细，建议通读一遍；了解其中的原理和细节，对于绘图和布局有巨大帮助。目前正在翻译，文档<a href="https://www.gitbook.com/book/weishu/graph-easy-cn/details" target="_blank" rel="external">地址</a>.</p>
<h2 id="实例">实例</h2><p>语法是不是非常简单？有了这些知识，我们就可以建立自己的流程图了；Have a try！来个MVP模式的示意图试试～</p>
<ol>
<li>新建文件，<code>vi mvp.txt</code>; 输入以下代码：</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ View ] &#123;rows:3&#125; - Parse calls to -&gt; [ Presenter ] &#123;flow: south; rows: 3&#125; - Manipulates -&gt; [ Model ]</span></span><br><span class="line"><span class="attribute">[ Presenter ] - Updates -&gt; [ View ]</span></span><br></pre></td></tr></table></figure>
<ol>
<li>保存然后退出；命令行执行 <code>graph-easy mvp.txt</code>, 输入效果如下：</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+------+</span>  Parse calls to   <span class="code">+--------------+</span></span><br><span class="line">|      | ----------------&gt; |              |</span><br><span class="line">| View |                   |  Presenter   |</span><br><span class="line">|      |  Updates          |              |</span><br><span class="line">|      | &lt;---------------- |              |</span><br><span class="line"><span class="code">+------+</span>                   <span class="code">+--------------+</span></span><br><span class="line"><span class="code">                             |</span></span><br><span class="line"><span class="code">                             | Manipulates</span></span><br><span class="line"><span class="code">                             v</span></span><br><span class="line"><span class="code">                           +--------------+</span></span><br><span class="line"><span class="code">                           |    Model     |</span></span><br><span class="line"><span class="code">                           +--------------+</span></span><br></pre></td></tr></table></figure>
<p>两行代码就搞定了！自动对齐，调整位置，箭头，标签等等；我们完全不用管具体图形应该如何绘制，注意力集中在描述图像本身；还在等什么！赶紧试一试吧！！</p>
<p>原文：<a href="http://weishu.me/2016/01/03/use-pure-ascii-present-graph/">http://weishu.me/2016/01/03/use-pure-ascii-present-graph/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们使用纯文本写代码，有了Markdown又可以使用纯文本写文档，那么对于更直观的信息表达方式——图片，能不能使用纯文本描述呢？</p>
<p>另外，你是否见到过这样的注释：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451834573842.png" alt="ASCII art图像" width="463"/></p>
<p>没错，这种逼格极高的ASCII图片注释方式就是我们要讨论的话题。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[把Sublime添加到Mac右键菜单]]></title>
    <link href="http://weishu.me/2015/12/31/add-sublime-editor-to-finder-context-menu/"/>
    <id>http://weishu.me/2015/12/31/add-sublime-editor-to-finder-context-menu/</id>
    <published>2015-12-31T06:53:20.000Z</published>
    <updated>2015-12-31T07:48:55.000Z</updated>
    <content type="html"><![CDATA[<p>虽然大部分的时候是使用命令行，但是有些时候我们需要在<code>Finder</code>里面编辑某些文件的时候，如果还是拘泥于这样，就必须打开 <code>iTerm</code> （幸好有Profile可以一键打开终端）切换目录，编辑；这时候，类似Windows系统的右键菜单就比较方便了。</p>
<p>如果Mac系统识别出这是一个文本文件，右键菜单的 <strong>打开方式</strong> 可能还有点用，如果识别不出来，那么手动选择应用程序就比较麻烦了：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545353007.png" width="385"></p>
<p>其实Mac系统的 <strong>AutoMator</strong> 是可以完成这个功能的；接下来说一下操作步骤。</p>
<a id="more"></a>
<ul>
<li><p>打开 <code>Automator</code> 这个程序（可以使用Spotlight或者Alfred直接搜索），在弹出的菜单中选择 <strong>服务</strong><br><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545516628.png" width="545"></p>
</li>
<li><p>在左上角的搜索框搜索 <code>Finder</code> 然后在结果里面选择 <code>打开Finder项目</code><br>；然后把它拖到右边：</p>
</li>
</ul>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545618554.png" width="832"></p>
<ul>
<li>拖到右边之后，设置打开方式为「Sublime Text 2」，上面设定为“服务”收到选定的「文件或文件夹」位于「Finder」；</li>
</ul>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545743958.png" width="616"></p>
<ul>
<li>然后保存项目 (Cmd + S), 写上这个操作的名字，比如 <em>Open in Sublime Text</em></li>
</ul>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545891571.png" width="390"></p>
<p>这时候，进入 <code>Finder</code> 选择一个文件或者文件夹，点击右键：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545999524.png" width="228"></p>
<p>OK，大功告成！如果想添加别的编辑器，按照类似的操作即可。</p>
<p>但是，还有几个问题说明一下：</p>
<ul>
<li>右键菜单没有，出现在<strong>服务</strong>二级菜单</li>
</ul>
<p>有的童鞋按照这一步设置完毕之后，发现并没有直接在右键菜单出现，而是出现在服务二级菜单！这样每次都需要多点击一次，很不爽！如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512%2F1451546296324.png" width="443"></p>
<p>这时候，其实是服务菜单里面内容太多了，因此Mac系统自动把菜单收缩到了二级菜单。可以到「系统偏好设置…」-「键盘」-「服务」中去掉不需要的选项。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451546545636.png" width="620"></p>
<ul>
<li>如何删除</li>
</ul>
<p>如果弄错了，想删除掉；直接去 <code>~/Library/Services</code> 删除对应的目录即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然大部分的时候是使用命令行，但是有些时候我们需要在<code>Finder</code>里面编辑某些文件的时候，如果还是拘泥于这样，就必须打开 <code>iTerm</code> （幸好有Profile可以一键打开终端）切换目录，编辑；这时候，类似Windows系统的右键菜单就比较方便了。</p>
<p>如果Mac系统识别出这是一个文本文件，右键菜单的 <strong>打开方式</strong> 可能还有点用，如果识别不出来，那么手动选择应用程序就比较麻烦了：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545353007.png" width="385"/></p>
<p>其实Mac系统的 <strong>AutoMator</strong> 是可以完成这个功能的；接下来说一下操作步骤。</p>]]>
    
    </summary>
    
      <category term="mac" scheme="http://weishu.me/tags/mac/"/>
    
      <category term="sublime" scheme="http://weishu.me/tags/sublime/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio你不知道的调试技巧]]></title>
    <link href="http://weishu.me/2015/12/21/android-studio-debug-tips-you-may-not-know/"/>
    <id>http://weishu.me/2015/12/21/android-studio-debug-tips-you-may-not-know/</id>
    <published>2015-12-21T12:39:03.000Z</published>
    <updated>2015-12-23T03:03:55.000Z</updated>
    <content type="html"><![CDATA[<p>写代码不可避免有Bug，通常情况下除了日志最直接的调试手段就是debug；那么你的调试技术停留在哪一阶段呢？仅仅是下个断点单步执行吗？或者你知道 <code>Evaluate Expression</code>, 知道条件断点；可是你听说过日志断点吗，<code>Method Breakpoint</code>, <code>Exception Breakpoint</code> 呢？还有高大上的 <code>Field Watchpoint</code> ?</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450701212799.png" width="338" alt="几种不同的断点"></p>
<p>你有关注过Android Studio旁边断点的区别吗？比如上图三个断点有什么不同？且听我一一道来。<br><a id="more"></a></p>
<h2 id="调试基础">调试基础</h2><p>一般来说我们有两种办法调试一个debuggable的apk；其一是下好断点，然后用debug模式编译安装这个app；其二是 <code>attach process</code>，在Android Studio里面就是这么一个对话框：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450697931900.png" width="273" alt="Attach Process"></p>
<p>第二种方法比较常用，我们可以在启动apk之后，直接下断点，然后attach process到制定进程，条件触发之后就可以直接进入调试模式。</p>
<p>其他的一些单步执行，<code>step into</code>, <code>step out</code>, <code>force step into</code> 等就不提了；基本的跟踪手段。</p>
<p>还是提一下，下断点最简单的办法，是在代码编辑器的左侧，行号右边鼠标点击一下即可。</p>
<h2 id="Evaluate_Expression">Evaluate Expression</h2><p>这个功能非常实用，可以在断点处直接进入一个求值环境，在这里你可以执行任何你感兴趣的表达式；如下图：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450698259155.png" width="524" alt="Evaluate Expression"></p>
<p>比如在断点处有一个对象<code>object</code>，如果你要查看它的某个属性很简单，在Debug窗口就能看到，但是如果你想要执行它的某个方法看看结果是什么呢？借助这个可以实现。当然它的功能远不止这么多，相当于直接进入了一个 <code>REPL</code>环境，非常实用。忘了说了，快捷键 <code>Alt + F8</code> :P</p>
<h2 id="条件断点">条件断点</h2><p>假设你的断点在一个列表的循环里面，可是你只对这个列表的某一个元素感兴趣，只想在遇到这个元素的时候才断下来；你是一直人肉 <code>F9</code> 直到满足条件吗？条件断点就是满足这种需求的，顾名思义，在特定条件下的断点。使用起来也非常简单，在你的断点上鼠标右键会出现一个小窗口，写上条件即可。</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450698641184.png" width="465" alt="条件断点"></p>
<h2 id="日志断点">日志断点</h2><p>很多时候我们调试的时候更多的是打印日志定位异常代码，缩小范围之后再使用断点解决问题；所以经常做的事情就是在代码里面添加日志信息，输出函数参数，返回信息，输出我们感兴趣的变量信息等。</p>
<p>但是这么做一个问题就是，我们添加了日志代码需要重新编译；在没有 <code>Instant Run</code> 之前的黑暗时代这么做是非常痛苦的，每次编译少则几十秒，多则几分钟；这样无意义的等待简直就是折磨；其实，除了热部署工具，我们还可以使用日志断点解决这个问题。</p>
<p>首先我们在想要输出信息的地方下一个断点；然后右键这个断点，在出现的设置框里面把这个断点的 <code>suspend</code> 属性设置为 <code>False</code> ，这样虽然叫做“断点”，但是并不会真正断下来；然后，我们在 <code>log message</code> 里面填上我们想要输出的日志信息。如下图(注意标红位置）：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450699187057.png" width="591" alt="日志断点"></p>
<p>这样，每次代码执行到这个断点的位置，这个可爱的断点并不会使我们的程序停下来，而是输出我们告诉它的日志信息，然后继续执行；非常方便。</p>
<h2 id="方法断点">方法断点</h2><p>传统的调试方式是以行为单位的，所谓单步调试；但是很多时候我们关心的是某个函数的参数，返回值；（回想一下我们使用日志的时候打印的最多的信息难道不是函数的参数和返回值吗？）使用方法断点，我们可以在函数级别进行调试；如果经常跳进跳出函数或者只对某个函数的参数感兴趣，这种类型的断点非常实用。具体使用方法有两种方式；最简单的是在你感兴趣的方法头那一行打上断点，这时候你会发现断点图标有点不一样，这就是方法断点了，如下图：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450699584560.png" width="503" alt="方法断点"></p>
<p>另外一种方式是通过<em>断点设置窗口</em>, 后面介绍。</p>
<h2 id="异常断点">异常断点</h2><p>在有些情况下，我们只对某些特定的异常感兴趣，或者我们只对异常感兴趣；我们希望只要程序发生异常程序就能断下来；这好像保存现场一样，只要发生命案了（异常），第一时间保存现场，这样什么指纹之类的线索就会清晰很多，坏蛋就算想逃也是插翅难飞啊。</p>
<p>Android Studio给了我们这个能力！那就是<strong>异常断点</strong>!可以在特定异常发生的时候，直接让整个程序断下来；如果你对所有异常感兴趣，直接 <code>Throwable</code> 即可。</p>
<p>具体做法是，进入 <code>Run -&gt; View BreakPoints</code> 或者使用快捷键打开断点设置窗口；如下图：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450700136670.png" width="273" alt="断点设置窗口"></p>
<p>点击左上角的 ➕ ，会出现一个选择框；选择<code>Exception Breakpoint</code>；然后会出现一个对话框，选择你感兴趣的异常：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450700226518.png" width="526" alt="异常断点"></p>
<h2 id="Field_WatchPoint">Field WatchPoint</h2><p>在上面我们添加异常断点的时候，点击加号的时候，有四个选项；第一个就是我们前面所说的第二种方法断点的添加方式，第三个是异常断点，那么第二个 <strong>Field WatchPoint</strong> 是干什么的呢？</p>
<p>有没有这样一种场景：你发现某个值莫名其妙滴不知道什么时候被谁给修改了，罪魁祸首是谁？Java虽然是值传递，但是引用也可以是值；对象全部存放在堆上面，而堆是被所有线程共享的，因此在非常复杂的场景下，你根本不知道这些共享变量被谁修改了，这样非常危险；在多线程环境下，不变性是一个很重要的特性，我们看到高并发的语言诸如 <code>Erlang</code>, <code>Scala</code> 对于这种不变性都有着某种程度的支持。</p>
<p>好吧，扯远了；那么我们怎么揪出这个修改我们值的捣蛋鬼呢？那就是这个 <strong>Field WatchPoint</strong>的功能了；使用它我们可以在某个<strong>Field</strong>被访问或者修改的时候让程序断下来；完美解决这个问题。</p>
<p>下断点的方式和方法断点类似，也有两种；第一种是直接在某个字段的声明处下断点，这时候断点图标会改变，如下图：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450700886216.png" width="354" alt="Field WatchPoint"></p>
<p>右键这个断点我们可以进行一些设置，比如默认是被修改的时候断下来，你也可以改为每次访问这个字段就断下来。</p>
<p>另外一种方式是 <code>Run -&gt; View BreakPoint</code> 打开设置，与异常断点类似。</p>
<h2 id="远不止这么多">远不止这么多</h2><p>上面介绍了这么多给力的功能，其实还有很多细节；打开断点设置窗口（Run -&gt; View Breakpoint`):</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450701055366.png" width="873"></p>
<p>我们可以对<strong>感兴趣的类，感兴趣的某个特定对象</strong>下断点，也可以设置断点的次数，还能使断点在特定的线程才断下来；这些细节就不详细介绍了，大家自己去发掘！</p>
<p>Have Fun!!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写代码不可避免有Bug，通常情况下除了日志最直接的调试手段就是debug；那么你的调试技术停留在哪一阶段呢？仅仅是下个断点单步执行吗？或者你知道 <code>Evaluate Expression</code>, 知道条件断点；可是你听说过日志断点吗，<code>Method Breakpoint</code>, <code>Exception Breakpoint</code> 呢？还有高大上的 <code>Field Watchpoint</code> ?</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450701212799.png" width="338" alt="几种不同的断点"/></p>
<p>你有关注过Android Studio旁边断点的区别吗？比如上图三个断点有什么不同？且听我一一道来。<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="实用技巧" scheme="http://weishu.me/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio你不知道的快捷键(三)]]></title>
    <link href="http://weishu.me/2015/12/17/shortcut-of-android-studio-you-may-not-know-3/"/>
    <id>http://weishu.me/2015/12/17/shortcut-of-android-studio-you-may-not-know-3/</id>
    <published>2015-12-17T02:49:19.000Z</published>
    <updated>2015-12-18T06:12:05.000Z</updated>
    <content type="html"><![CDATA[<p>本文将继续介绍一些非常实用的但是你可能不知道的快捷键；没看过前两篇的可以移步：</p>
<ol>
<li><a href="http://www.tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/" target="_blank" rel="external">Android Studio你不知道的快捷键(一)</a></li>
<li><a href="http://www.tianweishu.com/2015/12/12/shortcut-of-android-studio-you-may-not-know-2/" target="_blank" rel="external">Android Studio你不知道的快捷键(二)</a></li>
</ol>
<h1 id="Select_In-">Select In..</h1><p>说实话，想不出一个比较好的翻译 :P 干脆使用英文吧。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-1.gif" alt="Select In.." width="449"></p>
<p>有没有这样的场景：你在Android Studio打开了一个图片文件（或者别的文件），想在资源浏览器里面查看这图片；在Eclipse里面我想大部分的人是<code>Alt + Enter</code>进入文件属性复制地址，然后在系统资源管理器里面打开；或者装一个EasyExplore插件。在Android Studio里面，这是内建支持的！而且还不止如此！比如你想看看某个文件在包的哪个目录，通常是不是点击Project View上面的那个小圆坐标；用这个快捷键鼠标就能搞定。<br><a id="more"></a><br>快捷键: <code>Alt + F1</code></p>
<p>弹出的菜单有一系列的选项；按对应的数字就可以选择；其他的菜单有什么功能可以自己尝试一下。</p>
<h1 id="拓展选择">拓展选择</h1><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-2.gif" alt="拓展选择" width="357"></p>
<p>这个功能应该很多人都知道；但还是说明一下，因为跟下面两个功能跟这个结合起来才有威力。这个功能太强大了，自己去按几遍就能想到很多使用场景了；我相信有了这个功能，你使用鼠标的机会会少很多。</p>
<ul>
<li>Mac: <code>Alt + up/down</code></li>
<li>Win/Linux: <code>ctrl + w / ctrl + shift + w</code></li>
</ul>
<h1 id="Surround_With-">Surround With..</h1><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-3.gif" alt="Surround With" width="299"></p>
<p>如果你想把一段代码使用<code>if</code>语句包起来；又或者使用<code>try</code>包围一段可能有运行时异常的代码，你会怎么干？</p>
<p>首先用光标定位到代码块开头，写上 <code>try {</code>然后，光标代码块末尾加上<code>} catch (XXXRuntimeException e) {// todo}</code>？可以试试这个快捷键。</p>
<ul>
<li>Mac: <code>cmd + alt + t</code></li>
<li>Win/Linux: <code>ctrl + alt + t</code></li>
</ul>
<p>可以使用上面的拓展选择选择你需要的代码块，然后使用这个功能<em>Surround With</em>；如果你什么都不选择的话，那么默认选择的是光标所在行。</p>
<h1 id="Unwrap/Remove">Unwrap/Remove</h1><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-4.gif" alt="Unwrap" width="546"></p>
<p>这个功能跟上面提到的是一对，有了<em>Surround With</em>自然就有<em>Unsurround With</em>;使用情况没有上面那个那么多，但是好歹一对，一起介绍吧。</p>
<h1 id="高亮某东西">高亮某东西</h1><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-5.gif" alt="highlight something" width="198"></p>
<p>有时候看代码的时候，看到某个变量想知道哪里使用了它；你还在用肉眼查找吗？或者你杀鸡用牛刀<code>Find Usgae</code>？其实你的需求就是把这个变量全部给我打个标签，我想直观的知道它在哪。</p>
<ul>
<li>Mac: <code>cmd + shift + F7</code></li>
<li>Win/Linux: <code>ctrl + shift + F7</code></li>
</ul>
<p>这个键功能远不止这个！</p>
<ol>
<li>如果你高亮<code>return</code>或者<code>throw</code>，那么会把这个方法所有的返回点高亮出来！</li>
<li>高亮某个类的<code>extends</code>或者<code>implements</code>会把这个类Override的方法高亮出来</li>
<li>高亮<code>import</code>会把使用的地方显示出来</li>
</ol>
<p>如果不想要高亮了，按下Esc就行。</p>
<h1 id="显示方法调用树">显示方法调用树</h1><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-6.gif" alt="方法调用树" width="451"></p>
<p>在看源码的时候，你还是使用<code>alt + F7</code>和<code>ctrl + B</code>在各个类之间来回穿梭吗？其实好多时候你就是想知道这个调用结构是怎么样的而已；谁是怎么一步一步滴调用谁的；这个快捷键会给你一个调用树。有了这个大菊观，继续探讨就很容易了。</p>
<p>快捷键: <code>ctrl + alt + h</code></p>
<h1 id="万能快捷键">万能快捷键</h1><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-7.gif" alt="万能快捷键" width="500"></p>
<p>记得之前提到过一个<em>万能重构键</em>, 有关重构的一切操作都可通过它完成。那么Android Studio这么快捷键，这么多功能，臣妾怎么可能都记住！要是有万能钥匙就好了！That’s it!</p>
<p>使用这个快捷键，你想到什么功能，打开它搜索就可以了；打个比方，我想看看Java的<code>for each</code>循环和普通的<code>for</code>循环底层是不是同一个实现;那么我就需要看虚拟机字节码了；我记得有这个功能但是不知道快捷键是啥；OK，<code>Cmd + shift + A</code>，输入<code>bytecode</code>:</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450323104893.png" width="423"></p>
<p>PS:(我用的Intellij IDEA，Android Studio没有集成bytecode功能，可能搜索不到）</p>
<p>好了，其实所有的快捷键的功能都可以用这个搜索到～～实在记不起来也就用万能键吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文将继续介绍一些非常实用的但是你可能不知道的快捷键；没看过前两篇的可以移步：</p>
<ol>
<li><a href="http://www.tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/">Android Studio你不知道的快捷键(一)</a></li>
<li><a href="http://www.tianweishu.com/2015/12/12/shortcut-of-android-studio-you-may-not-know-2/">Android Studio你不知道的快捷键(二)</a></li>
</ol>
<h1 id="Select_In-">Select In..</h1><p>说实话，想不出一个比较好的翻译 :P 干脆使用英文吧。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-1.gif" alt="Select In.." width="449"/></p>
<p>有没有这样的场景：你在Android Studio打开了一个图片文件（或者别的文件），想在资源浏览器里面查看这图片；在Eclipse里面我想大部分的人是<code>Alt + Enter</code>进入文件属性复制地址，然后在系统资源管理器里面打开；或者装一个EasyExplore插件。在Android Studio里面，这是内建支持的！而且还不止如此！比如你想看看某个文件在包的哪个目录，通常是不是点击Project View上面的那个小圆坐标；用这个快捷键鼠标就能搞定。<br>]]>
    
    </summary>
    
      <category term="实用技巧" scheme="http://weishu.me/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio你不知道的快捷键(二)]]></title>
    <link href="http://weishu.me/2015/12/12/shortcut-of-android-studio-you-may-not-know-2/"/>
    <id>http://weishu.me/2015/12/12/shortcut-of-android-studio-you-may-not-know-2/</id>
    <published>2015-12-12T01:51:53.000Z</published>
    <updated>2016-03-22T03:05:44.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="http://tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/" target="_blank" rel="external">Android Studio你不知道的快捷键(一)</a>里面，主要讲述了一些窗口操作的快捷键还有补全参数提示等，这一篇会分享一些代码代码编辑的快捷键。(<strong>默认Keymap</strong>如<a href="http://tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/" target="_blank" rel="external">上文</a>)</p>
<h2 id="自动生成变量">自动生成变量</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-1.gif" alt="自动生成变量"></p>
<p>作为一门静态类型语言，Java是有一定的类型推导能力的；那么你是否经常书写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String testStr = <span class="string">"testStr"</span>;</span><br><span class="line">List&lt;String&gt; testStrings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure></p>
<p>其实大可不必写那些恼火的类型声明的，一看就知道<code>testStr, testStrings</code>就知道是什么类型，再这么干不就是废话么！好在IDEA给了我们这个能力。尝试一下这个快捷键吧，会给你惊喜。<br><a id="more"></a></p>
<ul>
<li>Mac: <code>Cmd + Alt + V</code></li>
<li>Win/Linux: <code>Ctrl + Alt + V</code></li>
</ul>
<p>有的童鞋可能会问了：我使用<code>ArrayList, HashMap</code>的时候，习惯类型声明为<code>List,Map</code>等接口，这个自动生成的类型声明还是具体的实现啊，怎么办？这一点IDE已经帮你想到了，试试<code>shift + tab</code>,他会给你一个可以选择的类型列表～</p>
<h2 id="自动提取参数">自动提取参数</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-2.gif" alt="自动提取参数"></p>
<p>有时候你正在写一个方法的时候发现。哎哟，这个变量最好是当作参数传递进来啊；要做成这么一件事，你必须把这个方法内部所有使用这个局部变量的地方替换，把所有调用这个函数的地方添加参数，繁琐至极！好了有了这个你可以随便玩了：</p>
<ul>
<li>Mac: <code>Cmd + Alt + P</code></li>
<li>Win/Linux: <code>Ctrl + Alt + P</code></li>
</ul>
<p>当然，如果你想保留原来的方法，只是搞一个参数不同的方法（重载）出来，可以在弹出的那个对话框里面打勾。</p>
<h2 id="自动提取方法">自动提取方法</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-3.gif" alt="自动提取方法"></p>
<p>写代码的时候是否会发现不知不觉的这个方法已经太长了，适合分解然后提取出一个个子方法；或者是重构的时候看到一个一两千的函数，你是不是头都大了？一般情况下，我们都是把要提取的代码copy出来，然后写一个方法（还要什么该死的方法签名）然后把这段代码复制进来；其实这个过程是机械的，完全可以由IDE完成：</p>
<ul>
<li>Mac: <code>Cmd + Alt + M</code></li>
<li>Win/Linux: <code>Ctrl + Alt + M</code></li>
</ul>
<p>如果想改变方法的签名，在对话框里面选择你需要的就可以了～</p>
<blockquote>
<p>上面提到了三个快捷键其实是比较类似的，如何记忆呢？</p>
<ol>
<li>首先组合键都是<code>Cmd/Ctrl + Alt</code></li>
<li>然后提取变量<strong>V</strong>ariable=<strong>V</strong>，参数<strong>P</strong>arameters=<strong>P</strong>，方法<strong>M</strong>ethod=<strong>M</strong></li>
</ol>
</blockquote>
<h2 id="内联变量/参数/方法">内联变量/参数/方法</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-4.gif" alt="内联"></p>
<p>好了学会了上面那几个快捷键，万一玩high了，比如提取了太多的方法，想“弄回去”，该怎么办呢？这个操作叫他<code>Inline..</code>：</p>
<ul>
<li>Mac: <code>Cmd + Alt + N</code></li>
<li>Win/Linux: <code>Ctrl + Alt + N</code></li>
</ul>
<p>上面那个图只是参考，其实不仅可以作用于变量，还可以是方法/参数，个人觉得方法inline比较有用。</p>
<h2 id="万能重构键">万能重构键</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-5.png" alt="万能重构键"></p>
<p>静态类型语言重构起来相对容易的，但是通常修改一个地方会牵扯到很多别的地方，我们只有一处一处找到这些编译错误然后手动修复。其实有好多工作是可以自动完成的，比如删除某个方法；先确认有没有人调用（Alt ＋ F7），没有的话把方法体删了，有的话去看看调用的地方再决定怎么办。</p>
<p>但是重构的操作实在是太多了！我们没有办法也没有必要一个个记住，知道这个快捷键即可，我叫他<em>万能重构键</em>:</p>
<ul>
<li>Mac : <code>Ctrl + T</code></li>
<li>Win/Linux: <code>Ctrl + Alt + Shift + T</code></li>
</ul>
<p>在Win/Linux上可以考虑把这个快捷键改一下键，一下按四个键臣妾很难做到啊。。</p>
<p>这个重构菜单每一个功能都可以自己去尝试一下，使用之后不好用你来打我。</p>
<h2 id="重命名">重命名</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-6.gif" alt="重命名"></p>
<p>好了介绍了那么多貌似很高端的玩意，来个大部分人都知道的吧。有时候你发现有个变量名字取得有问题，或者没文化的队友/自己单词拼错了咋办？需要把所有用到这个变量的地方重新命名，小case！</p>
<p>快捷键：<code>shift + F6</code></p>
<p>OK, 这一期的分享就到这里。如果没有看过上一篇的可以移步：<br><a href="http://tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/" target="_blank" rel="external">Android Studio你不知道的快捷键(一)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="http://tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/">Android Studio你不知道的快捷键(一)</a>里面，主要讲述了一些窗口操作的快捷键还有补全参数提示等，这一篇会分享一些代码代码编辑的快捷键。(<strong>默认Keymap</strong>如<a href="http://tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/">上文</a>)</p>
<h2 id="自动生成变量">自动生成变量</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-1.gif" alt="自动生成变量" /></p>
<p>作为一门静态类型语言，Java是有一定的类型推导能力的；那么你是否经常书写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String testStr = <span class="string">"testStr"</span>;</span><br><span class="line">List&lt;String&gt; testStrings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure></p>
<p>其实大可不必写那些恼火的类型声明的，一看就知道<code>testStr, testStrings</code>就知道是什么类型，再这么干不就是废话么！好在IDEA给了我们这个能力。尝试一下这个快捷键吧，会给你惊喜。<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="实用技巧" scheme="http://weishu.me/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio你不知道的快捷键(一)]]></title>
    <link href="http://weishu.me/2015/12/11/shortcut-of-android-studio-you-may-not-know/"/>
    <id>http://weishu.me/2015/12/11/shortcut-of-android-studio-you-may-not-know/</id>
    <published>2015-12-11T05:42:33.000Z</published>
    <updated>2015-12-11T05:59:38.000Z</updated>
    <content type="html"><![CDATA[<p>一般来说键盘用的越多鼠标用的越少，那么写起代码来效率就越高；常见的快捷键想必大家都已经掌握，接下来我就分享一些你可能不知道的但确非常实用的快捷键。</p>
<blockquote>
<p>下文所有快捷键基于如下keymap<br>Windows: Default<br>Linux: Default<br>OSX: Mac OSX 10.5+</p>
</blockquote>
<h2 id="自动补全的时候是Enter还是Tab？">自动补全的时候是Enter还是Tab？</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-1.gif" alt="自动补全enter和tab区别" width="252"><br>在使用自动补全的时候<code>Enter</code>和<code>Tab</code>的行为还是有一些细微的区别的：<br><a id="more"></a></p>
<ol>
<li>使用<code>Enter</code>会补全你选择的语句</li>
<li>使用<code>Tab</code>的话，会替换掉你之前在这里的内容（删除后面的语句直到遇到点号，逗号，分号）</li>
</ol>
<p>这种情况我们还是会经常遇到的，比如要替换一个资源的ID（R.id.a_xxx_xxx)，想必大多数人都是先选择<code>a.xxx_xxx</code>删除，然后输入新的内容，或者相反；其实这时候，用<code>Tab</code>才是最优雅的方式。</p>
<p>快捷键：（在补全的时候)<strong><code>Enter/Tab</code></strong></p>
<h2 id="返回编辑器窗口">返回编辑器窗口</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-2.gif" alt="返回编辑器窗口" width="550"><br>正在写代码的时候，很多操作会让焦点脱离编辑器；比如<em>Find Usage</em>, <em>Logcat</em>, 切换到项目结构视图，类型继承树等；如果视图切换了如何快速切回编辑器继续写代码呢？简单的鼠标点一下编辑器就可以了，但其实还有两种选择：</p>
<ol>
<li><code>Esc</code>: 让编辑器窗口获取焦点，这时候就可以输入代码了</li>
<li><code>Shift + Esc</code>: 这个会让编辑器获取焦点，并且顺手帮你把刚刚打开的窗口关闭了。</li>
</ol>
<p>个人喜欢第二种；Find Usage完毕了，<code>Shift + Esc</code>, 优雅～</p>
<ol>
<li><code>Esc</code>: 返回编辑器</li>
<li><code>Shift + Esc</code>: 返回编辑器并关闭当前窗口</li>
</ol>
<h2 id="返回上次打开的工具窗口">返回上次打开的工具窗口</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-3.gif" alt="返回最后打开的工具窗口" width="495"><br>接上面那个功能，如果你<code>Shift + Esc</code> 写了一会儿代码，发现又需要打开刚刚的窗口怎么办？这种场景通常发生在<em>Logcat</em>这个Tol Window上，看完了日志，写代码，写完代码看日志；如何快速切换？</p>
<p>快捷键：<code>F12</code></p>
<h2 id="快捷打开窗口">快捷打开窗口</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-4.gif" alt="使用数字快捷打开窗口" width="567"><br>有木有发现有的窗口上面有个数字？这样的窗口（工具窗）我们可以快捷打开！</p>
<ul>
<li>Mac: <code>Cmd + 数字</code></li>
<li>windows/Linux: <code>Alt + 数字</code></li>
</ul>
<h2 id="任意窗口切换">任意窗口切换</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-5.gif" alt="窗口切换" width="532"><br>上面的切换还是无法满足你的要求？记得Mac的<code>Cmd + Tab</code>，Windows的<code>Alt/Win + Tab</code>吗？Android Studio也有这个类似的功能，可以让你切换到任意窗口！</p>
<p>在这个切换窗口打开的时候，你可以直接按数字切换到对应的工具窗口，或者输入字母搜索右边的编辑器窗口，如果你需要关闭某个窗口，在上面按<code>BackSpace</code>即可。</p>
<p>快捷键：<code>Ctrl + Tab</code></p>
<h2 id="隐藏所有窗口">隐藏所有窗口</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-6.gif" alt="隐藏所有窗口" width="566"><br>好了学了那么多打开窗口的技能，如果你想关闭那些乱七八糟的窗口，安安静静写代码应该怎么办？</p>
<ul>
<li>Mac: <code>CMD + Shift + F12</code></li>
<li>windows/Linux: <code>Ctrl + shift + F12</code></li>
</ul>
<p>如果需要恢复所有窗口，再按一次这个快捷键即可。</p>
<h2 id="参数提示">参数提示</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-7.gif" alt="参数提示" width="472"><br>这个功能估计很多人知道了，但是还是提一下。在自动补全以后，如果某个方法参数超级长，你不知道参数是什么怎么办？可以试试这个。</p>
<ul>
<li>Mac: <code>CMD + P</code></li>
<li>win/Linux: <code>Ctrl + P</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>一般来说键盘用的越多鼠标用的越少，那么写起代码来效率就越高；常见的快捷键想必大家都已经掌握，接下来我就分享一些你可能不知道的但确非常实用的快捷键。</p>
<blockquote>
<p>下文所有快捷键基于如下keymap<br>Windows: Default<br>Linux: Default<br>OSX: Mac OSX 10.5+</p>
</blockquote>
<h2 id="自动补全的时候是Enter还是Tab？">自动补全的时候是Enter还是Tab？</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-1.gif" alt="自动补全enter和tab区别" width="252"/><br>在使用自动补全的时候<code>Enter</code>和<code>Tab</code>的行为还是有一些细微的区别的：<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="实用技巧" scheme="http://weishu.me/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]厌倦了NullPointException？Optional拯救你！]]></title>
    <link href="http://weishu.me/2015/12/08/use-optional-avoid-nullpointexception/"/>
    <id>http://weishu.me/2015/12/08/use-optional-avoid-nullpointexception/</id>
    <published>2015-12-08T12:49:40.000Z</published>
    <updated>2015-12-10T06:31:54.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>I call it my billion-dollar mistake. It was the invention of the null reference in 1965. I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement.<br>—Tony Hoare</p>
</blockquote>
<p>有人说，当你处理过了空指针异常才真正成为一个Java开发者。抛开玩笑话不谈，空指针确实是很多bug的根源。Java SE 8引入了一个新的叫做<code>java.util.Optional</code> 的类来缓解这个问题。</p>
<p>我们首先看看空指针有什么危险，<code>Computer</code>是一个嵌套的对象，如图：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-9-1.gif" alt="Comtuper对象"></p>
<p>下面的代码有什么潜在的问题呢？<br><code>String version = computer.getSoundcard().getUSB().getVersion();</code></p>
<p>貌似可行，但是，很多电脑（比如 Raspberry Pi）并没有Soundcard，因此调用<code>getSoundcard</code>会发生什么？毫无疑问，结果自然是在运行时给你抛出一个<code>NullPointException</code>，然后终止程序的执行。</p>
<p>如何避免上面的空指针异常呢？一般的做法就是在调用方法之前进行检测：<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String version = <span class="string">"UNKNOWN"</span>;</span><br><span class="line"><span class="keyword">if</span>(computer != <span class="keyword">null</span>)&#123;</span><br><span class="line">  Soundcard soundcard = computer.getSoundcard();</span><br><span class="line">  <span class="keyword">if</span>(soundcard != <span class="keyword">null</span>)&#123;</span><br><span class="line">    USB usb = soundcard.getUSB();</span><br><span class="line">    <span class="keyword">if</span>(usb != <span class="keyword">null</span>)&#123;</span><br><span class="line">      version = usb.getVersion();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，上面嵌套if检测的代码确实不怎么好看。但是没办法，我们需要很多这样死板的没什么意义的代码来避免碰到<code>NullPointException</code>。更恼火的是，这部分代码成了我们业务逻辑的一部分，还降低了代码的可读性。</p>
<p>万一我们忘记对某个可能为<code>null</code>的对象进行非空检测怎么办？<strong>使用<code>null</code>来说明某个值缺失是一种错误的方式</strong>, 下文将说明这个问题并给出更好的解决办法。</p>
<p>先看看别的编程语言是如何处理这个问题的。</p>
<h2 id="Null的替代物">Null的替代物</h2><p>Grovvy语言有一个<code>?.</code>的操作符，可以安全地处理潜在可能的空引用（C#即将包含这个特性，Java7曾被建议引入这个但是并没有发布。）它是这么用的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String version = computer?.getSoundcard()?.getUSB()?.getVersion();</span><br></pre></td></tr></table></figure>
<p>如果<code>getSoundcard()</code>,<code>getUSB()</code>,<code>getVersion</code>任意一个返回<code>null</code>，变量<code>version</code>就被赋值为<code>null</code>，不需要额外的复杂的嵌套检测。更好的是，Grovvy还有一个<em>Elvis</em>操作符:<code>?:</code>，可以给类似上面的表达式提供默认值。下面的表达式如果<code>?.</code> 返回了<code>null</code>那么变量<code>version</code>会被赋值为<code>&quot;UNKNOW&quot;</code>:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String version = computer?.getSoundcard()?.getUSB()?.getVersion() ?: &#34;UNKNOWN&#34;;</span><br></pre></td></tr></table></figure></p>
<p>其他的一些函数式编程语言，比如Haskell, Scala，使用了一种别的方式。Haskell有一个<code>Maybe</code>型态，这个型态代表了一种有可选值的类型。Maybe形态的值可能包含一个给定类型的值或者是Nothing(译者注：代表没有值)，完全没有空指针的概念。Scala有一种类似的叫做<strong>Option[T]</strong>的东西来代表类型T的某一个值存在或者没有。因此，你必须显式检测这个值是否存在，如果不存在就不能使用任何Option类型的操作符；这样由于Scala的类型系统，你永远也不会忘记对于空指针的检测。</p>
<p>貌似有点扯远了，那么，Java8给我们提供了什么呢？</p>
<h2 id="果壳里的Optional">果壳里的<code>Optional</code></h2><p>受到Haskell和Scala的启发，Java8引入了一个叫做<code>java.util.Optional&lt;T&gt;</code>的类，这一个包含一个可选值的类型，你可以把它当作包含单个值的容器——这个容器要么包含一个值要么什么都没有，如下图：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-9-2.gif" alt="Optional表示"><br>我们在数据模型里面引入<code>Optional</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Optional&lt;Soundcard&gt; soundcard;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Optional&lt;Soundcard&gt; <span class="title">getSoundcard</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soundcard</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Optional&lt;USB&gt; usb;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Optional&lt;USB&gt; <span class="title">getUSB</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getVersion</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用上面的代码，我们一眼就可以看出来一个computer有没有soundcard（他们是optioal，可选的），更进一步，一个声卡也有一个可选的USB端口；新的模型能清晰地反映出一个给定的值是有可能不存在的。这种做法在某些库里面也存在，比如<strong>Guava</strong>(译：Java5之后就可以使用，不过有局限)</p>
<p>我们能用<em>Optional</em>对象干什么？Optional对象包含了一些方法来显式地处理某个值是存在还是缺失，Optional类强制你思考值不存在的情况，这样就能避免潜在的空指针异常。</p>
<p>值得一提的是，设计Optional类的目的并不是完全取代<code>null</code>, 它的目的是设计更易理解的API。通过Optional，可以从方法签名就知道这个函数有可能返回一个缺失的值，这样强制你处理这些缺失值的情况。</p>
<h2 id="Optional的正确打开方式">Optional的正确打开方式</h2><p>废话扯了这么多，来点实际的例子吧！首先来看看如何使用Optional类来实现传统的空指针检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = computer.flatMap(Computer::getSoundcard)</span><br><span class="line">                          .flatMap(Soundcard::getUSB)</span><br><span class="line">                          .map(USB::getVersion)</span><br><span class="line">                          .orElse(<span class="string">"UNKNOWN"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果无法理解这段代码，可以复习Java8的lambda和方法引用,见<a href="http://www.oracle.com/technetwork/articles/java/architect-lambdas-part1-2080972.html" target="_blank" rel="external">Java8 Lambdas</a> 以及stream pipelining概念,见<a href="http://www.oraclejavamagazine-digital.com/javamagazine_open/20140304#pg51" target="_blank" rel="external">Processing Data with Java SE 8 Steams</a></p>
</blockquote>
<h3 id="创建Optional对象">创建Optional对象</h3><p>如何创建Optional对象呢，有下面几种方式：</p>
<ol>
<li>空的Optional</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Soundcard&gt; sc = Optional.empty();</span><br></pre></td></tr></table></figure>
<ol>
<li>包含非空值的Optional</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SoundCard soundcard = <span class="keyword">new</span> Soundcard();</span><br><span class="line">Optional&lt;Soundcard&gt; sc = Optional.of(soundcard);</span><br></pre></td></tr></table></figure>
<p>一旦<code>soundcard</code>是<code>null</code>，这段代码会立即抛出一个<code>NullPointException</code>（而不是等你以后你访问这个空的soundcard对象的时候)</p>
<ol>
<li>可能为空的Optional</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Soundcard&gt; sc = Optional.ofNullable(soundcard);</span><br></pre></td></tr></table></figure>
<p>如果<code>soundcard</code>是<code>null</code>那么这个<code>Optional</code>将会是<code>empty</code>.</p>
<h3 id="值存在的时候进行进一步的操作">值存在的时候进行进一步的操作</h3><p>现在你有了一个Optional对象，你可以显式地处理值存在或者不存在的情况，再也不用想这样如履薄冰地进行空指针检测了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SoundCard soundcard = ...;</span><br><span class="line"><span class="keyword">if</span>(soundcard != <span class="keyword">null</span>)&#123;</span><br><span class="line">  System.out.println(soundcard);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，可以使用<code>ifPresent()</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Soundcard&gt; soundcard = ...;</span><br><span class="line">soundcard.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>
<p>现在，你再也不用显示地进行非空检测了，类型系统帮你干了这件事。如果Optional是empty,上面的代码就不会执行打印了。</p>
<p>你也可以使用<code>isPresent()</code>方法检查某个值是否存在，另外，<code>get</code> 方法可以返回Optional容器里面包含的那个对象，如果没有这个对象，<code>get</code>方法会立即抛出一个<code>NoSuchElementException</code>，这两个方法可以结合起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(soundcard.isPresent())&#123;</span><br><span class="line">  System.out.println(soundcard.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，并不提倡这样使用Optional。（这么做跟<code>null</code>检测有什么区别？），下面有一些惯用手法，我们来看一下。</p>
<h3 id="默认值和默认操作">默认值和默认操作</h3><p>在某个操作返回空的时候给出一个默认值也是一个典型的场景，通畅的做法是使用三目运算符(<code>?</code>):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Soundcard soundcard = maybeSoundcard != <span class="keyword">null</span> ? </span><br><span class="line">            maybeSoundcard : <span class="keyword">new</span> Soundcard(<span class="string">"basic_sound_card"</span>);</span><br></pre></td></tr></table></figure>
<p>可以使用Optional对象的<code>ifElse</code>方法改进这个代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Soundcard soundcard = maybeSoundcard.orElse(<span class="keyword">new</span> Soundcard(<span class="string">"defaut"</span>));</span><br></pre></td></tr></table></figure>
<p>如果你想在空值的时候抛出一个异常，可以使用<code>ifElseThrow</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Soundcard soundcard = </span><br><span class="line">  maybeSoundCard.orElseThrow(IllegalStateException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<h3 id="使用filter过滤特定值">使用<code>filter</code>过滤特定值</h3><p>很多时候你需要调用某个对象的方法并且检查它的一些属性。例如：你可能需要检测一个USB的端口是否是一个特定的版本；如果需要避免空指针异常，通畅的方式是检测非空然后调用<code>getVersion</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USB usb = ...;</span><br><span class="line"><span class="keyword">if</span>(usb != <span class="keyword">null</span> &amp;&amp; <span class="string">"3.0"</span>.equals(usb.getVersion()))&#123;</span><br><span class="line">  System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Optional的<code>filter</code>可以这么干：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;USB&gt; maybeUSB = ...;</span><br><span class="line">maybeUSB.filter(usb -&gt; <span class="string">"3.0"</span>.equals(usb.getVersion())</span><br><span class="line">                    .ifPresent(() -&gt; System.out.println(<span class="string">"ok"</span>));</span><br></pre></td></tr></table></figure>
<p><code>filter</code>方法带有一个<code>Predicate</code>的参数，如果Optional容器里面的对象存在并且满足这个predicate,那么<code>filter</code>返回那个对象，否则就返回<code>empty</code>的Optional。（跟<code>Stream</code>接口的<code>filter</code>类似）</p>
<h3 id="使用map转换值">使用<code>map</code>转换值</h3><p>另外一个比较常见的场景是需要从某个对象里面提取出特定的值。例如：从一个<code>Soundcard</code>对象里面取出一个<code>USB</code>对象然后检测这个usb对象是否是正确的版本。通常可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(soundcard != <span class="keyword">null</span>)&#123;</span><br><span class="line">  USB usb = soundcard.getUSB();</span><br><span class="line">  <span class="keyword">if</span>(usb != <span class="keyword">null</span> &amp;&amp; <span class="string">"3.0"</span>.equals(usb.getVersion())&#123;</span><br><span class="line">    System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Optional的<code>map</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;USB&gt; usb = maybeSoundcard.map(Soundcard::getUSB);</span><br></pre></td></tr></table></figure>
<p>Optional容器里面的值被某个函数（这里是USB的方法引用）作为参数“转换”了，如果Optional是<code>empty</code>那么就什么也不会发生。</p>
<p>结合使用<code>map</code>和<code>filter</code>可以检测某个声卡是否有USB 3.0的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maybeSoundcard.map(Soundcard::getUSB)</span><br><span class="line">      .filter(usb -&gt; <span class="string">"3.0"</span>.equals(usb.getVersion())</span><br><span class="line">      .ifPresent(() -&gt; System.out.println(<span class="string">"ok"</span>));</span><br></pre></td></tr></table></figure>
<p>现在我们的代码看起来比较像是在描述问题了！而且没有任何非空检测，太酷了！</p>
<h3 id="使用flatMap级联Optional">使用<code>flatMap</code>级联Optional</h3><p>我们已经有一些常见的模式可以通过<code>Optional</code>重构了，那么我们如何用一种安全的方式重构下面的代码呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String version = computer.getSoundcard().getUSB().getVersion();</span><br></pre></td></tr></table></figure>
<p>上面的代码都是从一个对象里面取出另外一个对象， 这不正是上文介绍的<code>map</code>吗？我们改写Computer模型对象，让它拥有一个<code>Optional&lt;Soundcard&gt;</code>和一个<code>Optional&lt;USB&gt;</code>，然后就可以把代码改成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String version = computer.map(Computer::getSoundcard)</span><br><span class="line">                  .map(Soundcard::getUSB)</span><br><span class="line">                  .map(USB::getVersion)</span><br><span class="line">                  .orElse(<span class="string">"UNKNOWN"</span>);</span><br></pre></td></tr></table></figure>
<p>但是，这段代码并不能通过编译。为什么？</p>
<p><code>computer</code>变量类型是<code>Optional&lt;Computer&gt;</code>，因此它调用<code>map</code>方法没有任何问题；但是，<code>getSoundcard()</code>方法的返回类型是<code>Optional&lt;Soundcard&gt;</code>这意味着<code>map</code>操作结果的类型是<code>Optional&lt;Optional&lt;Soundcard&gt;&gt;</code>,因此<code>getUsb</code>这个调用是非法的：外面的那个Optional包含的值是另外一个Optional，自然就没有<code>getUsb</code>方法，下图是这个调用的结构：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-9-3.gif" alt="two level Optional"><br>如何解决这个问题呢？Optional类提供了一个<code>flapMap</code>的方法。这个方法可以对一个Optional使用一个函数转换为一个Optional然后把结果（两个Optional)flatten为一个单个Optional，下图给出了<code>map</code>和<code>flatMap</code>的区别：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-9-4.gif" alt="map and flatMap"><br>用<code>flatMap</code>重写我们的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String version = computer.flatMap(Computer::getSoundcard)</span><br><span class="line">                   .flatMap(Soundcard::getUSB)</span><br><span class="line">                   .map(USB::getVersion)</span><br><span class="line">                   .orElse(<span class="string">"UNKNOWN"</span>);</span><br></pre></td></tr></table></figure>
<p>第一个<code>flatMap</code>确保返回一个<code>Optioan&lt;Soundcard&gt;</code>而不是<code>Optional&lt;&lt;Optional&lt;Soundcard&gt;&gt;</code>，第二个<code>flatMap</code>确保返回一个<code>Optional&lt;USB&gt;</code>；接着第三次调用着需要一个<code>map</code>即可，因为<code>getVersion</code>返回一个<code>String</code>而非<code>Optional</code>方法。</p>
<p>Cool！现在我们可以抛弃痛苦的嵌套非空检测了，使用Optional可以写出声明式的，更可读的代码，并且永远不会有空指针异常！</p>
<h2 id="总结">总结</h2><p>本文介绍了如何使用Java SE 8的<code>java.util.Optional&lt;T&gt;</code>。<code>Optional</code>的目的不是替换你代码里面的每个<code>null</code>，它可以帮助你设计出更好的API，使用者通过方法签名就能知道是否有一个可选的值。另外，Optional通过强迫主动处理空指针情况，可以保护代码不出现<code>NullPointException</code>。</p>
<h2 id="译后感">译后感</h2><p>嵌套的非空检测确实是个很头大的问题，虽然有一些静态代码检测工具可以检测到这些异常，但是这样无聊的检测代码很是让人失望。Java 8引入的<code>Optional</code>确实可以部分缓解这部分问题；但是依然存在局限性，比如，如果某个特定的方法调用出了别的运行时异常怎么办？对于?Haskell Maybe Monad只吸收了一部分，不过已经很不错了，期待什么时候能引入Grovvy的<code>?.</code>操作符，在处理空指针问题上，<code>?.</code>更加简洁有力。</p>
<p><code>Optional</code>虽好，但是Java 8目前并不普及，Android 就不用想了。虽然有<a href="https://github.com/orfjackal/retrolambda" target="_blank" rel="external">retrolambda</a>项目支持在Java 6里面使用lambda，但是它更多地是提供了语法糖：</p>
<ol>
<li>lambda的实现使用的是匿名内部类而不是<code>invokedynamic</code>, 见<a href="http://www.infoq.com/cn/articles/Java-8-Lambdas-A-Peek-Under-the-Hood" target="_blank" rel="external">深入探索Java 8 Lambda表达式</a></li>
<li>方法引用是lambda的语法糖，实现相同</li>
<li>接口默认方法实际上给接口生成了一个抽象方法，然后给所有接口的实现者添加了这个默认实现</li>
<li>接口静态方法，实际上把静态方法放在另外一个类里面，然后把所有对接口静态方法的调用更换为对新生成类里面方法的调用</li>
</ol>
<p>鉴于以上种种原因，在生产环境基本上不可能使用<em>retrolambda</em>了，大型系统还是老实一点吧。</p>
<p>虽然Grava项目也有一个<code>Optional</code>类，但是没有函数式接口，我们所能做的不过是把<code>if (obj == null)</code>替换为<code>if (opt.isPresend())</code>罢了；虽说能提高类型安全性，但是还是得写一堆shit一样的嵌套检测。</p>
<p>对于Android开发，想使用这个是没有希望了。但愿<strong>Kotlin</strong>能给我们惊喜。</p>
<h2 id="参考">参考</h2><ol>
<li>Chapter 9, “Optional: a better alternative to null,” <a href="http://www.manning.com/urma/" target="_blank" rel="external">from Java 8 in Action: Lambdas, Streams, and Functional-style Programming</a></li>
<li>“<a href="http://www.slideshare.net/mariofusco/monadic-java" target="_blank" rel="external">Monadic Java</a>“ by Mario Fusco</li>
<li><a href="http://www.oraclejavamagazine-digital.com/javamagazine_open/20140304#pg51" target="_blank" rel="external">Processing Data with Java SE 8 Streams</a></li>
</ol>
<h2 id="致谢">致谢</h2><p>Thanks to Alan Mycroft and Mario Fusco for going through the adventure of writing Java 8 in Action: Lambdas, Streams, and Functional-style Programming with me.</p>
<h2 id="关于作者">关于作者</h2><p>Raoul-Gabriel Urma (@raoulUK) is currently completing a PhD in computer science at the University of Cambridge, where he does research in programming languages. He’s a coauthor of the upcoming book Java 8 in Action: Lambdas, Streams, and Functional-style Programming, published by Manning. He is also a regular speaker at major Java conferences (for example, Devoxx and Fosdem) and an instructor. In addition, he has worked at several well-known companies—including Google’s Python team, Oracle’s Java Platform group, eBay, and Goldman Sachs—as well as for several startup projects.</p>
<p><strong>原文</strong>：<a href="http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html" target="_blank" rel="external">http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>I call it my billion-dollar mistake. It was the invention of the null reference in 1965. I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement.<br>—Tony Hoare</p>
</blockquote>
<p>有人说，当你处理过了空指针异常才真正成为一个Java开发者。抛开玩笑话不谈，空指针确实是很多bug的根源。Java SE 8引入了一个新的叫做<code>java.util.Optional</code> 的类来缓解这个问题。</p>
<p>我们首先看看空指针有什么危险，<code>Computer</code>是一个嵌套的对象，如图：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-9-1.gif" alt="Comtuper对象"></p>
<p>下面的代码有什么潜在的问题呢？<br><code>String version = computer.getSoundcard().getUSB().getVersion();</code></p>
<p>貌似可行，但是，很多电脑（比如 Raspberry Pi）并没有Soundcard，因此调用<code>getSoundcard</code>会发生什么？毫无疑问，结果自然是在运行时给你抛出一个<code>NullPointException</code>，然后终止程序的执行。</p>
<p>如何避免上面的空指针异常呢？一般的做法就是在调用方法之前进行检测：<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://weishu.me/tags/java/"/>
    
      <category term="optional" scheme="http://weishu.me/tags/optional/"/>
    
      <category term="java" scheme="http://weishu.me/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让Alfred支持拼音搜索]]></title>
    <link href="http://weishu.me/2015/12/07/make-alfred-support-pinyinyin-search/"/>
    <id>http://weishu.me/2015/12/07/make-alfred-support-pinyinyin-search/</id>
    <published>2015-12-06T20:39:49.000Z</published>
    <updated>2015-12-10T06:34:21.000Z</updated>
    <content type="html"><![CDATA[<p>Alfred是个好东西，不过检索程序的时候不支持拼音搜索；我在论坛看到有人给作者反馈过，无奈作者说支持中文，他不知道拼音是什么，于是就不了了之了。举个例子：我想打开<code>网易云音乐</code>,可是当我输入<code>wangyiyunyinyue</code>的时候却是这样的结果:</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1449431593204.png" width="536" alt="不支持拼音的搜索结果"></p>
<p>要么我知道这个App的名字叫做<code>NeteaseMusic</code>，要么我就需要用中文输入<code>网易云音乐</code>打开了；如果恰巧输入法是英文输入状态，那么就会遇到上图的情况；这时候再把已经输入的删除然后切换输入法打开，效率无疑大大折扣。</p>
<a id="more"></a>
<p>就算这里搜索这个App可以使用英文名字解决，可是对于某些系统程序比如邮件可能还知道是<code>Mail</code>，那么备忘录呢？便签呢？还有一些别的中文程序没有英文名的比如马克飞象？如果Alfred能支持拼音搜索，这些问题全部都没了！而且，Alfred可以强制使用英文输入，直接使用字母检索，不用切换输入法了。</p>
<h2 id="原理">原理</h2><p>经过简单的观察之后，发现Alfred检索程序不仅仅是检索名字，还收集了一些额外的信息；在Alfred作者的帮助下，知道它利用了Mac文件系统的一个<strong>拓展信息</strong>的字段；如果你发现某些目录后面有<code>@</code>那么就是有拓展信息了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x+  <span class="number">3</span> root    wheel  <span class="number">102</span>  <span class="number">9</span> <span class="number">10</span>  <span class="number">2014</span> Stickies.app/</span><br><span class="line">drwxr-xr-x@  <span class="number">3</span> weishu  admin  <span class="number">102</span>  <span class="number">3</span> <span class="number">26</span>  <span class="number">2015</span> Sublime Text.app/</span><br></pre></td></tr></table></figure>
<p>可以借助命令行工具<code>xattr</code>进行操作；具体使用可以<code>man xattr</code>.</p>
<p>所以，我们可以通过<strong>把拼音信息添加到文件的拓展信息里面</strong>去，这样Alfred就能借助这些信息帮助拼音检索了。</p>
<h2 id="实现">实现</h2><h3 id="获取程序名">获取程序名</h3><p>程序名不仅仅是一个文件名这么简单，Mac软件有一个叫做<em>localization</em>的概念，大致就是国际化吧；程序结构把国际化的字段存放在不同的文件里面，在程序本地化之后自动load.</p>
<p>我们要使用的那个字段是<code>CFBundleName</code>存放在<code>/&lt;App&gt;/Contents/Resources/&lt;language&gt;/InfoPlist.strings</code>这个文件里面；我们把这个名字读取出来即可。</p>
<p>尝试过使用<code>objc</code>的接口<code>NSBundle.localizedInfoDiction</code>来获取本地化的字段，无奈拿到的永远是英文字段；只好手工解析中文字段了（不会Objc 😭）；使用的命令行工具<code>plutil</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_localized_name</span><span class="params">(abs_path)</span>:</span></span><br><span class="line">    <span class="string">'''get the localized name of given app'''</span></span><br><span class="line">    bundle = NSBundle.new()</span><br><span class="line">    bundle.initWithPath_(abs_path)</span><br><span class="line">    localizations = bundle.localizations()</span><br><span class="line">    chinese = (<span class="string">'zh_CN'</span>, <span class="string">'zh_Hans'</span>)</span><br><span class="line"></span><br><span class="line">    b = any(map(<span class="keyword">lambda</span> x: x <span class="keyword">in</span> localizations, chinese))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> b: <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> chinese:</span><br><span class="line">        path = bundle.pathForResource_ofType_inDirectory_forLanguage_(<span class="string">'InfoPlist'</span>, <span class="string">'strings'</span>, <span class="keyword">None</span>, ch)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path: <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># the path must surround with "", there may be space characters</span></span><br><span class="line">        json_str = subprocess.check_output(<span class="string">u'plutil -convert json -o - "%s"'</span> % path, shell=<span class="keyword">True</span>)</span><br><span class="line">        <span class="comment"># print json_str</span></span><br><span class="line">        json_res = json.loads(json_str, encoding=<span class="string">'utf8'</span>)</span><br><span class="line">        name = json_res.get(<span class="string">'CFBundleName'</span>)</span><br><span class="line">        <span class="keyword">if</span> name: <span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>
<h3 id="转换为拼音">转换为拼音</h3><p>可以直接使用python的拼音转换库<a href="https://github.com/mozillazg/python-pinyin" target="_blank" rel="external">pypinyin</a>,借助这个工具，一行代码搞定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_app_pinyin_name</span><span class="params">(app_name)</span>:</span></span><br><span class="line">    reduce(<span class="keyword">lambda</span> x, y: x + y, lazy_pinyin(app_name, errors=<span class="string">'ignore'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="添加拼音信息">添加拼音信息</h3><p>拼音信息被添加到文件的拓展信息里面，直接使用<code>xattr</code>添加即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add_meta_data</span><span class="params">(app_pinyin_name, app_path)</span>:</span></span><br><span class="line">    <span class="string">''' add meta data(comments) to the app, which can help Alfred or SpotLight find it'''</span></span><br><span class="line">    subprocess.check_call(<span class="string">'xattr -w com.apple.metadata:kMDItemFinderComment %s %s'</span> % (app_pinyin_name, app_path), shell=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>好了，把这些代码整合起来，就能得到最终的结果了，完整的代码在<a href="https://gist.github.com/tiann/35fb758c18036d7f8640" target="_blank" rel="external">这里</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    pattern = re.compile(<span class="string">r'^[\w\s.]+$'</span>)</span><br><span class="line"></span><br><span class="line">    workspace = NSWorkspace.sharedWorkspace()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> app_dir <span class="keyword">in</span> APP_DIRECTORYS:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(app_dir): <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(app_dir, topdown=<span class="keyword">True</span>):</span><br><span class="line">            remove_list = []</span><br><span class="line">            <span class="keyword">for</span> directory <span class="keyword">in</span> dirs:</span><br><span class="line">                <span class="comment"># print type(directory), root, directory</span></span><br><span class="line">                full_path = os.path.join(root, directory)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> _is_application(workspace, full_path): <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                remove_list.append(directory)</span><br><span class="line">                </span><br><span class="line">                localized_name =  _get_localized_name(full_path)</span><br><span class="line">                app_name = localized_name <span class="keyword">if</span> localized_name <span class="keyword">else</span> directory.rsplit(<span class="string">r'.'</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> pattern.match(app_name): </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                _add_meta_data(_get_app_pinyin_name(app_name), full_path)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if this directory is already a Application</span></span><br><span class="line">            <span class="comment"># do not traverse this; some app may be very large </span></span><br><span class="line">            <span class="comment"># and there won't be any other app inside it</span></span><br><span class="line">            dirs[:] = [d <span class="keyword">for</span> d <span class="keyword">in</span> dirs <span class="keyword">if</span> d <span class="keyword">not</span> <span class="keyword">in</span> remove_list]</span><br></pre></td></tr></table></figure>
<p>最后，我们执行这一段脚本即可<code>sudo python main.py</code>。之所以需要<strong>sudo</strong>是因为某些系统程序（比如家计算器），直接使用是没有权限的。</p>
<p>最后看效果：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdownalfredpinyin.gif" width="1104" alt="支持拼音搜索效果图"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Alfred是个好东西，不过检索程序的时候不支持拼音搜索；我在论坛看到有人给作者反馈过，无奈作者说支持中文，他不知道拼音是什么，于是就不了了之了。举个例子：我想打开<code>网易云音乐</code>,可是当我输入<code>wangyiyunyinyue</code>的时候却是这样的结果:</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1449431593204.png" width="536" alt="不支持拼音的搜索结果"/></p>
<p>要么我知道这个App的名字叫做<code>NeteaseMusic</code>，要么我就需要用中文输入<code>网易云音乐</code>打开了；如果恰巧输入法是英文输入状态，那么就会遇到上图的情况；这时候再把已经输入的删除然后切换输入法打开，效率无疑大大折扣。</p>]]>
    
    </summary>
    
      <category term="alfred" scheme="http://weishu.me/tags/alfred/"/>
    
      <category term="python" scheme="http://weishu.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mac下自动切换输入法]]></title>
    <link href="http://weishu.me/2015/12/01/autoswitch-keyboard-in-mac/"/>
    <id>http://weishu.me/2015/12/01/autoswitch-keyboard-in-mac/</id>
    <published>2015-12-01T02:17:29.000Z</published>
    <updated>2015-12-02T06:53:30.000Z</updated>
    <content type="html"><![CDATA[<p>长久以来，输入法一直是困扰mac用户的一个问题；不过随着国内厂商的跟进，这种状况得到了极大的改善。不用自己去折腾什么<strong>鼠须管</strong>了，狼厂和企鹅都做的不错。</p>
<p>不过依然有一个问题没有完全解决：不同程序之间输入的自动切换。</p>
<p>相信大家一定有切换到<code>item2</code>输入两个命令发现是中文然后按<code>cmd + space</code>切换的尴尬；另外如果你如果使用vi或者emacs，那么就更蛋疼了。造成这种状况的根本原因在于：<strong>输入法的状态是混乱的</strong>，我无法明白现在自己处于哪一种输入环境，除非我开始打字或者看右上角输入法的图标。我希望<code>item2</code>,<code>Intellij IDEA</code>,<code>Alfred2</code><strong>永远</strong>是英文输入状态，除非手动切换；其他的程序比如chrome浏览器，邮件客户端保持正常。</p>
<p>打个比方，使用<code>sublime</code>写代码，大多数情况下肯定是英文输入状态，写注释的时候可能手动切换到中文；但是这里有个问题，这时候如果我切换到其他程序，然后改变了输入的状态，再次回到<code>sublime</code>，fuck!怎么又成了中文!</p>
<p>目前解决方案有如下方式：</p>
<ol>
<li>mac系统自带的设置-&gt; 键盘 -&gt; 输入源 -&gt; 自动使用文稿的输入源</li>
<li>一些输入法的类似<em>安静模式</em>的功能</li>
</ol>
<a id="more"></a>
<p>第一种方式，意思就是不同的程序保持独立的输入状态，不会出现你在另外一个程序切换了输入法的时候再次回来输入法状态就变了。这个开关很有用，我使用了一段时间，发现还是怪怪的，有时候并不符合预期，但是具体场景也搞不明白，反正是一头雾水，有时候依然会陷入困惑的状态。</p>
<p>第二种方式很有意思，应该可以满足很多非程序员的需求。这个<em>安静模式</em>，打个比方，鼠须管输入法；这种输入法其实有几种输入模式，如果对于<code>sublime</code>开启安静模式，那么在进入<code>sublime</code>程序的时候，会自动切换到英文输入模式；nice！不过问题就是：如果要切换到中文模式，需要按<code>ctrl</code>或者<code>shift</code>。如果使用一些IDE的话，肯定各种快捷键用的飞起，怎么少的了按<code>ctrl</code>和<code>shift</code>，这时候问题就来了，如果我们一不小心在使用某些快捷键的时候触发了这个输入法的模式切换功能，那么就蛋疼了：我们需要不停滴按<code>shift</code>切换确保自己处于正确的状态。更糟糕的是，如果你发现自己处于鼠须管的英文输入模式，想使用中文，然后按了<code>cmd + space</code> 切换，你有可能会切换到系统的英文输入法，打个字发现依然是英文！fuck！你不信邪，以为是没有按到，再猛敲几次<code>cmd + space</code>，最后你自己处于那个状态就晕了。</p>
<h2 id="怎么正确配置输入法">怎么正确配置输入法</h2><p>经过这些折腾之后，可以得到输入法的这么几条最佳实践：</p>
<ol>
<li>最基本的原则是要很方便滴知道自己处于哪一种输入状态。如果任何时候清楚这个，那么就是简单的切换问题了。</li>
<li>最好不要使用一个输入的两种模式，并使用<code>shift</code>或者<code>ctrl</code>切换；如上文，某些情况会陷入极度混乱，最好在输入法之间切换，模式简单。</li>
<li>所有程序输入法状态应该有一个恒定的初始态，每次你重新进入这个程序，就会回到初始状态。</li>
</ol>
<p>为什么需要一个恒定的初始状态呢？为了明确自己处于哪一种输入状态，只需要在每次进入这个程序的时候，不管之前做过什么，它的状态是确定的，姑且叫它初始态；然后基于原则2，每次你希望切换的时候<code>cmd + space</code>一下，需要的时候换回来，如果你去了别的程序再回来，状态重置为初始态。</p>
<p>好了分析了这么多，其实要解决的问题就是3一个，我们写一段小程序。</p>
<h2 id="切换输入法实现">切换输入法实现</h2><p>mac下如果使用objc或者swift切换输入法很简单，Apple提供了很详细的Text Input Service文档（现在这个文档403了，可以使用google的cache访问)；我希望使用python来调用这些接口，很遗憾的是，<code>pyobjc</code>没有封装<code>TIS</code>系列函数，手动使用<code>ctypes</code>模块来wrap一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> ctypes.util</span><br><span class="line"><span class="keyword">import</span> objc</span><br><span class="line"><span class="keyword">import</span> CoreFoundation</span><br><span class="line"></span><br><span class="line">_objc = ctypes.PyDLL(objc._objc.__file__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PyObject *PyObjCObject_New(id objc_object, int flags, int retain)</span></span><br><span class="line">_objc.PyObjCObject_New.restype = ctypes.py_object</span><br><span class="line">_objc.PyObjCObject_New.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_int]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">objc_object</span><span class="params">(id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _objc.PyObjCObject_New(id, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># kTISPropertyLocalizedName</span></span><br><span class="line">kTISPropertyUnicodeKeyLayoutData_p = ctypes.c_void_p.in_dll(carbon, <span class="string">'kTISPropertyInputSourceIsEnabled'</span>)</span><br><span class="line">kTISPropertyInputSourceLanguages_p = ctypes.c_void_p.in_dll(carbon, <span class="string">'kTISPropertyInputSourceLanguages'</span>)</span><br><span class="line">kTISPropertyInputSourceType_p = ctypes.c_void_p.in_dll(carbon, <span class="string">'kTISPropertyInputSourceType'</span>)</span><br><span class="line">kTISPropertyLocalizedName_p = ctypes.c_void_p.in_dll(carbon, <span class="string">'kTISPropertyLocalizedName'</span>)</span><br><span class="line"><span class="comment"># kTISPropertyInputSourceLanguages_p = ctypes.c_void_p.in_dll(carbon, 'kTISPropertyInputSourceLanguages')</span></span><br><span class="line"></span><br><span class="line">kTISPropertyInputSourceCategory = objc_object(ctypes.c_void_p.in_dll(carbon, <span class="string">'kTISPropertyInputSourceCategory'</span>))</span><br><span class="line">kTISCategoryKeyboardInputSource = objc_object(ctypes.c_void_p.in_dll(carbon, <span class="string">'kTISCategoryKeyboardInputSource'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># TISCreateInputSourceList</span></span><br><span class="line">carbon.TISCreateInputSourceList.restype = ctypes.c_void_p</span><br><span class="line">carbon.TISCreateInputSourceList.argtypes = [ctypes.c_void_p, ctypes.c_bool]</span><br><span class="line"></span><br><span class="line">carbon.TISSelectInputSource.restype = ctypes.c_void_p</span><br><span class="line">carbon.TISSelectInputSource.argtypes = [ctypes.c_void_p]</span><br><span class="line"></span><br><span class="line">carbon.TISGetInputSourceProperty.argtypes = [ctypes.c_void_p, ctypes.c_void_p]</span><br><span class="line">carbon.TISGetInputSourceProperty.restype = ctypes.c_void_p</span><br><span class="line"></span><br><span class="line">carbon.TISCopyInputSourceForLanguage.argtypes = [ctypes.c_void_p]</span><br><span class="line">carbon.TISCopyInputSourceForLanguage.restype = ctypes.c_void_p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_avaliable_languages</span><span class="params">()</span>:</span></span><br><span class="line">    single_langs = filter(<span class="keyword">lambda</span> x: x.count() == <span class="number">1</span>, \</span><br><span class="line">        map(<span class="keyword">lambda</span> x: objc_object(carbon.TISGetInputSourceProperty(CoreFoundation.CFArrayGetValueAtIndex(objc_object(s), x).__c_void_p__(), kTISPropertyInputSourceLanguages_p)), \</span><br><span class="line">            range(CoreFoundation.CFArrayGetCount(objc_object(carbon.TISCreateInputSourceList(<span class="keyword">None</span>, <span class="number">0</span>))))))</span><br><span class="line">    res = set()</span><br><span class="line">    map(<span class="keyword">lambda</span> y: res.add(y[<span class="number">0</span>]), single_langs)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_kb</span><span class="params">(lang)</span>:</span></span><br><span class="line">    cur = carbon.TISCopyInputSourceForLanguage(CoreFoundation.CFSTR(lang).__c_void_p__())</span><br><span class="line">    carbon.TISSelectInputSource(cur)</span><br></pre></td></tr></table></figure>
<p>切换输入法主要是<code>TISSelectInputSource</code>方法，简单滴调用这个方法就可以了。使用<code>ctypes</code>包装这个方法有两个地方可以借鉴：</p>
<h3 id="pyobjc_转ctypes兼容类型">pyobjc 转ctypes兼容类型</h3><p>pyobjc提供的对象是不能直接传递给ctypes要包装的函数使用的，需要转换成可以识别的类型。每一个pyobjc提供的对象都有一个<code>__c_void_p__()</code>方法，对它调用这个方法就可以把这个对象转换成一个<code>c_void_p</code>类型</p>
<h3 id="ctypes指针构造出pyobjc对象">ctypes指针构造出pyobjc对象</h3><p>简单包装一下<code>objc</code>runtime里面的new方法，然后可以直接根据指针new一个对象出来。正如以上代码的<code>PyObjCObject_New</code>。（新版的pyobjc模块貌似已经包装了这个方法）</p>
<p>PS：本人第一次包装objc接口，对于objc以及pyobjc均不熟悉，可能有更优雅的方法，请批评指正。</p>
<h2 id="如何自动切换？">如何自动切换？</h2><p>要想实现输入法自动切换，自然是需要在某程序切换到前台的时候，帮它更改一下输入法的状态；如果知道一个程序是不是在前台呢？最笨的办法当然就是轮询，但是不够优雅。幸运的是，新的mac系统提供了这个回调。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span><span class="params">(NSObject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_</span><span class="params">(self, noti)</span>:</span></span><br><span class="line">        info = noti.userInfo().objectForKey_(NSWorkspaceApplicationKey)</span><br><span class="line">        bundleIdentifier = info.bundleIdentifier()</span><br><span class="line">        <span class="keyword">if</span> bundleIdentifier <span class="keyword">in</span> ignore_list:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"found: %s active"</span> % bundleIdentifier</span><br><span class="line">            select_kb(<span class="string">u'en'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    nc = NSWorkspace.sharedWorkspace().notificationCenter()</span><br><span class="line">    observer = Observer.new()</span><br><span class="line">    nc.addObserver_selector_name_object_(</span><br><span class="line">        observer,</span><br><span class="line">        <span class="string">"handle:"</span>,</span><br><span class="line">        NSWorkspaceDidActivateApplicationNotification,</span><br><span class="line">        <span class="keyword">None</span></span><br><span class="line">    )</span><br><span class="line">    AppHelper.runConsoleEventLoop(installInterrupt=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>这一段代码可以拿到最前台运行的application，而且是回调通知。有两个地方需要注意：</p>
<ol>
<li>Observer对象需要先new出来，（我直接在函数参数里面调用，直接就是segement fault，不知道原因）不能使用python的构造对象方式。需要调用new方法。</li>
<li>需要使用AppHelper.runConsoleEventLoop 才能接收到事件，至于为什么见<a href="http://stackoverflow.com/questions/8348627/what-is-the-correct-way-to-identify-the-currently-active-application-in-osx-10" target="_blank" rel="external">参考</a>。</li>
</ol>
<h2 id="成果">成果</h2><p>好了，把上面两段代码整合起来；就能实现每次在打开某些程序的时候，自动切换到某个输入法了！完整的代码见<a href="https://gist.github.com/tiann/f85e89bef4b6e9b83f2a" target="_blank" rel="external">auto_switch_kb.py</a></p>
<p>每次我切换到<code>IDEA</code>敲代码，输入法状态永远都是英文；就算我切换到其他回个邮件，发个消息切换到了中文，再次回来依然是英文；我手动切换到了中文被打断了去做了别的事情，再次回来，依然是英文状态。我永远都知道自己处于什么输入模式，如果不满足条件，<code>cmd + space</code> 切换即可。</p>
<p>最后，你可以使用<code>supervisor</code>之类的东西把它加入开机自动运行，这样，困惑已久的输入法问题终于得到解决。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>长久以来，输入法一直是困扰mac用户的一个问题；不过随着国内厂商的跟进，这种状况得到了极大的改善。不用自己去折腾什么<strong>鼠须管</strong>了，狼厂和企鹅都做的不错。</p>
<p>不过依然有一个问题没有完全解决：不同程序之间输入的自动切换。</p>
<p>相信大家一定有切换到<code>item2</code>输入两个命令发现是中文然后按<code>cmd + space</code>切换的尴尬；另外如果你如果使用vi或者emacs，那么就更蛋疼了。造成这种状况的根本原因在于：<strong>输入法的状态是混乱的</strong>，我无法明白现在自己处于哪一种输入环境，除非我开始打字或者看右上角输入法的图标。我希望<code>item2</code>,<code>Intellij IDEA</code>,<code>Alfred2</code><strong>永远</strong>是英文输入状态，除非手动切换；其他的程序比如chrome浏览器，邮件客户端保持正常。</p>
<p>打个比方，使用<code>sublime</code>写代码，大多数情况下肯定是英文输入状态，写注释的时候可能手动切换到中文；但是这里有个问题，这时候如果我切换到其他程序，然后改变了输入的状态，再次回到<code>sublime</code>，fuck!怎么又成了中文!</p>
<p>目前解决方案有如下方式：</p>
<ol>
<li>mac系统自带的设置-&gt; 键盘 -&gt; 输入源 -&gt; 自动使用文稿的输入源</li>
<li>一些输入法的类似<em>安静模式</em>的功能</li>
</ol>]]>
    
    </summary>
    
      <category term="mac" scheme="http://weishu.me/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[获取迅雷会员工作流]]></title>
    <link href="http://weishu.me/2015/11/18/xunlei-vip-account-workflow/"/>
    <id>http://weishu.me/2015/11/18/xunlei-vip-account-workflow/</id>
    <published>2015-11-18T06:59:44.000Z</published>
    <updated>2015-12-10T06:37:02.000Z</updated>
    <content type="html"><![CDATA[<p>mac下的P2P下载工具目前只有迅雷了，可是大家都知道mac下只有“会员迅雷”才能下载，没会员就是个废物。对于冷门资源离线下载还是是非常非常有用的，高速下载对速度提升也是显而易见。</p>
<p>想必都不会为了临时下载一个资源去开一个会员，肯定有过上网搜迅雷会员的经历；这里教大家如何把这个过程变成一个自动化的工作。<strong>如果长期使用迅雷的话，建议还是开会员去；本教程仅供学习使用，用完请于24小时之内删除</strong></p>
<p>先看看效果：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdownxunleivip.gif" alt="效果图" width="721"></p>
<a id="more"></a>
<h2 id="获取免费迅雷账号的地址">获取免费迅雷账号的地址</h2><p>随便百度一下，就能找到一堆免费迅雷会员分享的地址，具体就不指出了；然后把每天最新的账号分享信息抓取出来。</p>
<p>这里使用python，可以用<code>pyquery</code>来解析网页，然后一个正则匹配就拿到了结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, urllib, re</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">from</span> workflow <span class="keyword">import</span> Workflow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_url = <span class="string">'http://www.xunleihuiyuan.net/'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(wf)</span>:</span></span><br><span class="line">    args = wf.args</span><br><span class="line"></span><br><span class="line">    results = _get_from_web()</span><br><span class="line">    map(<span class="keyword">lambda</span> (x,y):wf.add_item(<span class="string">u'账号:%s'</span> % x, <span class="string">u'密码:%s'</span> % y, arg=<span class="string">u'%s %s'</span> %(x,y), valid=<span class="keyword">True</span>), results)</span><br><span class="line">    wf.send_feedback()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_today_url</span><span class="params">()</span>:</span></span><br><span class="line">    home = urllib.urlopen(_url).read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> pq(home)(<span class="string">'.cate1 .post-title a'</span>)[<span class="number">0</span>].get(<span class="string">'href'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_from_web</span><span class="params">()</span>:</span></span><br><span class="line">    page = urllib.urlopen(_get_today_url()).read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    results = r = pq(page)(<span class="string">'.formattext div'</span>).text()</span><br><span class="line">    <span class="keyword">return</span> re.findall(<span class="string">ur'\u8d26\u53f7(\S+)\u5bc6(\w+)'</span>, results)</span><br></pre></td></tr></table></figure></p>
<h2 id="用Alfred_workflow展示出来">用Alfred workflow展示出来</h2><p>使用python的alfred workflow sdk的话非常简单，文档在<a href="http://alfredworkflow.readthedocs.org/en/develop/index.html" target="_blank" rel="external">这里</a></p>
<p>这里要处理的一个问题是，账号和密码如何简单滴传递出来；一起放在剪切版肯定不太合适。幸好alfred自带剪切版历史的功能，我们分别两次把账号和密码复制到剪切版，要使用的时候，激活<code>cmd + option + c</code>然后从剪切版历史里面选择账号密码即可：效果如下：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1447827801109.png" width="514" alt="alfred历史剪切版功能"><br>然后，按下<code>cmd + 2</code>得到账号，<code>cmd + 3</code>得到密码！具体代码比较简单：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import subprocess,<span class="tag">time</span></span><br><span class="line">query = <span class="string">"&#123;query&#125;"</span></span><br><span class="line">def <span class="function"><span class="title">copy_osx</span><span class="params">(text)</span></span>:</span><br><span class="line">        <span class="tag">p</span> = subprocess.<span class="function"><span class="title">Popen</span><span class="params">([<span class="string">'pbcopy'</span>, <span class="string">'w'</span>], stdin=subprocess.PIPE, close_fds=True)</span></span></span><br><span class="line">        <span class="tag">p</span>.<span class="function"><span class="title">communicate</span><span class="params">(input=text.encode(<span class="string">'utf-8'</span>)</span></span>)</span><br><span class="line">account, pwd = query.<span class="function"><span class="title">split</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">copy_osx</span><span class="params">(account)</span></span></span><br><span class="line"><span class="tag">time</span>.<span class="function"><span class="title">sleep</span><span class="params">(<span class="number">0.3</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">copy_osx</span><span class="params">(pwd)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样，一个简单的迅雷会员获取工作流就完成了！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>mac下的P2P下载工具目前只有迅雷了，可是大家都知道mac下只有“会员迅雷”才能下载，没会员就是个废物。对于冷门资源离线下载还是是非常非常有用的，高速下载对速度提升也是显而易见。</p>
<p>想必都不会为了临时下载一个资源去开一个会员，肯定有过上网搜迅雷会员的经历；这里教大家如何把这个过程变成一个自动化的工作。<strong>如果长期使用迅雷的话，建议还是开会员去；本教程仅供学习使用，用完请于24小时之内删除</strong></p>
<p>先看看效果：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdownxunleivip.gif" alt='效果图' width="721" /></p>]]>
    
    </summary>
    
      <category term="alfred workflow" scheme="http://weishu.me/tags/alfred-workflow/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java高效分割字符串]]></title>
    <link href="http://weishu.me/2015/11/10/fast-split-in-android/"/>
    <id>http://weishu.me/2015/11/10/fast-split-in-android/</id>
    <published>2015-11-10T10:52:34.000Z</published>
    <updated>2015-11-11T02:19:52.000Z</updated>
    <content type="html"><![CDATA[<p>最近优化一段代码的调用时间，发现性能瓶颈居然是io和split！io操作慢情有可原，那么对于split有没有更高效的方法呢？</p>
<h2 id="一般方法">一般方法</h2><p>再java里面，一般的split 字符串解决方案有三种：</p>
<ol>
<li>直接用split函数</li>
<li>使用StingTokenizer类</li>
<li>用<code>indexOf,subString</code>实现；</li>
</ol>
<p>在JDK6的实现中，String类的split直接使用了正则表达式；不得不说，真是杀鸡焉用牛刀。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">        <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Android VM(Android 4.0以上系统源码如此)里面，对这个方法做了一定的优化：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regularExpression, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">       String[] result = java.util.regex.Splitter.fastSplit(regularExpression, <span class="keyword">this</span>, limit);</span><br><span class="line">       <span class="keyword">return</span> result != <span class="keyword">null</span> ? result : Pattern.compile(regularExpression).split(<span class="keyword">this</span>, limit);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用正则的话，效率肯定是有问题的；具体我们看一看就知道了。<code>StringTokenizer</code>是一个流式解析类，虽然JDK已经deprecated很久了，但是还是无法阻止大量的开源库使用这个类，效果自然得到了广泛的认可；另外呢，对于简单的分隔符，比如空格，单个字符等，可以直接使用<code>indexOf</code>得到索引，然后用<code>subString</code>得到字串；在这种情况下，理论上效率比上述两种高出很多；首先<code>indexOf</code>这个查找操作肯定是<code>o(logn)</code>，然后，求字串最多也是线性操作。具体效率如何，测试一下就知道了。</p>
<h2 id="测试">测试</h2><p>我们选择的测试字符串对象，是<code>ps</code>得到的输出，然后，写一个测试类，然后在Android下面运行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSplitter</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String line =</span><br><span class="line">            <span class="string">"root      1     0     572    436   c014bbc4 00011304 S /init"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNS = <span class="number">1000000</span>;<span class="comment">// 000000;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COLUMNS = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] splitBySplit() &#123;</span><br><span class="line">        <span class="keyword">return</span> line.split(<span class="string">"\\s+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">splitByIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; l = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] lp = getPsLinePos(line);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">1</span>; i1 &lt; COLUMNS - <span class="number">1</span>; i1++) &#123;</span><br><span class="line">            l.add(line.substring(lp[i1 - <span class="number">1</span>], lp[i1]));</span><br><span class="line">        &#125;</span><br><span class="line">        l.add(line.substring(lp[COLUMNS - <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] sPos;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">splitByIndex2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; l = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sPos == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sPos = getPsLinePos(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">1</span>; i1 &lt; COLUMNS - <span class="number">1</span>; i1++) &#123;</span><br><span class="line">            l.add(line.substring(sPos[i1 - <span class="number">1</span>], sPos[i1]));</span><br><span class="line">        &#125;</span><br><span class="line">        l.add(line.substring(sPos[COLUMNS - <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPsLinePos(String line) &#123;</span><br><span class="line">        <span class="comment">// 以下是为了得到每一列的pos;不在循环里面判空,节省调用</span></span><br><span class="line">        <span class="keyword">int</span>[] lp = <span class="keyword">new</span> <span class="keyword">int</span>[COLUMNS];</span><br><span class="line">        lp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一个起点是开始</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> lastChar;</span><br><span class="line">        <span class="keyword">char</span> curChar;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = line.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            lastChar = line.charAt(j - <span class="number">1</span>);</span><br><span class="line">            curChar = line.charAt(j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index + <span class="number">1</span> &gt;= COLUMNS) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lastChar == <span class="string">' '</span> &amp;&amp; curChar != <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是从空格突变为非空格,那么就是起始点</span></span><br><span class="line">                lp[++index] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">splitByTokenizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; l = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">16</span>);</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(line);</span><br><span class="line">        <span class="keyword">while</span> (st.hasMoreTokens()) &#123;</span><br><span class="line">            l.add(st.nextToken());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Test test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RUNS; i++) &#123;</span><br><span class="line">            test.run();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s use time: %s(ms)"</span>, test.tag, System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Test split = <span class="keyword">new</span> Test(<span class="string">"Split"</span>) &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                splitBySplit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Test string = <span class="keyword">new</span> Test(<span class="string">"StringTokenizer"</span>) &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                splitByTokenizer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Test index = <span class="keyword">new</span> Test(<span class="string">"indexOf"</span>) &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                splitByIndex();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Test index2 = <span class="keyword">new</span> Test(<span class="string">"indexOf2"</span>) &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                splitByIndex2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        test(split);</span><br><span class="line">        test(string);</span><br><span class="line">        test(index);</span><br><span class="line">        test(index2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String tag;</span><br><span class="line"></span><br><span class="line">        Test(String tag) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tag = tag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="结果">结果</h2><p>代码有点长，能用lambda就简洁了，这时后话；看一看性能表现如何（以下使用的是Htc x920e 4.4.2系统测试的）：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I/System.out﹕ Split <span class="operator"><span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">2267</span>(ms)</span><br><span class="line"><span class="keyword">I</span>/<span class="keyword">System</span>.<span class="keyword">out</span>﹕ StringTokenizer <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">326</span>(ms)</span><br><span class="line"><span class="keyword">I</span>/<span class="keyword">System</span>.<span class="keyword">out</span>﹕ indexOf <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">218</span>(ms)</span><br><span class="line"><span class="keyword">I</span>/<span class="keyword">System</span>.<span class="keyword">out</span>﹕ indexOf2 <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">157</span>(ms)</span></span><br></pre></td></tr></table></figure></p>
<p>这下体会到split有多么慢了吧！<code>StringTokenizer</code>与<code>indexOf</code>时间在一个数量级，优化后的indexOf稍微好点，大致快一倍。</p>
<h2 id="结论">结论</h2><ol>
<li>在split需要被大量调用的场合，在现有的Android VM里面，<code>String</code>类的<code>split</code>方法<strong>肯定是不符合要求的</strong></li>
<li><code>StringTokenizer</code>是最廉价的替换split的方法，简单修改成这个实现之后，花费时间能提升一个数量级；</li>
<li><code>indexOf</code>结合<code>subString</code>经过充分的优化，对于<strong>结构化</strong>特别是<strong>表格类</strong>的数据，效率是最快的，对于特定场合，可以考虑使用这种方法，速度大致提升一倍。</li>
</ol>
<h2 id="题外话">题外话</h2><h3 id="JDK8">JDK8</h3><p>自己的mac上面装的是jdk8，我看了一下String在上面的实现，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">        <span class="comment">/* fastpath if the regex is a</span><br><span class="line">         (1)one-char String and this character is not one of the</span><br><span class="line">            RegEx's meta characters ".$|()[&#123;^?*+\\", or</span><br><span class="line">         (2)two-char String and the first char is the backslash and</span><br><span class="line">            the second is not the ascii digit or ascii letter.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (((regex.value.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">             <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</span><br><span class="line">             (regex.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">              regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</span><br><span class="line">              (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">              ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">              ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">            (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">             ch &gt; Character.MAX_LOW_SURROGATE))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">            boolean limited = limit &gt; <span class="number">0</span>;</span><br><span class="line">            ArrayList&lt;String&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> ((next = indexOf(ch, off)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!limited || <span class="built_in">list</span>.size() &lt; limit - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">list</span>.add(substring(off, next));</span><br><span class="line">                    off = next + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">// last one</span></span><br><span class="line">                    <span class="comment">//assert (list.size() == limit - 1);</span></span><br><span class="line">                    <span class="built_in">list</span>.add(substring(off, value.length));</span><br><span class="line">                    off = value.length;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If no match was found, return this</span></span><br><span class="line">            <span class="keyword">if</span> (off == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add remaining segment</span></span><br><span class="line">            <span class="keyword">if</span> (!limited || <span class="built_in">list</span>.size() &lt; limit)</span><br><span class="line">                <span class="built_in">list</span>.add(substring(off, value.length));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Construct result</span></span><br><span class="line">            <span class="keyword">int</span> resultSize = <span class="built_in">list</span>.size();</span><br><span class="line">            <span class="keyword">if</span> (limit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">list</span>.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    resultSize--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] result = <span class="keyword">new</span> String[resultSize];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>.subList(<span class="number">0</span>, resultSize).toArray(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的实现可以看到：<strong>对于单个字符或者两个字符（后面限制条件不翻译了）作为分割的时候，JDK对它进行了优化！</strong>，看一看在JDK8上面的结论：（需要把那个正则替换成空格）<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Split <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">43</span>(ms)</span><br><span class="line">StringTokenizer <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">15</span>(ms)</span><br><span class="line">indexOf <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">14</span>(ms)</span><br><span class="line">indexOf2 <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">7</span>(ms)</span><br></pre></td></tr></table></figure></p>
<p>效果惊人！！硬生生拉到了一个数量级！所以说，<strong>没事升级下JDK还是很有必要的，免费的午餐不过如此</strong>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近优化一段代码的调用时间，发现性能瓶颈居然是io和split！io操作慢情有可原，那么对于split有没有更高效的方法呢？</p>
<h2 id="一般方法">一般方法</h2><p>再java里面，一般的split 字符串解决方案有三种：</p>
<ol>
<li>直接用split函数</li>
<li>使用StingTokenizer类</li>
<li>用<code>indexOf,subString</code>实现；</li>
</ol>
<p>在JDK6的实现中，String类的split直接使用了正则表达式；不得不说，真是杀鸡焉用牛刀。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">        <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Android VM(Android 4.0以上系统源码如此)里面，对这个方法做了一定的优化：<br>]]>
    
    </summary>
    
      <category term="split" scheme="http://weishu.me/tags/split/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何安全地打印日志]]></title>
    <link href="http://weishu.me/2015/10/19/how-to-log-safely-in-android/"/>
    <id>http://weishu.me/2015/10/19/how-to-log-safely-in-android/</id>
    <published>2015-10-19T12:28:02.000Z</published>
    <updated>2015-12-10T06:42:17.000Z</updated>
    <content type="html"><![CDATA[<p>如何打印日志？这不是很简单，直接使用<code>android.util.Log</code>这个类不就行了？然而，日志属于非常敏感的信息；逆向工程师在逆向你的程序的时候，本来需要捕捉你程序的各种输出，然后进行推测，顺藤摸瓜然后得到需要的信息；一旦你的日志泄漏，无异于门户洞开，破解你的程序如入无人之境。<br>安全的概念本来就是相对的，如果破解你程序的代价远远大于破解得到的价值，那么就可以认为程序是“安全的”；这里就分析一下，为了提高程序的安全性，在打印日志的时候应该注意什么。</p>
<a id="more"></a>
<p>首先看看绝大部分公司以及开发者的做法：</p>
<h2 id="日志开关＋日志类">日志开关＋日志类</h2><p>为了在release版本里面没有日志输出，一个最简单的想法是：把所有打印日志的语句放在一个<code>if(DEBUG)</code>的语句里面；在日常开发的时候，<code>DEBUG</code>开关打开，发布正式版本的时候关闭这个开关即可，大致思路如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LogUtil.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;<span class="comment">// 发布的时候修改为false</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(String tag, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) android.util.Log.d(TAG, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他debug方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看一个真实的例子，国外的一个apk，名字叫做powerclean；包名：com.lionmobi.powerclean;我们安装这个包；发现很正常，没有任何日志输出；然后我们逆向这个apk；随便翻看几个类，发现很多地方有类似日志输出：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/1445243591752.png" width="552" alt="日志输出图片"><br>我们打开这个叫做x的类，虽然被混淆过了，但是意思很明白，跟我们上面的思路一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lionmobi.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">x</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        x.a = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(String arg1, String arg2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.a) &#123;</span><br><span class="line">            Log.d(arg1, arg2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">e</span><span class="params">(String arg1, String arg2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.a) &#123;</span><br><span class="line">            Log.e(arg1, arg2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">(String arg1, String arg2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.a) &#123;</span><br><span class="line">            Log.i(arg1, arg2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个真实的例子，而且这个app的用户还不少；接下来我们看看这种方式有什么问题。</p>
<h2 id="静态反编译打开日志开关">静态反编译打开日志开关</h2><p>上面的那种方式有一个问题：虽然在release版本里面，确实没有日志输出；但是<strong>输出日志的代码依然存在，只是没有执行到！(if条件不成立)</strong>所以，有没有办法让这些代码执行到呢？简单来说，就是能不能在release版本里面把这个<code>DEBUG</code>变量弄成<code>true</code>呢？当然可以！而且做法还非常简单。</p>
<p>我们使用<code>apktool</code>反编译得到这个apk的smali代码；然后上面的反编译告诉我们，这个日志类的位置是：<code>com.lionmobi.util.x</code>我们打开这个x.smali文件，内容如下：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.class</span><span class="keyword"> public</span> <span class="class">Lcom/lionmobi/util/x;</span></span><br><span class="line"><span class="keyword">.super</span> <span class="class">Ljava/lang/Object;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># static fields</span></span><br><span class="line"><span class="keyword">.field</span><span class="keyword"> private</span><span class="keyword"> static</span> a:Z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># direct methods</span></span><br><span class="line"><span class="keyword">.method</span><span class="keyword"> static</span><span class="keyword"> constructor</span><span class="function"> &lt;clinit&gt;(</span><span class="function">)</span>V</span><br><span class="line"><span class="keyword">    .locals</span> 1</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const/4 </span><span class="variable">v0</span>, 0x0 <span class="comment"># 修改为0x1 (True)</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> sput-boolean </span><span class="variable">v0</span>, <span class="class">Lcom/lionmobi/util/x;</span>-&gt;a:Z <span class="comment">#初始化位置</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> return-void</span><br><span class="line"></span><span class="keyword">.end method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span><span class="function"> d(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"><span class="keyword">    .locals</span> 1</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> sget-boolean </span><span class="variable">v0</span>, <span class="class">Lcom/lionmobi/util/x;</span>-&gt;a:Z</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> if-eqz </span><span class="variable">v0</span>,<span class="keyword"> :cond_0</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">p0</span>, <span class="variable">p1</span>&#125;, <span class="class">Landroid/util/Log;</span><span class="function">-&gt;d(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>I</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> :cond_0</span></span><br><span class="line">   <span class="instruction"> return-void</span><br><span class="line"></span><span class="keyword">.end method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span><span class="function"> e(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"><span class="keyword">    .locals</span> 1</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> sget-boolean </span><span class="variable">v0</span>, <span class="class">Lcom/lionmobi/util/x;</span>-&gt;a:Z</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> if-eqz </span><span class="variable">v0</span>,<span class="keyword"> :cond_0</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">p0</span>, <span class="variable">p1</span>&#125;, <span class="class">Landroid/util/Log;</span><span class="function">-&gt;e(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>I</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> :cond_0</span></span><br><span class="line">   <span class="instruction"> return-void</span><br><span class="line"></span><span class="keyword">.end method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span><span class="function"> i(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"><span class="keyword">    .locals</span> 1</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> sget-boolean </span><span class="variable">v0</span>, <span class="class">Lcom/lionmobi/util/x;</span>-&gt;a:Z</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> if-eqz </span><span class="variable">v0</span>,<span class="keyword"> :cond_0</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">p0</span>, <span class="variable">p1</span>&#125;, <span class="class">Landroid/util/Log;</span><span class="function">-&gt;i(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>I</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> :cond_0</span></span><br><span class="line">   <span class="instruction"> return-void</span><br><span class="line"></span><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure></p>
<p>很明白，那个叫做<code>a</code>的静态变量就是我们的开关， 它的初始化在哪个静态代码块里面；新建了一个局部变量0x0然后赋值给了<code>a</code>；因此，我们<strong>把这个0x0修改为0x1</strong>就打开了这个开关。很简单吧，接下来我们把修改好的smali打包回去，然后签名得到一个新的可以运行的apk；运行一下看看结果。果然，一大堆的日志输出了出来，你的程序每一步在干什么都自己告诉别人了，都不需要去猜；我就随便截个图，感受下：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/1445245047558.png" width="1235" alt="泄漏的日志信息"></p>
<h2 id="让release版本里面不包含日志代码">让release版本里面不包含日志代码</h2><p>从上面的分析我们得到一个结论：<strong>如果需要程序是“日志安全的”，那么release版本里面不应该存在输出日志的代码</strong>。</p>
<p>如何做到这一点呢？我们可以做一个工具，开发的时候，正常打印日志；一旦需要发布版本，把所有打印日志的语句代码，全部删除掉。代码很简单，用一些正则表达式就可以做到。</p>
<p>事实上，我们也可以使用一些别的工具，来实现这个类似的功能；那就是<code>proguard</code>；提到这个工具，很多认只是觉得他是一个代码混淆的工具，实际上，<strong>它还可以帮你剔除无用代码！</strong>什么样的代码是无用代码呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// statement;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似于这样，静态编译的时候被认为“永远不会执行的代码”，就被认为是无用代码，会被这个工具直接优化掉，生成的class文件里面，这个if语句直接就没有了。这个功能，完美符合我们的需求；我们只需要把输出日志的代码用这样的if语句包围起来，然后release的时候肯定会用这个工具混淆；然后，在release版本里面，所有的输出日志的代码全部都没有了！不会像以前一样，留下一个影子，只是不做事。</p>
<h2 id="正确的做法">正确的做法</h2><p>最终，我们所有打印日志的语句应该如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>; <span class="comment">// 必须是static final 也就是常量，这样才能在编译器优化；删除if块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">    android.util.Log.d(TAG, <span class="string">"msg to print"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，使用proguard优化代码即可。<br>看起来简单，好像也与最初的“日志开关”没有什么区别，仔细分析一下：</p>
<h3 id="日志开关必须是静态常量">日志开关必须是静态常量</h3><p>对比一下正确的做法与最开始的日志开关，一个是一个<strong>静态变量</strong>，一个是<strong>静态常量</strong>；如果是<strong>常量</strong>的话，那么就是永远不变的，那么当<code>DEBUG</code>变量为<code>False</code>的时候proguard可以理所当然地认为，这一部分代码时绝对不会被执行的，这样，打印日志的语句就会被优化（删除）掉；如果是一个变量，那么在运行期间就有可能改变它的值（private仅仅是对于程序员的改变，对于编译器以及运行时，没有什么改不了），这样proguard就会置之不理，这样你的日志代码就暴露出来了，一字之差，失之千里。</p>
<h3 id="抛弃日志类">抛弃日志类</h3><p>假设我们使用了静态常量代码块以及proguard优化代码的技术；但是依然采用上面的日志类的技术，会发生什么呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(String tag, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) android.util.Log.d(tag, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我写了一个demo，自己打包然后反编译，得到这个日志类如下（为了方便看，没有混淆）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(String tag, String msg)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到，if代码块已经没有了，确实不会输出任何日志；但是，我们看看调用这个类的地方！<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/1445247504072.png" width="575" alt="掩耳盗铃的日志"></p>
<p>这个<code>LogUtil.d</code>的调用，无异于掩耳盗铃；虽然破解者没办法让<code>android.util.Log</code>这个类输出任何日志，但是你这里的这个调用还是告诉了别人你在干什么；所以，要屏蔽日志的输出，必须使用if代码块直接包含要被剔除的日志。上面的那个日志类，要被优化掉，那就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">    LogUtil.d(TAG, <span class="string">"msg"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，不是多此一举吗，写一个日志类就是想不想重复地写<code>if (DEBUG)</code>，这里为了使这一句隐藏，还是逃不掉；但是很抱歉，逃得了和尚逃不了庙，这种方法没办法做到完全隐藏信息；<strong>必须抛弃日志类包裹日志代码的做法！</strong></p>
<h3 id="解放双手的补充">解放双手的补充</h3><p>也许有人说，为了这个所谓的日志安全，每次输出日志都的写一个if语句，那不麻烦死；简直反人类，我懒！实际上，要少写几行代码，我们可以选择复用（代码级别，比如上面的日志类），也可以选择<strong>生成</strong>（直接生成代码）；在支持元编程的语言里面，生成代码是很常见的事情，比如C＋＋的模版元编程以及ruby吹嘘的<code>DSL</code>能力；这里没有那么高大上，用代码生成代码，我们直接借助编辑器帮助我们少写几行代码万事。</p>
<h4 id="IDEA/Android_Studio">IDEA/Android Studio</h4><p>可以使用live template的功能；比如我的做法是，写一个<code>ifd</code>的template，每次我输入<code>ifd</code>然后自动展开成if语句，光标停在最中间：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown1445258458.gif" width="402" alt="使用live template简化输入"></p>
<h4 id="vim/emacs">vim/emacs</h4><p>可以使用宏录制的功能，实现上面的live template。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如何打印日志？这不是很简单，直接使用<code>android.util.Log</code>这个类不就行了？然而，日志属于非常敏感的信息；逆向工程师在逆向你的程序的时候，本来需要捕捉你程序的各种输出，然后进行推测，顺藤摸瓜然后得到需要的信息；一旦你的日志泄漏，无异于门户洞开，破解你的程序如入无人之境。<br>安全的概念本来就是相对的，如果破解你程序的代价远远大于破解得到的价值，那么就可以认为程序是“安全的”；这里就分析一下，为了提高程序的安全性，在打印日志的时候应该注意什么。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="log" scheme="http://weishu.me/tags/log/"/>
    
  </entry>
  
</feed>
