<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Weishu's Notes]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://weishu.me/"/>
  <updated>2017-11-22T17:38:48.000Z</updated>
  <id>http://weishu.me/</id>
  
  <author>
    <name><![CDATA[weishu]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[我为Dexposed续一秒——论ART上运行时 Method AOP实现]]></title>
    <link href="http://weishu.me/2017/11/23/dexposed-on-art/"/>
    <id>http://weishu.me/2017/11/23/dexposed-on-art/</id>
    <published>2017-11-22T17:30:10.000Z</published>
    <updated>2017-11-22T17:38:48.000Z</updated>
    <content type="html"><![CDATA[<p>两年前阿里开源了<a href="https://github.com/alibaba/dexposed" target="_blank" rel="external">Dexposed</a> 项目，它能够在Dalvik上无侵入地实现运行时方法拦截，正如其介绍「enable ‘god’ mode for single android application」所言，能在非root情况下掌控自己进程空间内的任意Java方法调用，给我们带来了很大的想象空间。比如能实现运行时AOP，在线热修复，做性能分析工具（拦截线程、IO等资源的创建和销毁）等等。然而，随着ART取代Dalvik成为Android的运行时，一切都似乎戛然而止。</p>
<p>今天，我在ART上重新实现了Dexposed，在它能支持的平台（Android 5.0 ~ 7.1 Thumb2/ARM64)上，有着与Dexposed完全相同的能力和API；项目地址在这里 <a href="https://github.com/tiann/epic" target="_blank" rel="external">epic</a>，感兴趣的可以先试用下:) 然后我们聊一聊ART上运行时Method AOP的故事。</p>
<a id="more"></a>
<h2 id="ART有什么特别的？">ART有什么特别的？</h2><p>为什么Dexposed能够在Dalvik上为所欲为，到ART时代就不行了呢？排除其他非技术因素来讲，ART确实比Dalvik复杂太多；更要命的是，从Android L到Android O，每一个Android版本中的ART变化都是天翻地覆的，大致列举一下：</p>
<ul>
<li>Android L(5.0/5.1) 上的ART是在Dalvik上的JIT编译器魔改过来的，名为quick（虽然有个portable编译器，但是从未启用过）；这个编译器会做一定程度的方法内联，因此很多基于入口替换的Hook方式一上来就跪了。</li>
<li>Android M(6.0) 上的ART编译器完全重新实现了：Optimizing。且不说之前在Android L上的Hook实现要在M上重新做一遍，这个编译器的寄存器分配比quick好太多，结果就是hook实现的时候你要是乱在栈或者寄存器上放东西，代码很容易就跑飞。 </li>
<li>Android N(7.0/7.1) N 开始采用了混合编译的方式，既有AOT也有JIT，还伴随着解释执行；混合模式对Hook影响是巨大的，以至于<a href="https://www.xda-developers.com/official-xposed-framework-android-nougat/" target="_blank" rel="external">Xposed直到今年才正式支持Android N</a>。首先JIT的出现导致方法入口不固定，跑着跑着入口就变了，更麻烦的是还会有OSR（栈上替换），不仅入口变了，正在运行时方法的汇编代码都可能发生变化；其次，JIT的引入带来了更深度的运行时方法内联，这些都使得虚拟机层面的Hook更为复杂。</li>
<li>Android O(8.0) Android O的Runtime做了很多优化，传统Java VM有的一些优化手段都已经实现，比如类层次分析，循环优化，向量化等；除此之外，DexCache被删除，跨dex方法内联以及Concurrent compacting GC的引入，使得Hook技术变的扑朔迷离。</li>
</ul>
<p>可以看出，ART不仅复杂，而且还爱折腾；一言不合就魔改，甚至重写。再加上Android的碎片化，这使得实现一个稳定的虚拟机层面上运行时Java Method AOP几无可能。</p>
<p>说到这里也许你会问，那substrate，frida等hook机制不是挺成熟了吗？跟这里说的ART Hook有什么联系与区别？事实上，substrate/frida 主要处理native层面的Hook，可以实现任意C/C++ 函数甚至地址处的调用拦截；而ART Java Method Hook/AOP 更多地是在虚拟机层面，用来Hook和拦截Java方法，虚拟机层面的Hook底层会使用于substrate等类似的Hook技术，但是还要处理虚拟机独有的特点，如GC/JNI/JIT等。</p>
<h2 id="已有的一些方案">已有的一些方案</h2><p>虽然ART上的运行时Java Method AOP实现较为困难，但还是有很多先驱者和探索者。最有名的莫过于AndFix（虽然它不能实现AOP）；在学术界，还有两篇研究ART Hook的论文，一篇实现了Callee side dynamic rewrite，另一篇基于虚函数调用原理实现了vtable hook。另外，除了在讲epic之前，我们先看看这些已有的方案。</p>
<p>首先简单介绍下ART上的方法调用原理（本文不讨论解释模式，所有entrypoint均指compiled_code_entry_point)。在ART中，每一个Java方法在虚拟机（注：ART与虚拟机虽有细微差别，但本文不作区分，两者含义相同，下同）内部都由一个ArtMethod对象表示（native层，实际上是一个C++对象），这个native 的 ArtMethod对象包含了此Java方法的所有信息，比如名字，参数类型，方法本身代码的入口地址（entrypoint)等；暂时放下trampoline以及interpreter和jit不谈，一个Java方法的执行非常简单：</p>
<ol>
<li>想办法拿到这个Java方法所代表的ArtMethod对象</li>
<li>取出其entrypoint，然后跳转到此处开始执行</li>
</ol>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201605/1511369316918.png" alt=""></p>
<h3 id="entrypoint_replacement">entrypoint replacement</h3><p>从上面讲述的ART方法调用原理可以得到一种很自然的Hook办法————直接替换entrypoint。通过把原方法对应的ArtMethod对象的entrypoint替换为目标方法的entrypoint，可以使得原方法被调用过程中取entrypoint的时候拿到的是目标方法的entry，进而直接跳转到目标方法的code段；从而达到Hook的目的。</p>
<p>AndFix就是基于这个原理来做热修复的，<a href="https://yq.aliyun.com/articles/74598?t=t1#" target="_blank" rel="external">Sophix</a> 对这个方案做了一些改进，也即整体替换，不过原理上都一样。二者在替换方法之后把原方法直接丢弃，因此无法实现AOP。<a href="https://github.com/panhongwei/AndroidMethodHook" target="_blank" rel="external">AndroidMethodHook</a> 基于Sophix的原理，用dexmaker动态生成类，将原方法保存下来，从而实现了AOP。</p>
<p>不过这种方案能够生效有一个前提：方法调用必须是先拿到ArtMethod，再去取entrypoint然后跳转实现调用。但是很多情况下，第一步是不必要的；系统知道你要调用的这个方法的entrypoint是什么，直接写死在汇编代码里，这样方法调用的时候就不会有取ArtMethod这个动作，从而不会去拿被替换的entrypoint，导致Hook失效。这种调用很典型的例子就是系统函数，我们看一下Android 5.0上 调用<code>TextView.setText(Charsequence)</code> 这个函数的汇编代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSetText</span><span class="params">(TextView textView)</span> </span>&#123;</span><br><span class="line">    textView.setText(<span class="string">"hehe"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OAT文件中的汇编代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00037e10: e92d40e0&#9;push    &#123;r5, r6, r7, lr&#125;&#10;0x00037e14: b088    &#9;sub     sp, sp, #32&#10;0x00037e16: 1c07    &#9;mov     r7, r0&#10;0x00037e18: 9000    &#9;str     r0, [sp, #0]&#10;0x00037e1a: 910d    &#9;str     r1, [sp, #52]&#10;0x00037e1c: 1c16    &#9;mov     r6, r2&#10;0x00037e1e: 6978    &#9;ldr     r0, [r7, #20]&#10;0x00037e20: f8d00ef0&#9;ldr.w   r0, [r0, #3824]&#10;0x00037e24: b198    &#9;cbz     r0, +38 (0x00037e4e)&#10;0x00037e26: 1c05    &#9;mov     r5, r0&#10;0x00037e28: f24a6e29&#9;movw    lr, #42537&#10;0x00037e2c: f2c73e87&#9;movt    lr, #29575&#10;0x00037e30: f24560b0&#9;movw    r0, #22192&#10;0x00037e34: f6c670b4&#9;movt    r0, #28596&#10;0x00037e38: 1c31    &#9;mov     r1, r6&#10;0x00037e3a: 1c2a    &#9;mov     r2, r5&#10;0x00037e3c: f8d1c000&#9;ldr.w   r12, [r1, #0]&#10;suspend point dex PC: 0x0002&#10;GC map objects:  v0 (r5), v1 ([sp + #52]), v2 (r6)&#10;0x00037e40: 47f0    &#9;blx     lr</span><br></pre></td></tr></table></figure>
<p>看这两句代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00037e28: f24a6e29&#9;movw    lr, #42537&#10;0x00037e2c: f2c73e87&#9;movt    lr, #29575</span><br></pre></td></tr></table></figure>
<p>什么意思呢？lr = 0x7387a629，然后接着就blx跳转过去了。事实上，这个地址 <code>0x7387a629</code> 就是TextView.setText(Charsequence)` 这个方法entrypoint的绝对地址；我们可以把系统编译好的oat代码弄出来看一看：</p>
<blockquote>
<p>adb shell oatdump –oat-file=/data/dalvik-cache/arm/system@framework@boot.oat</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">364</span>: <span class="keyword">void</span> android.widget.TextView.setText(java.lang.CharSequence) (dex_method_idx=<span class="number">28117</span>)</span><br><span class="line">  <span class="comment">// 略掉无关内容</span></span><br><span class="line">  QuickMethodFrameInfo</span><br><span class="line">    frame_size_in_bytes: <span class="number">48</span></span><br><span class="line">    core_spill_mask: <span class="number">0x000081e0</span> (r5, r6, r7, r8, r15)</span><br><span class="line">    fp_spill_mask: <span class="number">0x00000000</span></span><br><span class="line">  CODE: (code_offset=<span class="number">0x037d8629</span> size_offset=<span class="number">0x037d8624</span> size=<span class="number">64</span>).</span><br></pre></td></tr></table></figure>
<p>其中这个方法的code_offset = 0x037d8629; boot.oat的EXECUTABLE OFFSET 为0x02776000, boot.oat 在proc/<pid>/maps 中的基址如下：</pid></p>
<figure class="highlight"><figcaption><span>rw-p 00000000 103:1f 32773</span><a href="/data/dalvik-cache/arm/system@framework@boot.art">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">700a1000-72818000 r--p 00000000 103:1f 32772     /data/dalvik-cache/arm/system@framework@boot.oat&#10;72818000-74689000 r-xp 02777000 103:1f 32772     /data/dalvik-cache/arm/system@framework@boot.oat&#10;74689000-7468a000 rw-p 045e8000 103:1f 32772     /data/dalvik-cache/arm/system@framework@boot.oat</span><br></pre></td></tr></table></figure>
<p>其中 可执行段的地址为 0x72818000，因此算出来的 TextView.setText(CharSequence) 这个方法的地址为 <code>0x037d8629 - 0x02776000 + 0x72818000 = 0x7387a629</code>；丝毫不差。</p>
<p>为什么会这么干呢？因为boot.oat 这个文件在内存中的加载地址是固定的（如果发生变化，所有APP的oat文件会重新生成，于是又重新固定），因此里面的每一个函数的绝对地址也是固定的，如果你调用系统函数，ART编译器知道系统每一个函数入口的绝对地址，根本没有必要再去查找方法，因此生成的代码中没有任何查找过程。</p>
<p>所以，从原理上讲，如果要支持系统方法的Hook，这种方案在很多情况下是行不通的。当然如果你Hook自己App的代码，并且调用方和被调用方在不同的dex，在Android O之前是没什么问题的（在Android O之前跨dex一定会走方法查找）。</p>
<p>从上面的分析可以看出，就算不查找ArtMethod，这个ArtMethod的enntrypoint所指向代码是一定要用到的（废话，不然CPU执行什么，解释执行在暂不讨论）。既然替换入口的方式无法达到Hook所有类型方法的目的，那么如果不替换入口，而是直接修改入口里面指向的代码呢？（这种方式有个高大上的学名：callee side dynamic rewriting) </p>
<h3 id="dynamic_callee-side_rewriting">dynamic callee-side rewriting</h3><p>第一次学到这个词是在 Wißfeld, Marvin 的论文 <a href="http://publications.cispa.saarland/143/" target="_blank" rel="external">ArtHook: Callee-side Method Hook Injection on the New Android Runtime ART</a>上。这篇文章很精彩，讲述了各种Hook的原理，并且他还在ART上实现了 dynamic callee-side rewriting 的Hook技术，代码在github上：<a href="https://github.com/mar-v-in/ArtHook" target="_blank" rel="external">ArtHook</a></p>
<p>通俗地讲，dynamic callee-side rewriting其实就是修改entrypoint 所指向的代码。但是有个基本问题：Hook函数和原函数的代码长度基本上是不一样的，而且为了实现AOP，Hook函数通常比原函数长很多。如果直接把Hook函数的代码段copy到原函数entrypoint所指向的代码段，很可能没地儿放。因此，通常的做法是写一段trampoline。也就是把原函数entrypoint所指向代码的开始几个字节修改为一小段固定的代码，这段代码的唯一作用就是跳转到新的位置开始执行，如果这个「新的位置」就是Hook函数，那么基本上就实现了Hook；这种跳板代码我们一般称之为trampoline/stub，比如Android源码中的 art_quick_invoke_stub/art_quick_resolution_trampoline等。</p>
<p>这篇论文基本上指明了ART上Method Hook的方向，而且Wißfeld 本人的项目 ArtHook也差不多达到了这个目的。不过他的Hook实现中，被用来替换的方法必须写死在代码中，因此无法达到某种程度上的动态Hook。比如，我想知道所有线程的创建和销毁，因此选择拦截Thread.class 的run方法；但是Thread子类实现的run方法不一定会调用 Thread 的run，所以可能会漏掉一些线程。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do not call super</span></span><br><span class="line">        Log.i(TAG, <span class="string">"dang dang dang.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"I am started.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start(); <span class="comment">// Thread1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// super.run();</span></span><br><span class="line">        <span class="comment">// do not call super.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start(); <span class="comment">// Thread 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MyThread().start();<span class="comment">// Thread 3</span></span><br></pre></td></tr></table></figure>
<p>上述例子中，如果仅仅Hook Thread.class 的run方法，只有 Thread1能被发现，其他两个都是漏网之鱼。既然如此，我们可以Hook线程的构造函数（子类必定调用父类），从而知道有哪些自定义的线程类被创建，然后直接Hook这些在运行时才发现的类，就能知道所有Java线程的创建和销毁。</p>
<p>要解决「不写死Hook方法」这个问题有两种思路：其一，直接在运行时凭空创建出一个Method；其二，把Hook收拢到一个统一的方法，在这个方法中做分发处理。</p>
<p>第一种方式：凭空创建Method，并非new 一个Method对象就行了，这个方法必须要有你想执行的代码，以及必要的declaring_class, dex_method_index 等成员；要达到这个目的，可以使用运行时字节码生成技术，比如 <a href="https://github.com/linkedin/dexmaker" target="_blank" rel="external">dexmaker</a>。另外，Java本身的动态代理机制也可以也会动态生成代理类，在代理类中有全新创建的方法，如果合适处理，也能达到目的；不过这种方案貌似还无人实现，反倒是entrypoint replcement中有人这么做 :(</p>
<p>第二种方式：用一个函数来处理hook的分发逻辑，这是典型的xposed/dexposed 实现方式。不过Xposed支持Android N过程中直接修改了 libart.so，这种方式对进程内Hook是行不通的。dexposed的 <a href="https://github.com/alibaba/dexposed/tree/dev_art" target="_blank" rel="external">dev_art</a> 分支有尝试过实现，但是几乎不可用。</p>
<p>有趣地是，还有另外一个项目 <a href="https://github.com/rk700/YAHFA" target="_blank" rel="external">YAHFA</a> 也提出了一种Hook方案；不过他这种方案看起来是entrypoint replacement和dynamic callee-side rewriting的结合体：把entrypoint替换为自己的trampoline函数的地址，然后在trampoline继续处理跳转逻辑。作者的<a href="http://rk700.github.io/2017/06/30/hook-on-android-n/" target="_blank" rel="external">博客</a>值得一看。</p>
<h3 id="vtable_replacement">vtable replacement</h3><p>除了传统的类inline hook 的 dynamic callee-side rewriting 的Hook方式，也有基于虚拟机特定实现的Hook技术，比如vtable hook。ART中的这种Hook方式首先是在论文 <a href="http://ceur-ws.org/Vol-1575/paper_10.pdf" target="_blank" rel="external">ARTDroid: A Virtual-Method Hooking Framework on Android ART Runtime</a> 中提出的，作者的实现代码也在github上 <a href="https://github.com/tdr130/art-hooking-vtable" target="_blank" rel="external">art-hooking-vtable</a>。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1511342723016.png" width="340"></p>
<p>这种Hook方式是基于invoke-virtual调用原理的；简单来讲，ART中调用一个virtual method的时候，会查相应Class类里面的一张表，如果修改这张表对应项的指向，就能达到Hook的目的。更详细的实现原理，作者的论文以及他的<a href="http://roptors.me/art/art-part-iii-arthook-framework/" target="_blank" rel="external">博客</a>讲的很详细，感兴趣的可以自行围观。</p>
<p>这种方式最大的缺点是只能Hook virtual方法，虽然根据作者提供的数据：</p>
<blockquote>
<p>59.2% of these methods are declared as virtual<br>1.0% are non-virtual<br>39.8% methods not found</p>
</blockquote>
<p>高达99%的方法都能被hook住，不管你信不信，反正我是不信。所以，这种Hook方式无法Hook所有的调用过程，只能作为一种补充手段使用。</p>
<h2 id="epic的实现">epic的实现</h2><h3 id="基本原理">基本原理</h3><p>了解到已有项目的一些实现原理以及当前的现状，我们可以知道，要实现一个较为通用的Hook技术，几乎只有一条路———基于dynamic dispatch的dynamic callee-side rewriting。epic正是使用这种方式实现的，它的基本原理如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1511354138004.png" width="765"></p>
<p>在讲解这张图之前，有必要说明一下ART中的函数的调用约定。以Thumb2为例，子函数调用的参数传递是通过寄存器r0~r3 以及sp寄存器完成的。r0 ~ r3 依次传递第一个至第4个参数，同时 <em>sp, </em>(sp + 4), <em>(sp + 8), </em>(sp + 12) 也存放着r0~r3上对应的值；多余的参数通过 sp传递，比如 *(sp + 16)放第四个参数，以此类推。同时，函数的返回值放在r0寄存器。如果一个参数不能在一个寄存器中放下，那么会占用2个或多个寄存器。</p>
<p>在ART中，r0寄存器固定存放被调用方法的ArtMethod指针，如果是non-static 方法，r1寄存器存放方法的this对象；另外，只有long/double 占用8bytes，其余所有基本类型和对象类型都占用4bytes。不过这只是基本情形，不同的ART版本对这个调用约定有不同的处理，甚至不完全遵循。</p>
<p>好了我们回到epic。如上图所述，如果我们要Hook <code>android.util.Log.i</code> 这个方法，那么首先需要找到这个方法的entrypoint，可以通过这个方法的ArtMethod对象得到；然后我们直接修改内存，把这个函数的前8个字节：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e92d40e0  ; push    &#123;r5, r6, r7, lr&#125; &#10;b088      ; sub     sp, sp, #32 &#10;1c07      ; mov     r7, r0</span><br></pre></td></tr></table></figure>
<p>修改为一段跳转指令：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dff800f0  <span class="comment">; ldr pc, [pc]</span></span><br><span class="line"><span class="number">7f132450</span>  <span class="comment">; trampoline2 address</span></span><br></pre></td></tr></table></figure>
<p>这样，在执行<code>Log.i</code> 这个函数的时候，会通过这第一段跳板直接跳转到 0x7f132450 这个地址开始执行。这个地址是我们预先分配好的一段内存，也是一段跳转函数，我们姑且称之为二段跳板。在接下来的二段跳板中，我们开始准备分发逻辑：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr </span><span class="literal">ip</span>, <span class="number">3</span>f  <span class="comment">; ip = source_method_address</span></span><br><span class="line"><span class="keyword">cmp </span><span class="literal">r0</span>, <span class="literal">ip</span>  <span class="comment">; r0 == ip ?</span></span><br><span class="line"><span class="keyword">bne.w </span><span class="number">5</span>f    <span class="comment">; if r0 != source_method_address, then jump to label5.</span></span><br></pre></td></tr></table></figure>
<p>这段代码是用来判断是否需要执行Hook的，如果不需要，跳转到原函数的控制流，进而达到调用原函数的目的。接下来就是一些参数准备：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">str </span><span class="literal">sp</span>, [<span class="literal">ip</span>, <span class="number">#0</span>]</span><br><span class="line"><span class="keyword">str </span><span class="literal">r2</span>, [<span class="literal">ip</span>, <span class="number">#4</span>]</span><br><span class="line"><span class="keyword">str </span><span class="literal">r3</span>, [<span class="literal">ip</span>, <span class="number">#8</span>]</span><br><span class="line"><span class="keyword">mov </span><span class="literal">r3</span>, <span class="literal">ip</span></span><br><span class="line"><span class="keyword">ldr </span><span class="literal">r2</span>, <span class="number">3</span>f</span><br><span class="line"><span class="keyword">str </span><span class="literal">r2</span>, [<span class="literal">ip</span>, <span class="number">#12</span>]</span><br><span class="line"><span class="keyword">mov </span><span class="literal">r2</span>, <span class="literal">r9</span></span><br><span class="line"><span class="keyword">ldr </span><span class="literal">pc</span>, <span class="number">2</span>f <span class="comment">; jump to target_method_entry</span></span><br></pre></td></tr></table></figure>
<p>在参数准备好之后，直接跳转到另外一个Java方法的入口开始执行，这个方法称之为bridge方法。bridge方法接管控制流之后我们就回到了Java世界，自此之后我们就可以开始处理AOP逻辑。</p>
<h3 id="一些问题">一些问题</h3><p>基本原理比较简单，但是在实现过程中会有很多问题，这里简单交代一下。</p>
<h4 id="bridge函数分发以及堆栈平衡">bridge函数分发以及堆栈平衡</h4><p>从上面的基本介绍我们可以知道，方法的AOP逻辑是交给一个Java的bridge函数统一处理的，那么这个统一的函数如何区分每一个被Hook的方法，进而调用对应的回调函数呢？</p>
<p>最直接的办法是把被Hook的方法通过额外参数直接传递给bridge函数，而传递参数可以通过寄存器和堆栈实现。用来传递参数的寄存器（如r0~r3)最好是不要<strong>直接</strong>改的，不然我们的处理函数可能就收到不到原函数对应的参数，进而无法完成调用原函数的逻辑。如果用堆栈传递参数的话，我们是直接在堆栈上分配内存吗？</p>
<p>事实证明这样做是不行的，如果我们在二段跳板代码里面开辟堆栈，进而修改了sp寄存器；那么在我们修改sp到调用bridge函数的这段时间里，堆栈结构与不Hook的时候是不一样的（虽然bridge函数执行完毕之后我们可以恢复正常）；在这段时间里如果虚拟机需要进行栈回溯，sp被修改的那一帧会由于回溯不到对应的函数引发致命错误，导致Runtime 直接Abort。什么时候会回溯堆栈？发生异常或者GC的时候。最直观的感受就是，如果bridge函数里面有任何异常抛出（即使被try..catch住）就会使虚拟机直接崩溃。dexposed的 dev_art 分支中的AOP实现就有这个问题。</p>
<p>既然无法分配新的堆栈，那么能否找到空闲的空间使用呢？上面我们在介绍Thumb2调用约定的时候提到，r0~r3传递第一至第四个参数，sp ~ sp + 12 也传递第一至第四个参数，看起来好像是重复了；我们能否把 sp ~ sp + 12 这段空间利用起来呢？</p>
<p>但是实际实现的过程中又发现，此路不通。你以为就你会耍这点小聪明吗？虚拟机本身也是知道 sp + 12 这段空间相当于是浪费的，因此他直接把这段空间当做类似寄存器使用了；如果你把额外的参数丢在这里，那么根本就收不到参数，因为函数调用一旦发生，ART很可能直接把这段内存直接使用了。</p>
<p>既然如此，我们只能把要传递的一个或者多个额外参数打包在一起（比如放在结构体），通过指针一块传递了。再此观察我们上面的二段跳板代码：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr </span><span class="literal">ip</span>, <span class="number">4</span>f</span><br><span class="line"><span class="keyword">str </span><span class="literal">sp</span>, [<span class="literal">ip</span>, <span class="number">#0</span>]</span><br><span class="line"><span class="keyword">str </span><span class="literal">r2</span>, [<span class="literal">ip</span>, <span class="number">#4</span>]</span><br><span class="line"><span class="keyword">str </span><span class="literal">r3</span>, [<span class="literal">ip</span>, <span class="number">#8</span>]</span><br><span class="line"><span class="keyword">mov </span><span class="literal">r3</span>, <span class="literal">ip</span></span><br><span class="line"><span class="keyword">ldr </span><span class="literal">r2</span>, <span class="number">3</span>f</span><br><span class="line"><span class="keyword">str </span><span class="literal">r2</span>, [<span class="literal">ip</span>, <span class="number">#12</span>]</span><br></pre></td></tr></table></figure>
<p>其中，<code>4f</code> 处是我们预先分配好的一段16字节的内存(假设起始地址为base)；我们把 sp 放到 <em>(base)上，把r2寄存器（原第三个参数）放到 </em>(base + 4)，把r3（原第四个参数）放到 <em>(base + 8)，把 <code>3f</code>（被Hook函数的地址）放到 </em>(base + 12)；然后把这个base 的地址放在r3寄存器里面，这样根据调用约定，我们的bridge函数就可以在第四个参数上收到四个打包好的数据，然后通过相同的访问方式就可以把原始数据取出来。这些数据中就包括了被Hook的原函数地址，通过这个地址，我们可以区分不同的被Hook函数，进而触发各自对应的处理逻辑。</p>
<h4 id="入口重合的问题">入口重合的问题</h4><p>在二段跳板函数的开始处，有这么一段代码：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr </span><span class="literal">ip</span>, <span class="number">3</span>f  <span class="comment">; ip = source_method_address</span></span><br><span class="line"><span class="keyword">cmp </span><span class="literal">r0</span>, <span class="literal">ip</span>  <span class="comment">; r0 == ip ?</span></span><br><span class="line"><span class="keyword">bne.w </span><span class="number">5</span>f    <span class="comment">; if r0 != source_method_address, then jump to label5.</span></span><br></pre></td></tr></table></figure>
<p>也许你会问，这个比较逻辑是有必要的吗？除了达到调用原函数的目的之外，这个逻辑还有一个更重要的用途：区分入口相同，但是实际上Java方法完全不同的处理逻辑。</p>
<p>什么时候不同的Java函数的入口会一样呢？至少有下面几种情况：</p>
<ol>
<li>所有ART版本上未被resolve的static函数</li>
<li>Android N 以上的未被编译的所有函数</li>
<li>代码逻辑一模一样的函数</li>
<li>JNI函数</li>
</ol>
<p>static函数是lazy resolve的，在方法没有被调用之前，static函数的入口地址是一个跳板函数，名为 art_quick_resolution_trampoline，这个跳转函数做的事情就是去resvole原始函数，然后进行真正的调用逻辑；因此没有被调用的static函数的entrypoint都是一样的。</p>
<p>Android N以上，APK安装的时候，默认是不会触发AOT编译的；因此如果刚安装完你去看apk生成的OAT文件，会发现里面的code都是空。在这些方法被resolve的时候，如果ART发现code是空，会把entrypoint设置为解释执行的入口；接下来如果此方法被执行会直接进入到解释器。所以，Android N上未被编译的所有方法入口地址都相同。</p>
<p>如果代码逻辑完全一样，那么AOT编译器会发现这完全可以用一个函数来代替，于是这些函数都有了同一个入口地址；而JNI函数由于函数体都是空（也即所有代码相同），理所当然会共享同一个入口。</p>
<p>如果没有这段处理逻辑，你会发现你Hook一个函数的时候，很可能莫名其妙滴Hook了一堆你压根都不知道是什么的函数。</p>
<h4 id="指针与对象转换">指针与对象转换</h4><p>在基本的bridge函数调用（从汇编进入Java世界）的问题搞定之后，我们会碰到一个新问题：在bridge函数中接受到的参数都是一些地址，但是原函数的参数明明是一些对象，怎么把地址还原成原始的参数呢？</p>
<p>如果传递的是基本类型，那么接受到的地址其实就是基本类型值的表示；但是如果传递的是对象，那接受到的 int/long 是个什么东西？</p>
<p>这个问题一言难尽，它的背后是ART的对象模型；这里我简单说明一下。一个最直观的问题就是：JNI中的 jobject，Java中的Object，ART 中的 art::mirror::Object 到底是个什么关系？</p>
<p>实际上，art::mirror::Object 是 Java的Object在Runtime中的表示，java.lang.Object的地址就是art::mirror::Object的地址；但是jobject略有不同，它并非地址，而是一个句柄（或者说透明引用）。为何如此？</p>
<p>因为JNI对于ART来说是外部环境，如果直接把ART中的对象地址交给JNI层（也就是jobject直接就是Object的地址），其一不是很安全，其二直接暴露内部实现不妥。就拿GC来说，虚拟机在GC过程中很可能移动对象，这样对象的地址就会发生变化，如果JNI直接使用地址，那么对GC的实现提出了很高要求。因此，典型的Java虚拟机对JNI的支持中，jobject都是句柄（或者称之为透明引用）；ART虚拟机内部可以在joject与 art::mirror::Object中自由转换，但是JNI层只能拿这个句柄去标志某个对象。</p>
<p>那么jobject与java.lang.Object如何转换呢？这个so easy，直接通过一次JNI调用，ART就自动完成了转换。</p>
<p>因此归根结底，我们需要找到一个函数，它能实现把 art::mirror::Object 转换为 jobject对象，这样我们可以通过JNI进而转化为Java对象。这样的函数确实有，那就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">art::JavaVMExt::AddWeakGlobalReference(art::Thread*, art::mirror::Object*)</span><br></pre></td></tr></table></figure>
<p>此函数在 libart.so中，我们可以通过 <code>dlsym</code>拿到函数指针，然后直接调用。不过这个函数有一个art::Thread<em> 的参数，如何拿到这个参数呢？查阅 art::Thread 的源码发现，这个 art::Thread 与 java.lang.Thread 也有某种对应关系，它们是通过peer结合在一起的（JNI文档中有讲）。也就是说，java.lang.Thread类中的 nativePeer 成员代表的就是当前线程的 art::Thread</em>对象。这个问题迎刃而解。</p>
<h4 id="Android_N无法dlsym">Android N无法dlsym</h4><p>上文提到，为了实现对象和指针的转换，我们需要 <code>dlsym</code> 一个 libart.so 中的导出函数；但不幸地是，在Android N中，Google禁止了这种行为，如果你用 <code>dlsym</code> 去取符号，返回的结果是nullptr。怎么办呢？</p>
<p>libart.so 不过是一个加载在内存中的elf文件而已。我们通过读取 <code>/proc/self/maps</code> 拿到这个文件的加载基地址，然后直接解析ELF文件格式，查出这个符号在ELF文件中的偏移，再加上内存基址，就能得到这个符号真正的地址。不过这过程已经有人实现了，而且放在了github上：<a href="https://github.com/avs333/Nougat_dlfunctions" target="_blank" rel="external">Nougat_dlfunctions</a> 可以直接使用 :)</p>
<h4 id="Android_N_解释执行">Android N 解释执行</h4><p>Android N采用了混合编译的模式，既有解释执行，也有AOT和JIT；APK刚安装完毕是解释执行的，运行时JIT会收集方法调用信息，必要的时候直接编译此方法，甚至栈上替换；在设备空闲时，系统会根据收集到的信息执行AOT操作。</p>
<p>那么在APK刚装完然后使用的那么几次，方法都是解释执行的，我们要Hook掉解释执行的入口吗？这当然可以，但是如果解释执行到一半方法入口被替换为JIT编译好的机器码的入口，那么本次Hook就会失效；我们还需要把JIT编译的机器码入口也拦截住。但是问题是，我们何时知道JIT执行完成？</p>
<p>所以这种方式实行起来比较麻烦，<strong>还不如一开始就全部是机器码</strong> 这样我们只用Hook机器码的entrypoint就可以了。事实上，Android N可以手动触发AOT全量编译，如 <a href="https://source.android.com/devices/tech/dalvik/jit-compiler" target="_blank" rel="external">官方文档</a> 所述，可以通过如下命令手动执行AOT编译：</p>
<blockquote>
<p>adb shell cmd package compile -m speed -f <package-name></package-name></p>
</blockquote>
<p>这样一来，我们一般情况下就不用管解释器的事了。</p>
<p>虽然多这么一个步骤，勉强能解决问题，但还是有点小瑕疵；(毕竟要多这么一步嘛！何况如果这个投入线上使用，你指望用户给你主动编译？）在研究了一段时间的JIT代码之后，我发现<strong>可以主动调用JIT编译某个方法</strong>。这样，在Hook之前我们可以先请求JIT编译此方法，得到机器码的entrypoint，然后按照正常的流程Hook即可。具体如何调用JIT可以参阅epic的<a href="https://github.com/tiann/epic" target="_blank" rel="external">源码</a>。</p>
<h4 id="Android_N_JIT编译">Android N JIT编译</h4><p>上文提到Android N上开启了JIT编译器，即使我们手动触发全量AOT编译，在运行时这种机制依然存在；JIT的一个潜在隐患就是，他有可能动态修改代码，这使得在Android N上的Hook可能随机出现crash。</p>
<p>记得我在刚实现完Android N上的Hook之后，发现我的测试case偶尔会崩溃，崩溃过程完全没有规律，而且崩溃的错误几乎都是SIG 11。当时追查了一段时间，觉得这种随机崩溃可能跟2个原因有关：GC或者JIT；不过一直没有找到证据。</p>
<p>某天半夜我发现一个有趣的现象，如果我把测试case中的Logcat日志输出关掉，崩溃的概率会小很多——如果输出Logcat可能测试八九次就闪退了，但如果关掉日志，要数十次或者几乎不会闪退。当时我就怀疑是不是碰上了薛定谔猫。</p>
<p>理性分析了一番之后我觉得这种尺度不可能触发量子效应，于是我只能把锅摔倒Log头上。我在想是不是Log有IO操作导致hook过程太慢了使得这段时间别的线程有机会修改代码？于是我在Hook过程中Sleep 5s发现一点问题没有。实在没辙，我就一条条删Log，结果发现一个神奇的现象：Log越多越容易崩。然后我就写个循环输出日志100次，结果几乎是毕现闪退。</p>
<p>事情到这里我就瞬间明白了：调用Log的过程中很有可能由于Log函数调用次数过多进而达到JIT编译的阈值从而触发了JIT，这时候JIT线程修改了被执行函数的代码，而Hook的过程也会修改代码，这导致内存中的值不可预期，从而引发随机crash。</p>
<p>按照这种情况推测的话，JIT的存在导致Android N上的Hook几乎是毕现闪退的。因为我的测试demo代码量很少，一个稍微有点规模的App很容易触发JIT编译，一旦在JIT过程中执行Hook，那么必崩无疑。</p>
<p>因此比较好的做法是，在Hook的过程中暂停所有其他线程，不让它们有机会修改代码；在Hook完毕之后在恢复执行。那么问题来了，如何暂停/恢复所有线程？Google了一番发现有人通过ptrace实现：开一个linux task然后挨个ptrace本进程内的所有子线程，这样就是实现了暂停。这种方式很重而且不是特别稳定，于是我就放弃了。ART虚拟机内部一定也有暂停线程的需求（比如GC），因此我可以选择直接调用ART的内部函数。</p>
<p>在源码里面捞了一番之后果然在thread_list.cc 中找到了这样的函数 resumeAll/suspendAll；不过遗憾的是这两个函数是ThreadList类的成员函数，要调用他们必须拿到ThreadList的指针；一般情况下是没有比较稳定的方式拿到这个对象的。不过好在Android 源码通过RAII机制对 suspendAll/resumeAll做了一个封装，名为 <code>ScopedSuspendAll</code> 这类的构造函数里面执行暂停操作，析构函数执行恢复操作，在栈上分配变量此类型的变量之后，在这个变量的作用域内可以自动实现暂停和恢复。因此我只需要用 <code>dlsym</code> 拿到构造函数和析构函数的符号之后，直接调用就能实现暂停恢复功能。详细实现见 epic <a href="https://github.com/tiann/epic" target="_blank" rel="external">源码</a></p>
<p>写了这么多，实际上还有很多想写的没有写完；比如Android M Optimizing编译器上的寄存器分配问题，long/double参数的处理细节，不同ART版本的调用约定 与 ATPCS/AAPCS之间不同等；不过来日方长，这些问题以后在慢慢道来吧 :)</p>
<h2 id="使用">使用</h2><p>扯了这么久的实现原理，我们来看看这玩意儿具体怎么用吧。只需要在你的项目中加入epic的依赖即可(jcenter 仓库)：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">'me.weishu:epic:0.1.2@aar'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以在你的项目中做AOP Hook，比如说要拦截所有Java线程的创建，我们可以用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadMethodHook</span> <span class="keyword">extends</span> <span class="title">XC_MethodHook</span></span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeHookedMethod(param);</span><br><span class="line">        Thread t = (Thread) param.thisObject;</span><br><span class="line">        Log.i(TAG, <span class="string">"thread:"</span> + t + <span class="string">", started.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterHookedMethod(param);</span><br><span class="line">        Thread t = (Thread) param.thisObject;</span><br><span class="line">        Log.i(TAG, <span class="string">"thread:"</span> + t + <span class="string">", exit.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DexposedBridge.hookAllConstructors(Thread.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterHookedMethod(param);</span><br><span class="line">        Thread thread = (Thread) param.thisObject;</span><br><span class="line">        Class&lt;?&gt; clazz = thread.getClass();</span><br><span class="line">        <span class="keyword">if</span> (clazz != Thread.class) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"found class extend Thread:"</span> + clazz);</span><br><span class="line">            DexposedBridge.findAndHookMethod(clazz, <span class="string">"run"</span>, <span class="keyword">new</span> ThreadMethodHook());</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, <span class="string">"Thread: "</span> + thread.getName() + <span class="string">" class:"</span> + thread.getClass() +  <span class="string">" is created."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">DexposedBridge.findAndHookMethod(Thread.class, <span class="string">"run"</span>, <span class="keyword">new</span> ThreadMethodHook());</span><br></pre></td></tr></table></figure>
<p>这里有2个AOP点，其一是 Thread.class 的run方法，拦截这个方法，我们可以知道所有通过Thread类本身创建的线程；其二是Thread的构造函数，这个Hook点我们可以知道运行时具体有哪些类继承了Thread.class类，在找到这样的子类之后，直接hook掉这个类的run方法，从而达到了拦截所有线程创建的目的。</p>
<p>当然，还有很多有趣的AOP点等待你去挖掘，这一切取决于您的想象力 :)</p>
<h2 id="局限">局限</h2><p>上文提到，「要在ART上实现一个完善而稳定的Hook机制，几无可能」，epic也不例外：它也有它自己的缺点，有些是先天的，有些是后天的，还有一些我没有发现的 ~_~；比如说：</p>
<ol>
<li>受限于dynamic callee-side rewrite机制，如果被Hook函数的code段太短以至于一个简单的trampoline跳转都放不下，那么epic无能为力。</li>
<li>如果ART中有深度内联，直接把本函数的代码内联到调用者，那么epic也搞不定。</li>
<li>Android O(8.0)还没有去研究和实现。</li>
<li>当前仅支持thumb2/arm64指令集，arm32/x86/mips还没有支持。 </li>
<li>在支持硬浮点的cpu架构，比如(armeabi-v7a, arm64-v8a)上，带有double/float参数的函数Hook可能有问题，没有充分测试。</li>
<li>还有一些其他机型上的，或者我没有发现的闪退。</li>
</ol>
<p>我本人只在Android 5.0, 5.1, 6.0, 7.0, 7.1 的个别机型，以及这些机型的thumb2指令集，和6.0/7.1 的arm64指令集做过测试；其他的机型均未测试，因此这么长的文章还读到最后的你，不妨拿出你手头的手机帮我测试一下，在下感激不尽 :)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>两年前阿里开源了<a href="https://github.com/alibaba/dexposed">Dexposed</a> 项目，它能够在Dalvik上无侵入地实现运行时方法拦截，正如其介绍「enable ‘god’ mode for single android application」所言，能在非root情况下掌控自己进程空间内的任意Java方法调用，给我们带来了很大的想象空间。比如能实现运行时AOP，在线热修复，做性能分析工具（拦截线程、IO等资源的创建和销毁）等等。然而，随着ART取代Dalvik成为Android的运行时，一切都似乎戛然而止。</p>
<p>今天，我在ART上重新实现了Dexposed，在它能支持的平台（Android 5.0 ~ 7.1 Thumb2/ARM64)上，有着与Dexposed完全相同的能力和API；项目地址在这里 <a href="https://github.com/tiann/epic">epic</a>，感兴趣的可以先试用下:) 然后我们聊一聊ART上运行时Method AOP的故事。</p>]]>
    
    </summary>
    
      <category term="AOP" scheme="http://weishu.me/tags/AOP/"/>
    
      <category term="ART" scheme="http://weishu.me/tags/ART/"/>
    
      <category term="Dexposed" scheme="http://weishu.me/tags/Dexposed/"/>
    
      <category term="Hook" scheme="http://weishu.me/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ART深度探索开篇：从Method Hook谈起]]></title>
    <link href="http://weishu.me/2017/03/20/dive-into-art-hello-world/"/>
    <id>http://weishu.me/2017/03/20/dive-into-art-hello-world/</id>
    <published>2017-03-20T15:37:08.000Z</published>
    <updated>2017-05-30T11:40:28.000Z</updated>
    <content type="html"><![CDATA[<p>Android上的热修复框架 AndFix 想必已经是耳熟能详，它的原理实际上很简单：方法替换——Java层的每一个方法在虚拟机实现里面都对应着一个ArtMethod的结构体，只要把原方法的结构体内容替换成新的结构体的内容，在调用原方法的时候，真正执行的指令会是新方法的指令；这样就能实现热修复，详细代码见 <a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix</a>。</p>
<p>为什么可以这么做呢？那得从 Android 虚拟机的方法调用过程说起。作为一个系列的开篇，本文不打算展开讲虚拟机原理等内容，首先给大家一道开胃菜；后续我们再深入探索ART。</p>
<p>众所周知，AndFix是一种 native 的hotfix方案，它的替换过程是用 c 在 native层完成的，但其实，我们也可以用纯Java实现它！而且，代码还非常精简，且看——</p>
<a id="more"></a>
<h2 id="方法替换原理">方法替换原理</h2><p>既然我们知道 AndFix 的原理是方法替换，那么为什么直接替换Java里面的 <code>java.lang.reflect.Method</code> 有什么问题吗？直接这样貌似很难下结论，那我们换个思路。我们实现方法替换的结果，就是调用原方法的时候最终是调用被替换的方法。因此，我们可以看看 <code>java.lang.reflect.Method</code>类的 <code>invoke</code> 方法。（这里有个疑问，Foo.bar()这种直接调用与反射调用Foo.class.getDeclaredMethod(“bar”).invoke(null) 有什么区别吗？这个问题后续再谈）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> Object <span class="title">invoke</span><span class="params">(Object receiver, Object[] args, <span class="keyword">boolean</span> accessible)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span>;</span><br></pre></td></tr></table></figure>
<p>这个invoke是一个native方法，它的native实现在 <code>art/runtime/native/java_lang_reflect_Method.cc</code> 里面，这个jni方法最终调用了 <code>art/runtime/reflection.cc</code> 的 <code>InvokeMethod</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">object <span class="title">InvokeMethod</span><span class="params">(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa, jobject javaMethod,</span><br><span class="line">                     jobject javaReceiver, jobject javaArgs, <span class="keyword">bool</span> accessible)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 略...</span></span><br><span class="line"></span><br><span class="line">  mirror::ArtMethod* m = mirror::ArtMethod::FromReflectedMethod(soa, javaMethod);</span><br><span class="line"></span><br><span class="line">  mirror::Class* declaring_class = m-&gt;GetDeclaringClass();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按需初始化类，略。。</span></span><br><span class="line"></span><br><span class="line">  mirror::Object* receiver = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (!m-&gt;IsStatic()) &#123;</span><br><span class="line">    <span class="comment">// Check that the receiver is non-null and an instance of the field's declaring class.</span></span><br><span class="line">    receiver = soa.Decode&lt;mirror::Object*&gt;(javaReceiver);</span><br><span class="line">    <span class="keyword">if</span> (!VerifyObjectIsClass(receiver, declaring_class)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the actual implementation of the virtual method.</span></span><br><span class="line">    m = receiver-&gt;GetClass()-&gt;FindVirtualMethodForVirtualOrInterface(m);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 略..</span></span><br><span class="line">  InvokeWithArgArray(soa, m, &amp;arg_array, &amp;result, shorty);</span><br><span class="line">  <span class="comment">// 略 。。</span></span><br><span class="line">  <span class="comment">// Box if necessary and return.</span></span><br><span class="line">  <span class="keyword">return</span> soa.AddLocalReference&lt;jobject&gt;(BoxPrimitive(mh.GetReturnType()-&gt;GetPrimitiveType(),</span><br><span class="line">                                                     result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面函数 InvokeMethod 的第二个参数 <code>javaMethod</code> 就是Java层我们进行反射调用的那个Method对象，在jni层反映为一个jobject；InvokeMethod这个native方法首先通过 <code>mirror::ArtMethod::FromReflectedMethod</code> 获取了Java对象的在native层的 ArtMethod指针，我们跟进去看看是怎么实现的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArtMethod* ArtMethod::FromReflectedMethod(<span class="keyword">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span><br><span class="line">                                          jobject jlr_method) &#123;</span><br><span class="line">  mirror::ArtField* f =</span><br><span class="line">      soa.DecodeField(WellKnownClasses::java_lang_reflect_AbstractMethod_artMethod);</span><br><span class="line">  mirror::ArtMethod* method = f-&gt;GetObject(soa.Decode&lt;mirror::Object*&gt;(jlr_method))-&gt;AsArtMethod();</span><br><span class="line">  DCHECK(method != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">return</span> method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里看到了一点端倪，获取到了Java层那个Method对象的一个叫做 <code>artMethod</code>的字段，然后强转成了ArtMethod指针（这里的说法不是很准确，但是要搞明白这里面的细节一两篇文章讲不清楚 ~_~，我们暂且这么认为吧。）</p>
<p>AndFix的实现里面，也正是使用这个 <code>FromReflectedMethod</code> 方法拿到Java层Method对应native层的ArtMethod指针，然后执行替换的。</p>
<p>上面我们也看到了，我们在native层替换的那个 ArtMethod 不是在 Java 层也有对应的东西么？我们直接替换掉 Java 层的这个artMethod 字段不就OK了？但是我们要注意的是，在Java里面除了基本类型，其他东西都是引用。要实现类似C++里面那种替换引用所指向内容的机智，需要一些黑科技。</p>
<h2 id="Unsafe_和_Memory">Unsafe 和 Memory</h2><p>要在Java层操作内容，也不是没有办法做到；JDK给我们留了一个后门：<code>sun.misc.Unsafe</code> 类；在OpenJDK里面这个类灰常强大，从内存操作到CAS到锁机制，无所不能（可惜的是据说JDK8要去掉？）但是在Android 平台还有一点点不一样，在 Android N之前，Android的JDK实现是 Apache Harmony，这个实现里面的Unsafe就有点鸡肋了，没法写内存；好在Android 又开了一个后门：<code>Memory</code> 类。</p>
<p>有了这两个类，我们就能在Java层进行简单的内存操作了！！由于这两个类是隐藏类，我写了一个wrapper，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// libcode.io.Memory#peekByte</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">peekByte</span><span class="params">(<span class="keyword">long</span> address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Byte) Reflection.call(<span class="keyword">null</span>, <span class="string">"libcore.io.Memory"</span>, <span class="string">"peekByte"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">long</span>.class&#125;, <span class="keyword">new</span> Object[]&#123;address&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pokeByte</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">byte</span> value)</span> </span>&#123;</span><br><span class="line">        Reflection.call(<span class="keyword">null</span>, <span class="string">"libcore.io.Memory"</span>, <span class="string">"pokeByte"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">long</span>.class, <span class="keyword">byte</span>.class&#125;, <span class="keyword">new</span> Object[]&#123;address, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">memcpy</span><span class="params">(<span class="keyword">long</span> dst, <span class="keyword">long</span> src, <span class="keyword">long</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            pokeByte(dst, peekByte(src));</span><br><span class="line">            dst++;</span><br><span class="line">            src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String UNSAFE_CLASS = <span class="string">"sun.misc.Unsafe"</span>;</span><br><span class="line">    <span class="keyword">static</span> Object THE_UNSAFE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> is64Bit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        THE_UNSAFE = Reflection.get(<span class="keyword">null</span>, UNSAFE_CLASS, <span class="string">"THE_ONE"</span>, <span class="keyword">null</span>);</span><br><span class="line">        Object runtime = Reflection.call(<span class="keyword">null</span>, <span class="string">"dalvik.system.VMRuntime"</span>, <span class="string">"getRuntime"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        is64Bit = (Boolean) Reflection.call(<span class="keyword">null</span>, <span class="string">"dalvik.system.VMRuntime"</span>, <span class="string">"is64Bit"</span>, runtime, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getObjectAddress</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object[] objects = &#123;o&#125;;</span><br><span class="line">        Integer baseOffset = (Integer) Reflection.call(<span class="keyword">null</span>, UNSAFE_CLASS,</span><br><span class="line">                <span class="string">"arrayBaseOffset"</span>, THE_UNSAFE, <span class="keyword">new</span> Class[]&#123;Class.class&#125;, <span class="keyword">new</span> Object[]&#123;Object[].class&#125;);</span><br><span class="line">        <span class="keyword">return</span> ((Number) Reflection.call(<span class="keyword">null</span>, UNSAFE_CLASS, is64Bit ? <span class="string">"getLong"</span> : <span class="string">"getInt"</span>, THE_UNSAFE,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Object.class, <span class="keyword">long</span>.class&#125;, <span class="keyword">new</span> Object[]&#123;objects, baseOffset.longValue()&#125;)).longValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体实现">具体实现</h2><p>接下来思路就很简单了呀，用伪代码表示就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcopy(originArtMethod, replaceArtMethod);</span><br></pre></td></tr></table></figure>
<p>但是还有一个问题，我们要整个把 originMethod 的 artMethod 所在的内存直接替换为 replaceMethod 的artMethod 所在的内存（上面我们已经知道，Java层Method类的artMethod实际上就是native层的指针表示，在Android N上更明显，这玩意儿直接就是一个long），现在我们已经知道这两个地址是什么，那么我们把 replaceArtMethod 代表的内存复制到 originArtMethod 的区域，应该还需要知道一个 artMethod 有多大。</p>
<p>但是事情没有一个 sizeof 那么简单。你看AndFix的实现是在每个Android版本把ArtMethod这个结构体复制一份的；要想用sizeof还得把这个类所有的引用复制过来，及其麻烦。更何况在Java里面 sizeof都没有。不过也不是没有办法，既然我们已经能在Java层拿到对象的地址，只需要创建一个数组，丢两个ArtMethod，把两个数组元素的起始地址相减不就得到一个 artMethod的大小了吗？(此方法来自<a href="https://yq.aliyun.com/articles/74598?t=t1" target="_blank" rel="external">Android热修复升级探索——追寻极致的代码热替换</a>)</p>
<p>不过，既然我们实现了方法替换；还有最后一个问题，如果我们需要在替换后的方法里面调用原函数呢？这个也很简单，我们只需要把原函数copy一份保存起来，需要调用原函数的时候调用那个copy的函数不就行了？不过在具体实现的时候，会遇到一个问题，就是 Java的非static 非private的方法默认是虚方法，在调用这个方法的时候会有一个类似查找虚函数表的过程，这个在上面的代码 <code>InvokeMethod</code> 里面可以看到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mirror::Object* receiver = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (!m-&gt;IsStatic()) &#123;</span><br><span class="line">  <span class="comment">// Check that the receiver is non-null and an instance of the field's declaring class.</span></span><br><span class="line">  receiver = soa.Decode&lt;mirror::Object*&gt;(javaReceiver);</span><br><span class="line">  <span class="keyword">if</span> (!VerifyObjectIsClass(receiver, declaring_class)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find the actual implementation of the virtual method.</span></span><br><span class="line">  m = receiver-&gt;GetClass()-&gt;FindVirtualMethodForVirtualOrInterface(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用的时候，如果不是static的方法，会去查找这个方法的真正实现；我们直接把原方法做了备份之后，去调用备份的那个方法，如果此方法是public的，则会查找到原来的那个函数，于是就无限循环了；我们只需要阻止这个过程，查看 FindVirtualMethodForVirtualOrInterface 这个方法的实现就知道，只要方法是 invoke-direct 进行调用的，就会直接返回原方法，这些方法包括：构造函数，private的方法( 见 <a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html" target="_blank" rel="external">https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html</a>) 因此，我们手动把这个备份的方法属性修改为private即可解决这个问题。</p>
<p>详细代码见：<a href="https://github.com/tiann/epic" target="_blank" rel="external">github/epic</a></p>
<p>至此，我们就用纯Java实现了一个 AndFix，代码只有200行不到！！是不是很神奇？当然，这里面包含了很多黑科技，接下来我们将以这个为引子，深入探索Android ART的方方面面，揭开虚拟机底层的神秘面纱，敬请期待～～</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android上的热修复框架 AndFix 想必已经是耳熟能详，它的原理实际上很简单：方法替换——Java层的每一个方法在虚拟机实现里面都对应着一个ArtMethod的结构体，只要把原方法的结构体内容替换成新的结构体的内容，在调用原方法的时候，真正执行的指令会是新方法的指令；这样就能实现热修复，详细代码见 <a href="https://github.com/alibaba/AndFix">AndFix</a>。</p>
<p>为什么可以这么做呢？那得从 Android 虚拟机的方法调用过程说起。作为一个系列的开篇，本文不打算展开讲虚拟机原理等内容，首先给大家一道开胃菜；后续我们再深入探索ART。</p>
<p>众所周知，AndFix是一种 native 的hotfix方案，它的替换过程是用 c 在 native层完成的，但其实，我们也可以用纯Java实现它！而且，代码还非常精简，且看——</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="art" scheme="http://weishu.me/tags/art/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何调试Android Native Framework]]></title>
    <link href="http://weishu.me/2017/01/14/how-to-debug-android-native-framework-source/"/>
    <id>http://weishu.me/2017/01/14/how-to-debug-android-native-framework-source/</id>
    <published>2017-01-14T09:02:03.000Z</published>
    <updated>2017-01-14T09:34:36.000Z</updated>
    <content type="html"><![CDATA[<p>半年前写了一篇文章，介绍 <a href="http://weishu.me/2016/05/30/how-to-debug-android-framework/">如何调试Android Framework</a>，但是只提到了Framework中Java代码的调试办法，但实际上有很多代码都是用C++实现的；无奈当时并并没有趁手的native调试工具，无法做到像Java调试那样简单直观（gdb+eclipse/ida之流虽然可以但是不完美），于是就搁置下了。</p>
<p>Android Studio 2.2版本带来了全新的对Android Native代码的开发以及调试支持，另外LLDB的Android调试插件也日渐成熟，我终于可以把这篇文章继续下去了！本文将带来Android Framework中native代码的调试方法。</p>
<p>在正式介绍如何调试之前，必须先说明一些基本的概念。调试器在调试一个可执行文件的时候，必须知道一些调试信息才能进行调试，这个调试信息可多可少（也可以没有）。最直观的比如行号信息，如果调试器知道行号信息，那么在进行调试的时候就能知道当前执行到了源代码的哪一行，如果调试器还知道对应代码的源文件在哪，那么现代IDE的调试器一般就能顺着源码带你飞了，这就是所谓的源码调试。相反，如果没有行号和源码信息，那么只能进行更低级别的调试了，调试器只能告诉你一些寄存器的值；而当前运行的代码也只是PC寄存器所指向的二进制数据，这些数据要么是虚拟机指令，要么是汇编指令；这就是所谓的无源码调试。显然无源码调试相比源码级别的调试要麻烦的多；接下来将围绕这两个方面分别介绍。</p>
<a id="more"></a>
<h2 id="用Android_Studio进行源码调试">用Android Studio进行源码调试</h2><p>如上文所述，如果需要实现源码调试，必须知道足够的调试信息；在native调试中就是所谓的「调试符号」。但是release版本的动态链接库或者可执行文件一般并不会包含我们需要的调试信息，在Android系统中，<code>/system/lib/*</code> 目录下的那些系统so并没有足够的调试信息，因此如果要进行源码调试，必须自己编译Android源代码，才能获取调试信息，进而让调试器协助我们调试。</p>
<p>Android源码编译是个麻烦事儿，我写过一篇文章介绍 <a href="https://zhuanlan.zhihu.com/p/24633328?refer=weishu" target="_blank" rel="external">如何使用Docker调试</a> ；但是，Android版本众多，如果真的需要调试各个版本，在本地进行编译几乎是不可能的——一个版本约占60G空间，如果每个版本都编译，你的Mac还有空间可用吗？因此比较推荐使用云服务进行源码编译；比如使用阿里云的ECS，20M的网速15分钟就能下载完源码；编译速度还勉强，4核8G两个半小时。扯远了 :) 如果你没有精力编译Android源码，我这个 <a href="https://github.com/tiann/android-native-debug" target="_blank" rel="external">Demo工程</a> 可以让你尝尝鲜，里面包含一些调试的必要文件，可以体会一下Native调试的感觉。</p>
<p>如果我们已经拥有了调试符号，那么还需要保证你的符号文件和设备上真正运行的动态链接库或者可执行文件是对应的，不然就是鸡同鸭讲了。最简单的办法就是使用模拟器。我们编译完源码之后，一个主要的编译产物就是 <code>system.img</code>，这个 <code>system.img</code>会在启动之后挂载到设备的 /system 分区，而system分区包含了Android系统运行时的绝大部分可执行文件和动态链接库，而这些文件就是我们的编译输出，正好可以与编译得到的调试符号进行配合调试。模拟器有一个 <code>-system</code>选项用来指定模拟器使用的 system.img文件；于是这个问题也解决了。</p>
<p>最后一个问题就是，既然是源码调试，当然需要源码了；我们可以在 <a href="https://android.googlesource.com/" target="_blank" rel="external">AOSP</a> 上下载需要的源码即可；需要注意的是，在check分支的时候，必须保证你的分支和编译源码时候的分支是一致的。</p>
<p>需要说明的是，虽然我们使用Android Studio调试，但是其背后的支撑技术实际上是 <a href="http://lldb.llvm.org/" target="_blank" rel="external">LLDB</a>。LLDB是一个相当强大的调试器，如果你现在还不知道它为何物，那真的是孤陋寡闻了！建议先简单学习一下 <a href="http://lldb.llvm.org/index.html" target="_blank" rel="external">教程</a></p>
<p>万事俱备，Let’s go!</p>
<h3 id="建立Android_Studio工程">建立Android Studio工程</h3><p>实际上任何Android Studio工程都可以进行native源码调试，但是为了方便还是新建一个工程；这个工程是一个空工程，没有任何实际用途；为了体验方便，你可以使用我的这个 <a href="https://github.com/tiann/android-native-debug" target="_blank" rel="external">Demo</a> 工程，里面包含了调试符号以及模拟器需要使用的system.img。一定要注意Android Studio的版本必须是2.2以上（我的是2.2.3稳定版)。</p>
<h3 id="下载需要调试模块的源码">下载需要调试模块的源码</h3><p>如果你本地编译了Android源码，那么就不需要这一步了；但是更多的时候我们只是想调试某一个模块，那么只需要下载这个模块的源码就够了。我这里演示的是调试 ART 运行时，因此直接下载ART模块的源码即可，我编译的Android源码版本是 <code>android-5.1.1_r9</code>，因此需要check这个分支的源码，地址在这里：<a href="https://android.googlesource.com/platform/art/+/android-5.1.1_r9" target="_blank" rel="external">ART-android-5.1.1_r9</a></p>
<h3 id="运行模拟器">运行模拟器</h3><p>由于我们的调试符号需要与运行时的动态链接库对应，因此我们需要借助模拟器；首先创建一个编译出来的调试符号对应的API版本的模拟器，我这里提供的是5.1.1也就是API 22；然后使用编译出来的 system.img 启动模拟器（[Demo]工程的image目录有我编译出来的文件，可以直接使用。）：</p>
<blockquote>
<p>emulator -avd 22 -verbose -no-boot-anim -system /path/to/system.img</p>
</blockquote>
<p>这个过程灰常灰常长！！我启动这个模拟器花了半个多小时，也是醉。现在是2017年，已经是Android创建的第十个年头，ARM模拟器还是烂的一塌糊涂，无力吐槽。一个能让它快一点的诀窍是创建一个小一点的SD card；我设置的是10M。</p>
<h3 id="开始调试">开始调试</h3><h4 id="选择native调试模式">选择native调试模式</h4><p>首先我们对调试的宿主工程设置一下，选择native调试功能。点击运行下面的按钮 <code>Edit Configuration</code>：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1484287940736.png" width="232"></p>
<p>然后在debugger栏选择Native：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1484288018710.png" width="400"></p>
<p>然后我们点击旁边的 <code>Debug</code>小按钮运行调试程序：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1484288078862.png" width="183"></p>
<h4 id="设置调试符号以及关联源码">设置调试符号以及关联源码</h4><p>在运行程序之后，我们可以在Android Studio的状态栏看到，LLDB调试插件自动帮我们完成了so查找路径的过程，这一点比gdb方便多了！在Android Studio的Debug窗口会自动弹出来，如下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1484288380978.png" width="474"></p>
<p>我们点击那个 <code>pause program</code> 按钮，可以让程序暂停运行：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1484288440156.png" width="615"></p>
<p>上图左边是正在运行的线程的堆栈信息，右边有两个tab，一个用来显示变量的值；一个是lldb交互式调试窗口！我们先切换到lldb窗口，输入如下命令设置一个断点：</p>
<blockquote>
<p>(lldb) br s -n CollectGarbageInternal<br>Breakpoint 2: where = libart.so`art::gc::Heap::CollectGarbageInternal(art::gc::collector::GcType, art::gc::GcCause, bool), address = 0xb4648c20</p>
</blockquote>
<p>可以看到，断点已经成功设置；这个断点在libart.so中，不过现在还没有调试符号信息以及源码信息，我们只知道它的地址。接下来我们设置调试符号以及关联源码。</p>
<p>接下来我们把编译得到的符号文件 libart.so 告诉调试器（符号文件和真正的动态链接库这两个文件名字相同，只不过一个在编译输出的symbols目录) ；在lldb窗口执行：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb<span class="function">)</span><span class="instruction"> add-dsym </span>/Users/weishu/dev/github/Android-native-debug/app/symbols/libart.so</span><br><span class="line">symbol file '/Users/weishu/dev/github/Android-native-debug/app/symbols/libart.so' \</span><br><span class="line">has been added to '/Users/weishu/.lldb/module_cache/remote-android/.cache/C51E51E5-0000-0000-0000-000000000000/libart.so'</span><br></pre></td></tr></table></figure>
<p>注意后面那个目录你的机器上与我的可能不同，需要修改一下。我们再看看有什么变化，看一下刚刚的断点：</p>
<blockquote>
<p>(lldb) br list 2<br>2: name = ‘CollectGarbageInternal’, locations = 1, resolved = 1, hit count = 0<br>  2.1: where = libart.so`art::gc::Heap::CollectGarbageInternal(art::gc::collector::GcType, art::gc::GcCause, bool) <strong>at heap.cc:2124</strong>, address = 0xb4648c20, resolved, hit count = 0 </p>
</blockquote>
<p>行号信息已经加载出来了！！在 <code>heap.cc</code> 这个文件的第2124行。不过如果这时候断点命中，依然无法关联到源码。我们看一下调试器所所知道的源码信息：</p>
<blockquote>
<p>(lldb) source info<br>Lines found in module `libart.so<br>[0xb4648c20-0xb4648c28): <strong>/Volumes/Android/android-5.1.1_r9/art/runtime/gc/heap.cc</strong>:2124</p>
</blockquote>
<p>纳尼？？这个目录是个什么鬼，根本没有这个目录好伐？难道是调试器搞错了？</p>
<p>在继续介绍之前我们需要了解一些关于「调试符号」的知识；我们拿到的调试符号文件其实是一个DWARF文件，只不过这个文件被嵌入到了ELF文件格式之中，而其中的调试符号则在一些名为 <code>.debug_*</code> 的段之中，我们可以用 <code>readelf -S libart.so</code> 查看一下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1484289374465.png" width="616"></p>
<p>编译器在编译libart.so的时候，记录下了<strong>编译时候</strong>源代码与代码偏移之间的对应关系，因此调试器可以从调试符号文件中获取到源码行号信息；如下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1484289826696.png" width="486"></p>
<p>这下我们明白了上面那个莫名其妙的目录是什么了；原来是在编译<code>libart.so</code>的那个机器上存在源码。那么问题来了，我们绝大多数情况下是使用另外一台机器上的源码进行调试的——比如我提供的那个 <a href="https://github.com/tiann/android-native-debug" target="_blank" rel="external">Demo工程</a> 包含的带符号libart.so里面保存的源文件信息的目录实际上是我编译的电脑上的目录，而你调试的时候需要使用自己电脑上的目录。知道了问题所在，解决就很简单了，我们需要映射一下；在Android Studio的Debug 窗口的lldb 那个tab执行如下命令：</p>
<blockquote>
<p>(lldb) settings set target.source-map /Volumes/Android/android-5.1.1_r9/ /Users/weishu/dev/github/Android-native-debug/app/source/</p>
</blockquote>
<p>第一个参数的意思是编译时候的目录信息，第二个参数是你机器上的源码存放路径；设置成自己的即可。</p>
<p>这时候，我们再触发断点（点击demo项目的Debug按钮），看看发生了什么？！</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1484290490320.png" width="1191"></p>
<p>至此，我们已经成功滴完成了在Android Studio中Native代码的源码调试。你可以像调试Java代码一样调试Native代码，step/in/out/over，条件断点，watch point任你飞。你可以借助这个工具去探究Android底层运行原理，比如垃圾回收机制，对象分配机制，Binder通信等等，完全不在话下！</p>
<h2 id="无源码调试">无源码调试</h2><p>接下来再介绍一下操作简单但是使用门槛高的「无源码调试」方式；本来打算继续使用Android Studio的，但是无奈现阶段还有BUG，给官方提了issue但是响应很慢：<a href="https://code.google.com/p/android/issues/detail?id=231116。因此我们直接使用" target="_blank" rel="external">https://code.google.com/p/android/issues/detail?id=231116。因此我们直接使用</a> LLDB 调试；当然，用gdb也能进行无源码调试，但是使用lldb比gdb的步骤要简单得多；不信你可以看下文。</p>
<h3 id="安装Android_LLDB工具">安装Android LLDB工具</h3><p>要使用lldb进行调试，首先需要在调试设备上运行一个lldb-server，这个lldb-server attach到我们需要调试的进程，然后我们的开发机与这个server进行通信，就可以进行调试了。熟悉gdb调试的同学应该很清楚这一点。我们可以用Android Studio直接下载这个工具，打开SDK Manager：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1484280931189.png" width="720"></p>
<p>如上图，勾选这个即可；下载的内容会存放到你的 $ANDROID_SDK/lldb 目录下。</p>
<h3 id="使用步骤">使用步骤</h3><p>安装好必要的工具之后，就可以开始调试了；整体步骤比较简单：把lldb-server推送到调试设备并运行这个server，在开发机上连上这个server即可；以下是详细步骤。</p>
<h4 id="在手机端运行lldb-server">在手机端运行lldb-server</h4><p>如果你的调试设备是root的，那么相对来说比较简单；毕竟我们的调试进程lldb-server要attach到被调试的进程是需要一定权限的，如果是root权限那么没有限制；如果没有root，那么我们只能借助<code>run-as</code>命令来调试自己的进程；另外，被调试的进程必须是debuggable，不赘述。以下以root的设备为例（比如模拟器）</p>
<ol>
<li><p>首先把lldb-server push到调试设备。lldb-sever这个文件可以在 `$ANDROID_SDK/lldb/&lt;版本号数字&gt;/android/ 目录下找到，确认你被调试设备的CPU构架之后选择你需要的那个文件，比如大多数是arm构架，那么执行：</p>
<blockquote>
<p>adb push lldb-server /data/local/tmp/</p>
</blockquote>
</li>
<li><p>在调试设备上运行lldb-server。</p>
<blockquote>
<p>adb shell /data/local/tmp/lldb-server platform \<br>–server –listen unix-abstract:///data/local/tmp/debug.sock</p>
</blockquote>
<p>如果提示 /data/local/tmp/lldb-server: can’t execute: Permission denied，那么给这个文件加上可执行权限之后再执行上述命令：</p>
<blockquote>
<p>adb shell chmod 777 /data/local/tmp/lldb-server</p>
</blockquote>
<p>这样，调试server就在设备上运行起来了，注意要这么做需要设备拥有root权限，不然后面无法attach进程进行调试；没有root权限另有办法。另外，这个命令执行之后所在终端会进入阻塞状态，不要管它，如下进行的所有操作需要重新打开一个新的终端。</p>
</li>
</ol>
<h4 id="连接到lldb-server开始调试">连接到lldb-server开始调试</h4><p>首先打开终端执行lldb（Mac开发者工具自带这个，Windows不支持）,会进入一个交互式的环境，如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1484282196260.png" width="462"></p>
<ol>
<li><p>选择使用Android调试插件。执行如下命令：</p>
<blockquote>
<p>platform select remote-android</p>
</blockquote>
<p>如果提示没有Android，那么你可能需要升级一下你的XCode；只有新版本的lldb才支持Android插件。</p>
</li>
<li><p>连接到lldb-server</p>
<p>这一步比较简单，但是没有任何官方文档有说明；使用办法是我查阅Android Studio的源码学习到的。如下：</p>
<blockquote>
<p>platform connect unix-abstract-connect:///data/local/tmp/debug.sock</p>
</blockquote>
<p>正常情况下你执行lldb-server的那个终端应该有了输出：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1484282509260.png" width="430"></p>
</li>
<li><p>attach到调试进程。首先你需要查出你要调试的那个进程的pid，直接用ps即可；打开一个新的终端执行：</p>
<blockquote>
<p>~ adb shell ps | grep lldbtest<br>u0_a53    2242  724   787496 33084 ffffffff b6e0c474 S com.example.weishu.lldbtest</p>
</blockquote>
<p>我要调试的那个进程pid是 <code>2242</code>，接下来回到lldb的那个交互式窗口执行：</p>
<blockquote>
<p>process attach -p 2242</p>
</blockquote>
<p>如果你的设备没有root，那么这一步就会失败——没有权限去调试一个别的进程；非root设备的调试方法见下文。</p>
<p>至此，调试环境就建立起来了。不需要像gdb那样设置端口转发，lldb的Android调试插件自动帮我们处理好了这些问题。虽然说了这么多，但是你熟练之后真正的步骤只有两步，灰常简单。</p>
</li>
<li><p>断点调试</p>
<p> 调试环境建立之后自然就可以进行调试了，如果进行需要学习lldb的使用方法；我这里先演示一下，不关心的可以略过。</p>
<ol>
<li><p>首先下一个断点：</p>
<blockquote>
<p>(lldb) br s -n CollectGarbageInternal<br>  Breakpoint 1: where = libart.so`art::gc::Heap::CollectGarbageInternal(art::gc::collector::GcType, art::gc::GcCause, bool), address = 0xb4648c20</p>
</blockquote>
</li>
<li><p>触发断点之后，查看当前堆栈：</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread #<span class="number">8</span>: tid = <span class="number">2254</span>, <span class="number">0xb4648c20</span> libart.so`art::gc::Heap::CollectGarbageInternal(art::gc::collector::GcType, art::gc::GcCause, <span class="keyword">bool</span>), name = <span class="string">'GCDaemon</span>', stop reason = breakpoint <span class="number">1.1</span></span><br><span class="line">* frame #<span class="number">0</span>: <span class="number">0xb4648c20</span> libart.so`art::gc::Heap::CollectGarbageInternal(art::gc::collector::GcType, art::gc::GcCause, <span class="keyword">bool</span>)</span><br><span class="line">frame #<span class="number">1</span>: <span class="number">0xb464a550</span> libart.so`art::gc::Heap::ConcurrentGC(art::Thread*) + <span class="number">52</span></span><br><span class="line">frame #<span class="number">2</span>: <span class="number">0x72b17161</span> com.example.weishu.lldbtest</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看寄存器的值</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	(lldb) reg read</span><br><span class="line">General Purpose Registers:</span><br><span class="line">   r0 = <span class="number">0xb4889600</span></span><br><span class="line">   r1 = <span class="number">0x00000001</span></span><br><span class="line">   r2 = <span class="number">0x00000001</span></span><br><span class="line">   r3 = <span class="number">0x00000000</span></span><br><span class="line">   r4 = <span class="number">0xb4889600</span></span><br><span class="line">   r5 = <span class="number">0xb4835000</span></span><br><span class="line">   r6 = <span class="number">0xb47fcfe4</span>  libart.so`art::Runtime::instance_</span><br><span class="line">   r7 = <span class="number">0xa6714380</span></span><br><span class="line">   r8 = <span class="number">0xa6714398</span></span><br><span class="line">   r9 = <span class="number">0xb4835000</span></span><br><span class="line">   r10 = <span class="number">0x00000000</span></span><br><span class="line">   r11 = <span class="number">0xa6714360</span></span><br><span class="line">   r12 = <span class="number">0xb47fbb28</span>  libart.so`art::Locks::logging_lock_</span><br><span class="line">   sp = <span class="number">0xa6714310</span></span><br><span class="line">   lr = <span class="number">0xb464a551</span>  libart.so`art::gc::Heap::ConcurrentGC(art::Thread*) + <span class="number">53</span></span><br><span class="line">   pc = <span class="number">0xb4648c20</span>  libart.so`art::gc::Heap::CollectGarbageInternal(art::gc::collector::GcType, art::gc::GcCause, <span class="keyword">bool</span>)</span><br><span class="line"> 	cpsr = <span class="number">0x20000030</span></span><br></pre></td></tr></table></figure>
<p> 我们可以看到寄存器 <code>r0</code>的值为 <code>0xb4889600</code>，这个值就是 `CollectGarbageInternal<br> 函数的第一个参数，this指针，也就是当前Heap对象的地址。在ARM下，r0~r4存放函数的参数，超过四个的参数放在栈上，具体如何利用这些寄存器的信息需要了解一些ARM汇编知识。</p>
</li>
<li><p>查看运行的汇编代码</p>
 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) di -p</span><br><span class="line">	libart.so`art::gc::Heap::CollectGarbageInternal:</span><br><span class="line">-&gt;  <span class="number">0xb4648c20</span> &lt;+<span class="number">0</span>&gt;:  <span class="keyword">push.w </span>&#123;<span class="literal">r4</span>, <span class="literal">r5</span>, <span class="literal">r6</span>, <span class="literal">r7</span>, <span class="literal">r8</span>, <span class="literal">r9</span>, <span class="literal">r10</span>, <span class="literal">r11</span>, <span class="literal">lr</span>&#125;</span><br><span class="line">	<span class="number">0xb4648c24</span> &lt;+<span class="number">4</span>&gt;:  <span class="keyword">subw </span>  <span class="literal">sp</span>, <span class="literal">sp</span>, <span class="number">#0x52c</span></span><br><span class="line">	<span class="number">0xb4648c28</span> &lt;+<span class="number">8</span>&gt;:  <span class="keyword">ldr.w </span> <span class="literal">r9</span>, [<span class="literal">pc</span>, <span class="number">#0xa9c</span>]</span><br><span class="line">	<span class="number">0xb4648c2c</span> &lt;+<span class="number">12</span>&gt;: <span class="keyword">add </span>   <span class="literal">r4</span>, <span class="literal">sp</span>, <span class="number">#0x84</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h4 id="没有root设备的调试办法">没有root设备的调试办法</h4><p>如果没有root权限，那么我可以借助run-as命令。run-as可以让我们以某一个app的身份执行命令——如果我们以被调试的那个app的身份进行attach，自然是可以成功的。</p>
<p>假设被调试的app包名为 <code>com.example.lldb</code>，那么首先想办法把 <code>lldb-server</code>这个文件推送到这个app自身的目录：</p>
<ol>
<li><p><code>adb push</code>直接这么做不太方便（还需要知道userid)，我们先push到 /data/local/tmp/</p>
<blockquote>
<p>adb push lldb-server /data/local/tmp/</p>
</blockquote>
</li>
<li><p>然后执行adb shell，连接到Android shell，执行</p>
<blockquote>
<p>run-as com.example.lldb`</p>
</blockquote>
</li>
<li><p>拷贝这个文件到本App的目录，并修改权限；（由于有的手机没有cp命令，改用cat)</p>
<blockquote>
<p>cat /data/local/tmp/lldb-server &gt; lldb-server<br>chmod 777 lldb-server</p>
</blockquote>
</li>
<li><p>运行lldb-server</p>
<blockquote>
<p>lldb-server platform –listen unix-abstract:///data/local/tmp/debug.sock</p>
</blockquote>
</li>
</ol>
<p>接下来的步骤就与上面root设备的调试过程完全一样了 :)</p>
<h2 id="后记">后记</h2><p>终于完成了Android调试这一系列的文章，时间跨度长达一年；从Java到C/C++再到汇编级别的调试，从有源码到无源码，从Application层到Framework层，任何代码都可以进行调试。借助强大的IDE以及调试器，我们不仅可以快速定位和解决问题，还可以深入学习任何一个复杂的模块。尤记得用探索用lldb进行native调试的过程，网上没有任何android方面的教程，唯一的学习资料就是Android Studio调试模块的源码以及LLDB Android插件的源码；这其中碰的壁和踩过的坑不计其数。好在最后终于一一解决，可以睡个安稳觉了 ~_~</p>
<ol>
<li><a href="http://weishu.me/2015/12/21/android-studio-debug-tips-you-may-not-know/">Android Studio你不知道的调试技巧</a></li>
<li><a href="http://weishu.me/2016/05/30/how-to-debug-android-framework/">如何调试Android Framework</a></li>
<li><a href="#">如何调试Android Framework Native</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>半年前写了一篇文章，介绍 <a href="http://weishu.me/2016/05/30/how-to-debug-android-framework/">如何调试Android Framework</a>，但是只提到了Framework中Java代码的调试办法，但实际上有很多代码都是用C++实现的；无奈当时并并没有趁手的native调试工具，无法做到像Java调试那样简单直观（gdb+eclipse/ida之流虽然可以但是不完美），于是就搁置下了。</p>
<p>Android Studio 2.2版本带来了全新的对Android Native代码的开发以及调试支持，另外LLDB的Android调试插件也日渐成熟，我终于可以把这篇文章继续下去了！本文将带来Android Framework中native代码的调试方法。</p>
<p>在正式介绍如何调试之前，必须先说明一些基本的概念。调试器在调试一个可执行文件的时候，必须知道一些调试信息才能进行调试，这个调试信息可多可少（也可以没有）。最直观的比如行号信息，如果调试器知道行号信息，那么在进行调试的时候就能知道当前执行到了源代码的哪一行，如果调试器还知道对应代码的源文件在哪，那么现代IDE的调试器一般就能顺着源码带你飞了，这就是所谓的源码调试。相反，如果没有行号和源码信息，那么只能进行更低级别的调试了，调试器只能告诉你一些寄存器的值；而当前运行的代码也只是PC寄存器所指向的二进制数据，这些数据要么是虚拟机指令，要么是汇编指令；这就是所谓的无源码调试。显然无源码调试相比源码级别的调试要麻烦的多；接下来将围绕这两个方面分别介绍。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="debug" scheme="http://weishu.me/tags/debug/"/>
    
      <category term="framework" scheme="http://weishu.me/tags/framework/"/>
    
      <category term="native" scheme="http://weishu.me/tags/native/"/>
    
      <category term="source" scheme="http://weishu.me/tags/source/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[史上最简单Android源码编译环境搭建方法]]></title>
    <link href="http://weishu.me/2016/12/30/simple-way-to-compile-android-source/"/>
    <id>http://weishu.me/2016/12/30/simple-way-to-compile-android-source/</id>
    <published>2016-12-29T17:08:41.000Z</published>
    <updated>2016-12-29T17:11:36.000Z</updated>
    <content type="html"><![CDATA[<p>有史以来，Android源码编译环境的搭建始终是一件麻烦事儿。网上有数不清的文章介绍如何编译Android源代码，但是他们要么方法复杂、步骤太多；要么自称解决了一些编译问题（需要修改头文件，系统配置等），让人对其可信度产生质疑。有的童鞋硬着头皮照做了，但是由于伟大的GFW，大部分都死在了第一步——repo脚本都下载不下来，就算下载过了过不了gerrit那一关。另外，就算你具备科学上网的能力，下载时间又成为了拦路虎；普通的VPN通常需要下载七八个小时，简直就是痛不欲生。久而久之，很多人对下载编译Android源码望而却步。</p>
<p>今天，我给大家提供一个极其简单、稳定的方案，来解决Android源码的下载编译问题。</p>
<p>首先，下载问题可以通过镜像解决；<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="external">清华镜像</a> 和 <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp" target="_blank" rel="external">科大镜像</a> 都是非常不错的选择，正常情况下一到两个小时即可下载完一个Android源码分支。</p>
<p>然后就是编译环境问题。由于Android源码庞大，依赖复杂；一旦使用的编译工具链有细微的不同就可能引发编译失败。<a href="https://source.android.com/source/initializing.html" target="_blank" rel="external">官方文档</a> 推荐使用Ubuntu 14.04进行编译。如果我们用Windows或者Mac系统，传统方式是使用虚拟机；但是在今天，我们完全可以使用 <strong>Docker</strong> 替代！！借助Docker，我们可以不用担心编译环境问题；不论我们的开发机是什么系统，可以使用Docker创建Ubuntu Image，并且直接在这个Ubuntu系统环境中创建编译所需要的工具链（JDK，ubuntu系统的依赖库等等）；而且，Docker运行的Ubuntu的系统开销比虚拟机低得多，这样下载以及编译速度就有了质的提升。更重要的是，这个环境可以作为一个Image打包发布！这样，你在不同的开发机，还有你与你的同事之间有了同一套编译环境，这会省去很多不必要的麻烦。关于Docker的更多内容，见 <a href="http://www.docker.com/" target="_blank" rel="external">Docker官网</a></p>
<a id="more"></a>
<p>当然，这个伟大的创举并不是我完成的，而是 <a href="https://github.com/kylemanna/docker-aosp" target="_blank" rel="external">kylemanna/docker-aosp</a>！我针对Docker以及天朝的网络环境做了一部分修改，fork了一份 <a href="https://github.com/tiann/docker-aosp" target="_blank" rel="external">tiann/docker-aosp</a>。</p>
<p>废话不多说，我们看看具体如何使用，以及怎么个简单法。</p>
<h2 id="使用步骤">使用步骤</h2><h3 id="安装Docker">安装Docker</h3><p>Docker的下载地址见 <a href="https://www.docker.com/products/overview" target="_blank" rel="external">Docker下载</a> ；下载完毕安装即可。</p>
<h3 id="准备工作">准备工作</h3><p>如果你不是Mac系统，可以直接略过这一步。</p>
<p>Mac的文件系统默认不区分大小写，这不满足Android源码编译系统的要求（编译的时候直接Error）；因此需要单独创建一个大小写敏感的磁盘映像。步骤如下：</p>
<ol>
<li>打开Mac的系统软件：<strong>磁盘工具</strong></li>
<li><p>CMD + N，创建新的磁盘映像，参数设置如下图：</p>
<p> <img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1483019239159.png" width="430"></p>
<p> 其中磁盘大小设置为 50~100G合适，<strong>格式一定要选择带区分大小写标志的。</strong></p>
</li>
</ol>
<h3 id="开始下载编译">开始下载编译</h3><p>真正的下载编译过程相当简单，脚本会自动完成；步骤如下：</p>
<ol>
<li><p>设置Android源码下载存放的目录；如果是Mac系统，这一步必须设置为一个大小写敏感的目录；不然后面编译的时候会失败。如果不设置这一步，那么源码会下载到 <code>~/aosp-root</code> 目录；设置过程如下：</p>
<p> <code>export AOSP_VOL=/Volume/Android/</code></p>
</li>
<li><p>下载wrapper脚本；如果需要下载其他系统版本，直接修改下载完毕后的build-nougat.sh文件的 android-4.4.4_r2.0.1改成你需要的分支即可，分支的信息见 <a href="https://source.android.com/source/build-numbers.html#source-code-tags-and-builds" target="_blank" rel="external">分支列表</a></p>
<p> <code>curl -O https://raw.githubusercontent.com/kylemanna/docker-aosp/master/tests/build-nougat.sh</code></p>
</li>
<li><p>运行脚本，开始自动下载安装过程；Windows系统可以使用 <a href="https://msdn.microsoft.com/en-us/commandline/wsl/about" target="_blank" rel="external">Bash for Windows</a> 或者cygwin。</p>
<p> <code>bash ./build-nougat.sh</code></p>
</li>
</ol>
<p>这样，所有的工作就都做完了。只需静静等待即可；时间视下载速度而定，清华的镜像速度还可以，笔者使用不到2小时就完成了下载编译过程。</p>
<p>三步完成，是不是灰常简单？赶紧下载编译安装属于你的Android系统吧 ^_^</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有史以来，Android源码编译环境的搭建始终是一件麻烦事儿。网上有数不清的文章介绍如何编译Android源代码，但是他们要么方法复杂、步骤太多；要么自称解决了一些编译问题（需要修改头文件，系统配置等），让人对其可信度产生质疑。有的童鞋硬着头皮照做了，但是由于伟大的GFW，大部分都死在了第一步——repo脚本都下载不下来，就算下载过了过不了gerrit那一关。另外，就算你具备科学上网的能力，下载时间又成为了拦路虎；普通的VPN通常需要下载七八个小时，简直就是痛不欲生。久而久之，很多人对下载编译Android源码望而却步。</p>
<p>今天，我给大家提供一个极其简单、稳定的方案，来解决Android源码的下载编译问题。</p>
<p>首先，下载问题可以通过镜像解决；<a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">清华镜像</a> 和 <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp">科大镜像</a> 都是非常不错的选择，正常情况下一到两个小时即可下载完一个Android源码分支。</p>
<p>然后就是编译环境问题。由于Android源码庞大，依赖复杂；一旦使用的编译工具链有细微的不同就可能引发编译失败。<a href="https://source.android.com/source/initializing.html">官方文档</a> 推荐使用Ubuntu 14.04进行编译。如果我们用Windows或者Mac系统，传统方式是使用虚拟机；但是在今天，我们完全可以使用 <strong>Docker</strong> 替代！！借助Docker，我们可以不用担心编译环境问题；不论我们的开发机是什么系统，可以使用Docker创建Ubuntu Image，并且直接在这个Ubuntu系统环境中创建编译所需要的工具链（JDK，ubuntu系统的依赖库等等）；而且，Docker运行的Ubuntu的系统开销比虚拟机低得多，这样下载以及编译速度就有了质的提升。更重要的是，这个环境可以作为一个Image打包发布！这样，你在不同的开发机，还有你与你的同事之间有了同一套编译环境，这会省去很多不必要的麻烦。关于Docker的更多内容，见 <a href="http://www.docker.com/">Docker官网</a></p>]]>
    
    </summary>
    
      <category term="android source" scheme="http://weishu.me/tags/android-source/"/>
    
      <category term="compile" scheme="http://weishu.me/tags/compile/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之虚拟机调优]]></title>
    <link href="http://weishu.me/2016/12/23/dive-into-android-optimize-vm-heap/"/>
    <id>http://weishu.me/2016/12/23/dive-into-android-optimize-vm-heap/</id>
    <published>2016-12-23T14:53:09.000Z</published>
    <updated>2016-12-23T14:57:22.000Z</updated>
    <content type="html"><![CDATA[<p>介绍完 <a href="https://zhuanlan.zhihu.com/p/24414378" target="_blank" rel="external">深入学习Android：虚拟机&amp;运行时</a> 之后，很多小伙伴问我，你描述的这些知识结构看起来艰深晦涩高大上，实际工作中能有多大用途呢？今天我就简单举个例子。</p>
<p>众所周知，我们的Android App运行在Java虚拟机之上，而Java是一门带GC的语言。在虚拟机进行垃圾回收的时候，要做一件很形象的事叫做STW（stop the world）；也就是说，为了回收那些不再使用的对象，虚拟机必须要停止所有的线程来进行必要的工作。虽说这一点在ART运行时上得到了很大的改善，但是GC的存在对App运行时的性能始终有着微妙的影响。如果你观察过手机输入的日志，一定会看到类似如下的内容：</p>
<blockquote>
<p>12-23 18:46:07.300 28643-28658/? I/art: Background sticky concurrent mark sweep GC freed 15442(1400KB) AllocSpace objects, 8(128KB) LOS objects, 4% free, 32MB/33MB, paused 10.356ms total 53.023ms at GCDaemon thread CareAboutPauseTimes 1<br>12-23 18:46:12.250 28643-28658/? I/art: Background partial concurrent mark sweep GC freed 28723(1856KB) AllocSpace objects, 6(92KB) LOS objects, 11% free, 31MB/35MB, paused 2.380ms <strong>total 108.502ms</strong> at GCDaemon thread CareAboutPauseTimes 1</p>
</blockquote>
<p>上面的日志反映一个事实：GC是有代价的。有很多有关性能优化的文章提到GC，会花长篇大论讲述垃圾回收的过程以及原理，但所做的策略无非就是「不要创建不必要的对象」，「避免内存泄漏」最终就提到MAT，LeakCanary等工具的使用上去了；我只能说这很苍白无力——写出这样的代码、学会使用工具应该是基本要求。</p>
<a id="more"></a>
<p>虽说Android也支持NDK开发，但是我们不可能把所有代码全用C++重写吧？那么，我们有没有办法能<strong>影响GC的策略</strong>，使得GC尽量减少呢？答案是肯定的。原理在于Android的进程机制——每一个App都有一个单独的虚拟机实例，在App自己的进程空间，我们有相当大的主动权。</p>
<p>我举个简单的例子。（下面的内容基于Android 5.1系统，所有的原理以及代码不保证能在其他系统版本甚至ROM上工作）</p>
<p>Android上所有的App进程都从Zygote进程fork而来，App子进程采用copy on write机制共享了Zygote进程的进程空间；其中Android虚拟机以及运行时的创建在Android系统启动，创建Zygote进程的时候已经完成了。垃圾回收机制是虚拟机的一部分，因此，我们先从Zygote进程的启动过程谈起。</p>
<p>我们知道，Android系统是基于Linux内核的，而在Linux系统中，所有的进程都是init进程的子孙进程，Zygote进程也不例外，它是在系统启动的过程，由init进程创建的。在系统启动脚本system/core/rootdir/init.rc文件中，我们可以看到启动Zygote进程的脚本命令：</p>
<blockquote>
<p>service zygote /system/bin/app_process -Xzygote /system/bin –zygote –start-system-server</p>
</blockquote>
<p>也就是说init进程通过执行 /system/bin/app_process 这个可执行文件来创建zygote进程；app_process的源码可见 <a href="http://androidxref.com/5.1.1_r6/xref/frameworks/base/cmds/app_process/app_main.cpp" target="_blank" rel="external">这里</a>；在main函数的最后有这么一句话：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">    runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br></pre></td></tr></table></figure>
<p>最终调用到了<a href="http://androidxref.com/5.1.1_r6/xref/frameworks/base/core/jni/AndroidRuntime.cpp" target="_blank" rel="external">AndroidRuntime.cpp</a> 的<code>start</code>函数，而这个函数中最重要的一步就是启动虚拟机：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JNIEnv* env;</span><br><span class="line"><span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数相当之长，不过都是解析虚拟机启动的参数，比如堆大小等等；<a href="http://droidyue.com/blog/2015/08/01/dive-into-android-large-heap/index.html" target="_blank" rel="external">探究largeHeap</a> 这篇文章对一些重要的参数做了说明，这些参数对虚拟机非常重要，后面我们会见到。解析参数完毕之后，最终调用<code>JNI_CreateJavaVM</code>来真正创建Java虚拟机。这个接口是Android虚拟机定义的三个接口这一，dalvik能切换到art很大程度上与这个有关。它的具体是现在 <a href="http://androidxref.com/5.1.1_r6/xref/art/runtime/jni_internal.cc" target="_blank" rel="external">jni_internal.cc</a>；JNI_CreateJavaVM 这个函数在拿到虚拟机的相关参数之后，就直接创建了Android运行时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Runtime::Create(options, ignore_unrecognized)) &#123;</span><br><span class="line">  <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runtime的创建非常复杂，其中，跟GC相关的是，App的堆空间被创建出来了；Heap的构造函数接受了一大堆参数，这些参数对于GC有着重大的影响，如果要调整GC的策略，从这里入手，是比较靠谱的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">heap_ = <span class="keyword">new</span> gc::Heap(options-&gt;heap_initial_size_,</span><br><span class="line">                     options-&gt;heap_growth_limit_,</span><br><span class="line">                     options-&gt;heap_min_free_,</span><br><span class="line">                     options-&gt;heap_max_free_,</span><br><span class="line">                     options-&gt;heap_target_utilization_,</span><br><span class="line">                     options-&gt;foreground_heap_growth_multiplier_,</span><br><span class="line">                     options-&gt;heap_maximum_size_,</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>其中 heap_initial<em>size</em> 是堆的初始大小，heap_growth<em>limit</em>是堆增长的最大限制，heap_min<em>free</em>以及heap_max<em>free</em> 是什么呢？详细的用途见 <a href="http://hello2mao.github.io/2015/12/16/Android_ART_GC_GrowForUtilization.html" target="_blank" rel="external">Android ART GC之GrowForUtilization的分析</a> 简单来说就是，Android系统为了保证堆的利用效率，减少堆中的内存碎片；每次执行GC回收到一些内存之后，会对堆大小进行调整。比如说你进入了一个图片非常多的页面，这时候申请了100M内存，当你退出这个页面的时候，这100M自然就被回收了，成为了空闲内存；但是系统为了防止浪费，并不会把这100M的空闲内存全部留给你，而是做一个调整。而具体调整到多大，则与   <code>heap_min_free_</code>, <code>heap_max_free_</code> 以及 <code>heap_target_utilization_</code> 相关。</p>
<p>说到这里，原理性的部分已经解释完了；除了流程稍微复杂，也没有什么难点。那么这个堆，跟我们的启动性能优化有什么关系呢？</p>
<p>在Android App的启动过程中，进程占用的内存在一段时间内是持续上涨的；假设堆的初始大小为8M，启动过程中的占用内存峰值30M；启动过程的进行中，伴随着大量临时对象的创建，它们朝生夕死，不久就被回收掉：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1482494040946.png" width="446"></p>
<p>如上图，这是某次启动过程中某App的内存占用情况；我们看到了有很多小折线，专业术语叫做内存抖动；原因呢，也很明显——有大量的临时对象被创建。怎么解决？有人说，不要创建大量的临时对象。道理我都懂，可是做不到。对于很多大型App来说，启动的过程是相当复杂的，而很多操作也不能简单滴去掉。那么问题来了，30M并不是一个很大的数字，为什么系统如此恐慌，还需要不停滴回收内存呢？</p>
<p>有一种冷，叫做你妈妈觉得你冷。垃圾回收并不是说有垃圾了才去回收，而是只要系统觉得你需要回收垃圾就会进行。</p>
<p>那么，能不能在启动过程中让堆保持持续增长而不进行GC呢？毕竟，30M并不会造成什么OOM。是什么原因导致系统没有这么做？答案是空闲内存。比如说一开始堆有8M，随着启动过程的进行，堆增长到了24M；这时候执行了一次GC，回收掉了8M内存，也是堆回到了16M；我们还有8M的空闲内存。系统就会说，小伙子，你占这么多空闲内存干嘛呀？来妈妈帮你保管，于是你就只剩下2M的空闲内存了。但显然App使用的堆内存很快就会超过18M，于是又引发一系列GC以及堆大小调整，周而复始直至启动完成内存平稳。至此，我们的结论已经很明显：</p>
<p><strong>如果我们能够调整 heap_min<em>free</em> 以及 heap_max<em>free</em>，就能很大程度上影响GC的过程</strong></p>
<p>如何调整这两个参数的大小呢？<em>拿到Heap对象的指针，找到这两个参数的偏移量，直接修改内存即可</em> 这里稍微需要一点C++内存布局的知识；至于如何拿到Heap对象的指针，只有去源码里面寻找答案了。这里我给出最终的实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyHeap</span><span class="params">(<span class="keyword">unsigned</span> size)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// JavaVMExt指针 可以从JNI_OnLoad中拿到 </span></span><br><span class="line">	JavaVMExt * vmExt = (JavaVMExt *)g_javaVM;</span><br><span class="line">	<span class="keyword">if</span> (vmExt-&gt;runtime == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>* runtime_ptr = (<span class="keyword">char</span>*) vmExt-&gt;runtime;</span><br><span class="line">    <span class="keyword">void</span>** heap_pp = (<span class="keyword">void</span>**)(runtime_ptr + <span class="number">188</span>);</span><br><span class="line">    <span class="keyword">char</span>* c_heap = (<span class="keyword">char</span>*) (*heap_pp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* min_free_offset = c_heap + <span class="number">532</span>;</span><br><span class="line">    <span class="keyword">char</span>* max_free_offset = min_free_offset + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span>* target_utilization_offset = max_free_offset + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span>* min_free_ = (<span class="keyword">size_t</span>*) min_free_offset;</span><br><span class="line">    <span class="keyword">size_t</span>* max_free_ = (<span class="keyword">size_t</span>*) max_free_offset;</span><br><span class="line">    </span><br><span class="line">    *min_free_ = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>;</span><br><span class="line">    *max_free_ = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改之后启动过程中内存占用如下，可以看到我们的目的已经达到：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1482496070927.png" width="452"></p>
<p>顺便说明一下，上面的代码没有考虑任何的可移植性和适配性，只起演示作用。真正投入使用是一个体力活：其一，我们依赖了某特定Android版本某个类的内存布局，其中的成员变量的偏移量可能不同版本不同；其二，这个 min<em>free</em> 以及 max<em>free</em> 具体调整为多大，跟手机的物理内存，App使用的内存，手机配置的初始堆大小等等因素密切相关；调整一个合适的参数需要花费一些时间，Android机型如此之多，这里需要一些小技巧。</p>
<p>不知道上面这个例子有木有让你感受到深入系统底层，那种呼风唤雨无所不能的快感？可能很多人觉得我们都是写写if else而已，调节面改动画写业务已经够了；但我想说明的是，深入学习系统原理是非常有好处的，它可以赋予你在应用层永远无法拥有的能力。</p>
<p>另外留个作业，我们上面提到观察GC的次数，除了使用debug模式下用工具观察，能不能用代码监听到呢？本文主要说明了虚拟机运行时等native层的重要性，而这个答案可以在Java Framework中找到 ^_^</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>介绍完 <a href="https://zhuanlan.zhihu.com/p/24414378">深入学习Android：虚拟机&amp;运行时</a> 之后，很多小伙伴问我，你描述的这些知识结构看起来艰深晦涩高大上，实际工作中能有多大用途呢？今天我就简单举个例子。</p>
<p>众所周知，我们的Android App运行在Java虚拟机之上，而Java是一门带GC的语言。在虚拟机进行垃圾回收的时候，要做一件很形象的事叫做STW（stop the world）；也就是说，为了回收那些不再使用的对象，虚拟机必须要停止所有的线程来进行必要的工作。虽说这一点在ART运行时上得到了很大的改善，但是GC的存在对App运行时的性能始终有着微妙的影响。如果你观察过手机输入的日志，一定会看到类似如下的内容：</p>
<blockquote>
<p>12-23 18:46:07.300 28643-28658/? I/art: Background sticky concurrent mark sweep GC freed 15442(1400KB) AllocSpace objects, 8(128KB) LOS objects, 4% free, 32MB/33MB, paused 10.356ms total 53.023ms at GCDaemon thread CareAboutPauseTimes 1<br>12-23 18:46:12.250 28643-28658/? I/art: Background partial concurrent mark sweep GC freed 28723(1856KB) AllocSpace objects, 6(92KB) LOS objects, 11% free, 31MB/35MB, paused 2.380ms <strong>total 108.502ms</strong> at GCDaemon thread CareAboutPauseTimes 1</p>
</blockquote>
<p>上面的日志反映一个事实：GC是有代价的。有很多有关性能优化的文章提到GC，会花长篇大论讲述垃圾回收的过程以及原理，但所做的策略无非就是「不要创建不必要的对象」，「避免内存泄漏」最终就提到MAT，LeakCanary等工具的使用上去了；我只能说这很苍白无力——写出这样的代码、学会使用工具应该是基本要求。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="heap" scheme="http://weishu.me/tags/heap/"/>
    
      <category term="performance" scheme="http://weishu.me/tags/performance/"/>
    
      <category term="vm" scheme="http://weishu.me/tags/vm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[请不要滥用SharedPreference]]></title>
    <link href="http://weishu.me/2016/10/13/sharedpreference-advices/"/>
    <id>http://weishu.me/2016/10/13/sharedpreference-advices/</id>
    <published>2016-10-12T16:31:19.000Z</published>
    <updated>2016-10-12T16:59:48.000Z</updated>
    <content type="html"><![CDATA[<p>SharedPreference是Android上一种非常易用的轻量级存储方式，由于其API及其友好，得到了很多很多开发者的青睐。但是，SharedPreference并不是万能的，如果把它用在不合适的使用场景，那么将会带来灾难性的后果；本文将讲述一些SharedPreference的使用误区。</p>
<h2 id="存储超大的value">存储超大的value</h2><p>第一次看到下面这个sp的时候，我的内心是崩溃的：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1476286071563.png" width="664"></p>
<p>一个默认的sp有90K，当我打开它的时候，我都快哭了：除了零零星星的几个很小的key之外，存储了一个炒鸡大的key，这一个key至少占了其中的89K。知道这是什么概念吗？</p>
<p>在小米1S这种手机上，<strong>就算获取这个sp里面一个很小的key，会花费120+ms！！</strong>那个毫不相干的key拖慢了其他所有key的读取速度！当然，在性能稍好的手机上，这个问题不是特别严重。但是要知道，120ms这个是完全不能忍的！</p>
<p>之所以说SharedPreference（下文简称sp）是一种轻量级的存储方式，是它的设计所决定的：sp在创建的时候会把整个文件全部加载进内存，如果你的sp文件比较大，那么会带来两个严重问题：</p>
<ol>
<li>第一次从sp中获取值的时候，有可能阻塞主线程，使界面卡顿、掉帧。</li>
<li>解析sp的时候会产生大量的临时对象，导致频繁GC，引起界面卡顿。</li>
<li>这些key和value会永远存在于内存之中，占用大量内存。</li>
</ol>
<a id="more"></a>
<p>也许有童鞋会说，sp的加载不是在子线程么，怎么会卡住主线程？子线程IO就一定不会阻塞主线程吗？</p>
<p>下面是默认的sp实现SharedPreferenceImpl这个类的getString函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String key, @Nullable String defValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v = (String)mMap.get(key);</span><br><span class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看看这个awaitLoadedLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一把锁就是挂在那里！！这意味着，如果你直接调用getString，主线程会等待加载sp的那么线程加载完毕！这不就把主线程卡住了么？</p>
<p>另外，有一个叫诀窍可以节省一下等待的时间：既然getString之类的操作会等待sp加载完成，而加载是在另外一个线程执行的，我们可以让sp先去加载，做一堆事情，然后再getString！如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先让sp去另外一个线程加载</span></span><br><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">"test"</span>, MODE_PRIVATE);</span><br><span class="line"><span class="comment">// 做一堆别的事情</span></span><br><span class="line">setContentView(testSpJson);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OK,这时候估计已经加载完了吧,就算没完,我们在原本应该等待的时间也做了一些事!</span></span><br><span class="line">String testValue = sp.getString(<span class="string">"testKey"</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>更为严重的是，被加载进来的这些大对象，会永远存在于内存之中，不会被释放。我们看看ContextImpl这个类，在getSharedPreference的时候会把所有的sp放到一个静态变量里面缓存起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> (sSharedPrefsCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sSharedPrefsCache = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String packageName = getPackageName();</span><br><span class="line">    ArrayMap&lt;File, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);</span><br><span class="line">    <span class="keyword">if</span> (packagePrefs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        packagePrefs = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">        sSharedPrefsCache.put(packageName, packagePrefs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> packagePrefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个<strong>static</strong>的<code>sSharedPrefsCache</code>，它保存了你所有使用的sp，然后sp里面有一个成员<code>mMap</code>保存了所有的键值对；这样，你程序中使用到的那些个sp永远就呆在内存中，是不是不寒而栗？！</p>
<p>所以，<strong>请不要在sp里面存储炒鸡大的key</strong>碰到这样的猪队友，请让他自行检讨！！赶紧把自家App检查一下！！</p>
<h2 id="存储JSON等特殊符号很多的value">存储JSON等特殊符号很多的value</h2><p>还有一些童鞋，他在sp里面存json或者HTML；这么做不是不可以，但是，如果这个json相对较大，那么也会引起sp读取速度的急剧下降。</p>
<p>JSON或者HTML格式存放在sp里面的时候，需要转义，这样会带来很多<code>&amp;</code>这种特殊符号，sp在解析碰到这个特殊符号的时候会进行特殊的处理，引发额外的字符串拼接以及函数调用开销。而JSON本来就是可以用来做配置文件的，你干嘛又把它放在sp里面呢？多此一举。下面我写个demo验证一下。</p>
<p>下面这个sp是某个app的换肤配置：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1476282570956.png" width="696"></p>
<p>我们先用sp进行读取，然后用直接把它丢json文件，直接读取并且解析；json使用的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValueByJson</span><span class="params">(Context context, String key)</span> </span>&#123;</span><br><span class="line">    File jsonFile = <span class="keyword">new</span> File(context.getFilesDir().getParent() + File.separator + SP_DIR_NAME, <span class="string">"skin_beta2.json"</span>);</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    ByteArrayOutputStream bao = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(jsonFile);</span><br><span class="line">        FileChannel channel = fis.getChannel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1</span> &lt;&lt; <span class="number">13</span>); <span class="comment">// 8K</span></span><br><span class="line">        <span class="keyword">int</span> i1;</span><br><span class="line">        <span class="keyword">while</span> ((i1 = channel.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            bao.write(buffer.array(), <span class="number">0</span>, i1);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String content = bao.toString();</span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject(content);</span><br><span class="line">        <span class="keyword">return</span> jsonObject.getInt(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"not a json file"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        close(fis);</span><br><span class="line">        close(bao);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我的测试结果是：直接解析JSON比在xml里面要快一倍！在小米1S上结果如下：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>json</th>
<th>sp</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mi 1S</td>
<td>80</td>
<td>38</td>
</tr>
<tr>
<td>Nexus5X</td>
<td>3.5</td>
<td>6.5</td>
</tr>
</tbody>
</table>
<p>这个JSON的读取还没有做任何的优化，提升潜力巨大！因此，<strong>如果你需要用JSON做配置，请不要把它存放在sp里面！！</strong></p>
<h2 id="多次edit多次apply">多次edit多次apply</h2><p>我见过这样的使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sp = getSharedPreferences(<span class="string">"test"</span>, MODE_PRIVATE);</span><br><span class="line">sp.edit().putString(<span class="string">"test1"</span>, <span class="string">"sss"</span>).apply();</span><br><span class="line">sp.edit().putString(<span class="string">"test2"</span>, <span class="string">"sss"</span>).apply();</span><br><span class="line">sp.edit().putString(<span class="string">"test3"</span>, <span class="string">"sss"</span>).apply();</span><br><span class="line">sp.edit().putString(<span class="string">"test4"</span>, <span class="string">"sss"</span>).apply();</span><br></pre></td></tr></table></figure>
<p>每次edit都会创建一个Editor对象，额外占用内存；当然多创建几个对象也影响不了多少；但是，多次apply也会卡界面你造吗？</p>
<p>有童鞋会说，apply不是在别的线程些磁盘的吗，怎么可能卡界面？我带你仔细看一下源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mcr.writtenToDiskLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    QueuedWork.add(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.remove(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意两点，第一，把一个带有await的runnable添加进了<code>QueueWork</code>类的一个队列；第二，把这个写入任务通过enqueueDiskWrite丢给了一个<strong>只有单个线程</strong>的线程池执行。</p>
<p>到这里一切都OK，在子线程里面写入不会卡UI。但是，你去ActivityThread类的handleStopActivity里看一看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> show, <span class="keyword">int</span> configChanges, <span class="keyword">int</span> seq)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关。。</span></span><br><span class="line">    <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.isPreHoneycomb()) &#123;</span><br><span class="line">        QueuedWork.waitToFinish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>waitToFinish?? 又要等？源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitToFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Runnable toFinish;</span><br><span class="line">    <span class="keyword">while</span> ((toFinish = sPendingWorkFinishers.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        toFinish.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得这个<code>toFinish</code>的Runnable是啥吗？就是上面那个<code>awaitCommit</code>它里面就一句话，等待写入线程！！如果在Activity Stop的时候，已经写入完毕了，那么万事大吉，不会有任何等待，这个函数会立马返回。但是，如果你使用了太多次的apply，那么意味着写入队列会有很多写入任务，而那里就只有一个线程在写。当App规模很大的时候，这种情况简直就太常见了！</p>
<p>因此，虽然apply是在子线程执行的，但是请不要无节制地apply；commit我就不多说了吧？直接在当前线程写入，如果你在主线程干这个，小心挨揍。</p>
<h2 id="用来跨进程">用来跨进程</h2><p>还有童鞋发现sp有一个貌似可以提供「跨进程」功能的FLAG——<code>MODE_MULTI_PROCESS</code>,我们看看这个FLAG的文档：</p>
<blockquote>
<p>@deprecated MODE_MULTI_PROCESS does not work reliably in<br>some versions of Android, and furthermore does not provide any mechanism for reconciling concurrent modifications across processes.  Applications should not attempt to use it.  Instead, they should use an explicit cross-process data management approach such as {@link android.content.ContentProvider ContentProvider}.</p>
</blockquote>
<p>文档也说了，这玩意在某些Android版本上不可靠，并且未来也不会提供任何支持，要是用跨进程数据传输需要使用类似ContentProvider的东西。而且，SharedPreference的文档也特别说明：</p>
<blockquote>
<p>Note: This class does not support use across multiple processes.</p>
</blockquote>
<p>那么我们姑且看一看，设置了这个Flag到底干了啥；在SharedPreferenceImpl里面，没有发现任何对这个Flag的使用；然后我们去ContextImpl类里面找找getSharedPreference的时候做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getSharedPreferences</span><span class="params">(File file, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    checkMode(mode);</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    <span class="keyword">synchronized</span> (ContextImpl.class) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</span><br><span class="line">        sp = cache.get(file);</span><br><span class="line">        <span class="keyword">if</span> (sp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sp = <span class="keyword">new</span> SharedPreferencesImpl(file, mode);</span><br><span class="line">            cache.put(file, sp);</span><br><span class="line">            <span class="keyword">return</span> sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="number">0</span> ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        <span class="comment">// If somebody else (some other process) changed the prefs</span></span><br><span class="line">        <span class="comment">// file behind our back, we reload it.  This has been the</span></span><br><span class="line">        <span class="comment">// historical (if undocumented) behavior.</span></span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个flag保证了啥？保证了<strong>在API 11以前</strong>的系统上，如果sp已经被读取进内存，再次获取这个sp的时候，如果有这个flag，会重新读一遍文件，仅此而已！所以，如果仰仗这个Flag做跨进程存取，简直就是丢人现眼。</p>
<h2 id="小结">小结</h2><p>总价一下，sp是一种轻量级的存储方式，使用方便，但是也有它适用的场景。要优雅滴使用sp，要注意以下几点：</p>
<ol>
<li>不要存放大的key和value！我就不重复三遍了，会引起界面卡、频繁GC、占用内存等等，好自为之！</li>
<li>毫不相关的配置项就不要丢在一起了！文件越大读取越慢，不知不觉就被猪队友给坑了；蓝后，放进defalut的那个简直就是愚蠢行为！</li>
<li>读取频繁的key和不易变动的key尽量不要放在一起，影响速度。（如果整个文件很小，那么忽略吧，为了这点性能添加维护成本得不偿失）</li>
<li>不要乱edit和apply，尽量批量修改一次提交！</li>
<li>尽量不要存放JSON和HTML，这种场景请直接使用json！</li>
<li>不要指望用这货进行跨进程通信！！！ </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>SharedPreference是Android上一种非常易用的轻量级存储方式，由于其API及其友好，得到了很多很多开发者的青睐。但是，SharedPreference并不是万能的，如果把它用在不合适的使用场景，那么将会带来灾难性的后果；本文将讲述一些SharedPreference的使用误区。</p>
<h2 id="存储超大的value">存储超大的value</h2><p>第一次看到下面这个sp的时候，我的内心是崩溃的：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1476286071563.png" width="664"/></p>
<p>一个默认的sp有90K，当我打开它的时候，我都快哭了：除了零零星星的几个很小的key之外，存储了一个炒鸡大的key，这一个key至少占了其中的89K。知道这是什么概念吗？</p>
<p>在小米1S这种手机上，<strong>就算获取这个sp里面一个很小的key，会花费120+ms！！</strong>那个毫不相干的key拖慢了其他所有key的读取速度！当然，在性能稍好的手机上，这个问题不是特别严重。但是要知道，120ms这个是完全不能忍的！</p>
<p>之所以说SharedPreference（下文简称sp）是一种轻量级的存储方式，是它的设计所决定的：sp在创建的时候会把整个文件全部加载进内存，如果你的sp文件比较大，那么会带来两个严重问题：</p>
<ol>
<li>第一次从sp中获取值的时候，有可能阻塞主线程，使界面卡顿、掉帧。</li>
<li>解析sp的时候会产生大量的临时对象，导致频繁GC，引起界面卡顿。</li>
<li>这些key和value会永远存在于内存之中，占用大量内存。</li>
</ol>]]>
    
    </summary>
    
      <category term="-android" scheme="http://weishu.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android插件化原理解析——ContentProvider的插件化]]></title>
    <link href="http://weishu.me/2016/07/12/understand-plugin-framework-content-provider/"/>
    <id>http://weishu.me/2016/07/12/understand-plugin-framework-content-provider/</id>
    <published>2016-07-12T11:18:07.000Z</published>
    <updated>2016-07-13T03:39:43.000Z</updated>
    <content type="html"><![CDATA[<p>目前为止我们已经完成了Android四大组件中Activity，Service以及BroadcastReceiver的插件化，这几个组件各不相同，我们根据它们的特点定制了不同的插件化方案；那么对于ContentProvider，它又有什么特点？应该如何实现它的插件化？</p>
<p>与Activity，BroadcastReceiver等频繁被使用的组件不同，我们接触和使用ContentProvider的机会要少得多；但是，ContentProvider这个组件对于Android系统有着特别重要的作用——作为一种极其方便的<strong>数据共享</strong>的手段，ContentProvider使得广大第三方App能够在壁垒森严的系统中自由呼吸。</p>
<p>在Android系统中，每一个应用程序都有自己的用户ID，而每一个应用程序所创建的文件的读写权限都是只赋予给自己所属的用户，这就限制了应用程序之间相互读写数据的操作。应用程序之间如果希望能够进行交互，只能采取跨进程通信的方式；Binder机制能够满足一般的IPC需求，但是如果应用程序之间需要共享大量数据，单纯使用Binder是很难办到的——我相信大家对于Binder 1M缓冲区以及TransactionTooLargeException一定不陌生；ContentProvider使用了匿名共享内存(Ashmem)机制完成数据共享，因此它可以很方便地完成大量数据的传输。Android系统的短信，联系人，相册，媒体库等等一系列的基础功能都依赖与ContentProvider，它的重要性可见一斑。</p>
<p>既然ContentProvider的核心特性是数据共享，那么要实现它的插件化，必须能让插件能够把它的ContentProvider共享给系统——如果不能「<strong>provide content</strong>」那还叫什么ContentProvider？</p>
<p>但是，如果回想一下Activity等组件的插件化方式，在涉及到「共享」这个问题上，一直没有较好的解决方案：<br><a id="more"></a></p>
<ol>
<li>系统中的第三方App无法启动插件中带有特定IntentFilter的Activity，因为系统压根儿感受不到插件中这个真正的Activity的存在。</li>
<li>插件中的静态注册的广播并不真正是静态的，而是使用动态注册广播模拟实现的；这就导致如果宿主程序进程死亡，这个静态广播不会起作用；这个问题的根本原因在由于BroadcastReceiver的IntentFilter的不可预知性，使得我们没有办法把静态广播真正“共享”给系统。</li>
<li>我们没有办法在第三方App中启动或者绑定插件中的Service组件；因为插件的Service并不是真正的Service组件，系统能感知到的只是那个代理Service；因此如果插件如果带有远程Service组件，它根本不能给第三方App提供远程服务。</li>
</ol>
<p>虽然在插件系统中一派生机勃勃的景象，Activity，Service等插件组件百花齐放，插件与宿主、插件与插件争奇斗艳；但是一旦脱离了插件系统的温室，这一片和谐景象不复存在：插件组件不过是傀儡而已；活着的，只有宿主——整个插件系统就是一座死寂的鬼城，各个插件组件借尸还魂般地依附在宿主身上，了无生机。</p>
<p>既然希望把插件的ContentProvider共享给整个系统，让第三方的App都能获取到我们插件共享的数据，我们必须解决这个问题；下文将会围绕这个目标展开，完成ContentProvider的插件化，并且顺带给出上述问题的解决方案。阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的 contentprovider-management 模块。另外，插件框架原理解析系列文章见 <a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<h2 id="ContentProvider工作原理">ContentProvider工作原理</h2><p>首先我们还是得分析一下ContentProvider的工作原理，很多插件化的思路，以及一些Hook点的发现都严重依赖于对于系统工作原理的理解；对于ContentProvider的插件化，这一点特别重要。</p>
<h3 id="铺垫工作">铺垫工作</h3><p>如同我们通过<code>startActivity</code>来启动Activity一样，与ContentProvider打交道的过程也是从Context类的一个方法开始的，这个方法叫做<code>getContentResolver</code>，使用ContentProvider的典型代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver resolver = content.getContentResolver();</span><br><span class="line">resolver.query(Uri.parse(<span class="string">"content://authority/test"</span>), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>直接去ContextImpl类里面查找的<code>getContentResolver</code>实现，发现这个方法返回的类型是android.app.ContextImpl.ApplicationContentResolver，这个类是抽象类android.content.ContentResolver的子类，<code>resolver.query</code>实际上是调用父类ContentResolver的<code>query</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="annotation">@Nullable</span> <span class="function">Cursor <span class="title">query</span><span class="params">(<span class="keyword">final</span> @NonNull Uri uri, @Nullable String[] projection,</span><br><span class="line">        @Nullable String selection, @Nullable String[] selectionArgs,</span><br><span class="line">        @Nullable String sortOrder, @Nullable CancellationSignal cancellationSignal)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(uri, <span class="string">"uri"</span>);</span><br><span class="line">    IContentProvider unstableProvider = acquireUnstableProvider(uri);</span><br><span class="line">    <span class="keyword">if</span> (unstableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IContentProvider stableProvider = <span class="keyword">null</span>;</span><br><span class="line">    Cursor qCursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        ICancellationSignal remoteCancellationSignal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancellationSignal.throwIfCanceled();</span><br><span class="line">            remoteCancellationSignal = unstableProvider.createCancellationSignal();</span><br><span class="line">            cancellationSignal.setRemote(remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            qCursor = unstableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">            <span class="comment">// The remote process has died...  but we only hold an unstable</span></span><br><span class="line">            <span class="comment">// reference though, so we might recover!!!  Let's try!!!!</span></span><br><span class="line">            <span class="comment">// This is exciting!!1!!1!!!!1</span></span><br><span class="line">            unstableProviderDied(unstableProvider);</span><br><span class="line">            stableProvider = acquireProvider(uri);</span><br><span class="line">            <span class="keyword">if</span> (stableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            qCursor = stableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里面的那个<code>try..catch</code>语句，<code>query</code>方法首先尝试调用抽象方法acquireUnstableProvider拿到一个IContentProvider对象，并尝试调用这个”unstable”对象的<code>query</code>方法，万一调用失败（抛出DeadObjectExceptopn，熟悉Binder的应该了解这个异常）说明ContentProvider所在的进程已经死亡，这时候会尝试调用<code>acquireProvider</code>这个抽象方法来获取一个可用的IContentProvider（代码里面那个萌萌的注释说明了一切^_^）；由于这两个<code>acquire*</code>都是抽象方法，我们可以直接看子类<code>ApplicationContentResolver</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Context c, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(c,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(context,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这两个抽象方法最终都通过调用<code>ActivityThread</code>类的<code>acquireProvider</code>获取到IContentProvider，接下来我们看看到底是如何获取到ContentProvider的。</p>
<h3 id="ContentProvider获取过程">ContentProvider获取过程</h3><p>ActivityThread类的<code>acquireProvider</code>方法如下，我们需要知道的是，方法的最后一个参数<code>stable</code>代表着ContentProvider所在的进程是否存活，如果进程已死，可能需要在必要的时候唤起这个进程；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(</span><br><span class="line">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IActivityManager.ContentProviderHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        holder = ActivityManagerNative.getDefault().getContentProvider(</span><br><span class="line">                getApplicationThread(), auth, userId, stable);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Failed to find provider info for "</span> + auth);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    holder = installProvider(c, holder, holder.info,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/*noisy*/</span>, holder.noReleaseNeeded, stable);</span><br><span class="line">    <span class="keyword">return</span> holder.provider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法首先通过<code>acquireExistingProvider</code>尝试从本进程中获取ContentProvider，如果获取不到，那么再请求<code>AMS</code>获取对应ContentProvider；想象一下，如果你查询的是自己App内部的ContentProvider组件，干嘛要劳烦AMS呢？不论是从哪里获取到的ContentProvider，获取完毕之后会调用<code>installProvider</code>来安装ContentProvider。</p>
<p>OK打住，我们思考一下，如果要实现ContentProvider的插件化，我们需要完成一些什么工作？开篇的时候我提到了数据共享，那么具体来说，实现插件的数据共享，需要完成什么？ContentProvider是一个数据共享组件，也就是说它不过是<strong>一个携带数据的载体而已</strong>。为了支持跨进程共享，这个载体是<strong>Binder调用</strong>，为了共享大量数据，使用了匿名共享内存；这么说还是有点抽象，那么想一下，给出一个ContentProvider，你能对它做一些什么操作？如果能让插件支持这些操作，不就支持了插件化么？这就是典型的duck type思想——如果一个东西看起来像ContentProvider，用起来也像ContentProvider，那么它就是ContentProvider。</p>
<p>ContentProvider主要支持<code>query, insert, update, delete</code>操作，由于这个组件一般工作在别的进程，因此这些调用都是Binder调用。从上面的代码可以看到，这些调用最终都是委托给一个IContentProvider的Binder对象完成的，如果我们Hook掉这个对象，那么对于ContentProvider的所有操作都会被我们拦截掉，这时候我们可以做进一步的操作来完成对于插件ContentProvider组件的支持。要拦截这个过程，我们可以<strong>假装插件的ContentProvider是自己App的ContentProvider</strong>，也就是说，让<code>acquireExistingProvider</code>方法可以直接获取到插件的ContentProvider，这样我们就不需要欺骗AMS就能完成插件化了。当然，你也可以选择Hook掉AMS，让AMS的<code>getContentProvider</code>方法返回被我们处理过的对象，这也是可行的；但是，为什么要舍近求远呢？</p>
<p>从上文的分析暂时得出结论：我们可以把插件的ContentProvider信息预先放在App进程内部，使得对于ContentProvider执行CURD操作的时候，可以获取到插件的组件，这样或许就可以实现插件化了。具体来说，我们要做的事情就是让<code>ActivityThread</code>的<code>acquireExistingProvider</code>方法能够返回插件的ContentProvider信息，我们看看这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireExistingProvider</span><span class="params">(</span><br><span class="line">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProviderKey key = <span class="keyword">new</span> ProviderKey(auth, userId);</span><br><span class="line">        <span class="keyword">final</span> ProviderClientRecord pr = mProviderMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 略。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，App内部自己的ContentProvider信息保存在ActivityThread类的<code>mProviderMap</code>中，这个map的类型是ArrayMap<providerkey, providerclientrecord="">；我们当然可以通过反射修改这个成员变量，直接把插件的ContentProvider信息填进去，但是这个ProviderClientRecord对象如何构造？我们姑且看看系统自己是如果填充这个字段的。在ActivityThread类中搜索一遍，发现调用mProviderMap对象的<code>put</code>方法的之后<code>installProviderAuthoritiesLocked</code>，而这个方法最终被<code>installProvider</code>方法调用。在分析ContentProvider的获取过程中我们已经知道，不论是通过本进程的<code>acquireExistingProvider</code>还是借助AMS的<code>getContentProvider</code>得到ContentProvider，最终都会对这个对象执行<code>installProvider</code>操作，也就是「安装」在本进程内部。那么，我们接着看这个<code>installProvider</code>做了什么，它是如何「安装」ContentProvider的。</providerkey,></p>
<h3 id="进程内部ContentProvider安装过程">进程内部ContentProvider安装过程</h3><p>首先，如果之前没有“安装”过，那么holder为null，下面的代码会被执行，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">localProvider = (ContentProvider)cl.</span><br><span class="line">    loadClass(info.name).newInstance();</span><br><span class="line">provider = localProvider.getIContentProvider();</span><br><span class="line"><span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Slog.e(TAG, <span class="string">"Failed to instantiate class "</span> +</span><br><span class="line">          info.name + <span class="string">" from sourceDir "</span> +</span><br><span class="line">          info.applicationInfo.sourceDir);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(</span><br><span class="line">    TAG, <span class="string">"Instantiating local provider "</span> + info.name);</span><br><span class="line"><span class="comment">// <span class="label">XXX Need to create the correct context for this provider.</span></span></span><br><span class="line">localProvider.attachInfo(c, info);</span><br></pre></td></tr></table></figure>
<p>比较直观，直接load这个ContentProvider所在的类，然后用反射创建出这个ContentProvider对象；但是由于查询是需要进行跨进程通信的，在本进程创建出这个对象意义不大，所以我们需要取出ContentProvider承载跨进程通信的Binder对象IContentProvider；创建出对象之后，接下来就是构建合适的信息，保存在ActivityThread内部，也就是<code>mProviderMap</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (localProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ComponentName cname = <span class="keyword">new</span> ComponentName(info.packageName, info.name);</span><br><span class="line">    ProviderClientRecord pr = mLocalProvidersByName.get(cname);</span><br><span class="line">    <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">"installProvider: lost the race, "</span></span><br><span class="line">                    + <span class="string">"using existing local provider"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        provider = pr.mProvider;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        holder = <span class="keyword">new</span> IActivityManager.ContentProviderHolder(info);</span><br><span class="line">        holder.provider = provider;</span><br><span class="line">        holder.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">        pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class="line">        mLocalProviders.put(jBinder, pr);</span><br><span class="line">        mLocalProvidersByName.put(cname, pr);</span><br><span class="line">    &#125;</span><br><span class="line">    retHolder = pr.mHolder;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>
<p>以上就是安装代码，不难理解。</p>
<h3 id="思路尝试——本地安装">思路尝试——本地安装</h3><p>那么，了解了「安装」过程再结合上文的分析，我们似乎可以完成ContentProvider的插件化了——直接把插件的ContentProvider安装在进程内部就行了。如果插件系统有多个进程，那么必须在每个进程都「安装」一遍，如果你熟悉Android进程的启动流程那么就会知道，这个安装ContentProvider的过程适合放在Application类中，因为每个Android进程启动的时候，App的Application类是会被启动的。</p>
<p>看起来实现ContentProvider的思路有了，但是这里实际上有一个严重的缺陷！</p>
<p>我们依然没有解决「共享」的问题。我们只是在插件系统启动的进程里面的ActivityThread的<code>mProviderMap</code>给修改了，这使得只有通过插件系统启动的进程，才能感知到插件中的ContentProvider(因为我们手动把插件中的信息install到这个进程中去了)；如果第三方的App想要使用插件的ContentProvider，那系统只会告诉它查无此人。</p>
<p>那么，我们应该如何解决共享这个问题呢？看来还是逃不过AMS的魔掌，我们继续跟踪源码，看看如果在本进程查询不到ContentProvider，AMS是如何完成这个过程的。在ActivityThread的<code>acquireProvider</code>方法中我们提到，如果<code>acquireExistingProvider</code>方法返回null，会调用ActivityManagerNative的<code>getContentProvider</code>方法通过AMS查询整个系统中是否存在需要的这个ContentProvider。如果第三方App查询插件系统的ContentProvider必然走的是这个流程，我们仔细分析一下这个过程；</p>
<h3 id="AMS中的ContentProvider">AMS中的ContentProvider</h3><p>首先我们查阅ActivityManagerService的<code>getContentProvider</code>方法，这个方法间接调用了<code>getContentProviderImpl</code>方法；<code>getContentProviderImpl</code>方法体相当的长，但是实际上只做了两件事件事（我这就不贴代码了，读者可以对着源码看一遍）：</p>
<ol>
<li>使用PackageManagerService的resolveContentProvider根据Uri中提供的auth信息查阅对应的ContentProivoder的信息ProviderInfo。</li>
<li>根据查询到的ContentProvider信息，尝试将这个ContentProvider组件安装到系统上。</li>
</ol>
<h4 id="查询ContentProvider组件的过程">查询ContentProvider组件的过程</h4><p>查询ContentProvider组件的过程看起来很简单，直接调用PackageManager的<code>resolveContentProvider</code>就能从URI中获取到对应的<code>ProviderInfo</code>信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProviderInfo <span class="title">resolveContentProvider</span><span class="params">(String name, <span class="keyword">int</span> flags, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// reader</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="keyword">final</span> PackageParser.Provider provider = mProvidersByAuthority.get(name);</span><br><span class="line">        PackageSetting ps = provider != <span class="keyword">null</span></span><br><span class="line">                ? mSettings.mPackages.get(provider.owner.packageName)</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> ps != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mSettings.isEnabledLPr(provider.info, flags, userId)</span><br><span class="line">                &amp;&amp; (!mSafeMode || (provider.info.applicationInfo.flags</span><br><span class="line">                        &amp;ApplicationInfo.FLAG_SYSTEM) != <span class="number">0</span>)</span><br><span class="line">                ? PackageParser.generateProviderInfo(provider, flags,</span><br><span class="line">                        ps.readUserState(userId), userId)</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是实际上我们关心的是，这个<code>mProvidersByAuthority</code>里面的信息是如何添加进PackageManagerService的，会在什么时候更新？在PackageManagerService这个类中搜索mProvidersByAuthority.put这个调用，会发现在<code>scanPackageDirtyLI</code>会更新<code>mProvidersByAuthority</code>这个map的信息，接着往前追踪会发现：<strong>这些信息是在Android系统启动的时候收集的</strong>。也就是说，Android系统在启动的时候会扫描一些App的安装目录，典型的比如/data/app/*，获取这个目录里面的apk文件，读取其AndroidManifest.xml中的信息，然后把这些信息保存在PackageManagerService中。合理猜测，在系统启动之后，安装新的App也会触发对新App中AndroidManifest.xml的操作，感兴趣的读者可以自行翻阅源码。</p>
<p>现在我们知道，查询ContentProvider的信息来源在Android系统启动的时候已经初始化好了，这个过程对于我们第三方app来说是鞭长莫及，想要使用类似在进程内部Hack ContentProvider的查找过程是不可能的。</p>
<h4 id="安装ContentProvider组件的过程">安装ContentProvider组件的过程</h4><p>获取到URI对应的ContentProvider的信息之后，接下来就是把它安装到系统上了，这样以后有别的查询操作就可以直接拿来使用；但是这个安装过程AMS是没有办法以一己之力完成的。想象一下App DemoA 查询App DemoB 的某个ContentProviderAppB，那么这个ContentProviderAppB必然存在于DemoB这个App中，AMS所在的进程(system_server)连这个ContentProviderAppB的类都没有，因此，AMS必须委托DemoB完成它的ContentProviderAppB的安装；这里就分两种情况：其一，DemoB这个App已经在运行了，那么AMS直接通知DemoB安装ContentProviderAppB（如果B已经安装了那就更好了）；其二，DemoB这个app没在运行，那么必须把B进程唤醒，让它干活；这个过程也就是ActivityManagerService的<code>getContentProviderImpl</code>方法所做的，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (proc != <span class="keyword">null</span> &amp;&amp; proc.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proc.pubProviders.containsKey(cpi.name)) &#123;</span><br><span class="line">        proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    proc = startProcessLocked(cpi.processName,</span><br><span class="line">            cpr.appInfo, <span class="keyword">false</span>, <span class="number">0</span>, <span class="string">"content provider"</span>,</span><br><span class="line">            <span class="keyword">new</span> ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                    cpi.name), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果查询的ContentProvider所在进程处于运行状态，那么AMS会通过这个进程给AMS的ApplicationThread这个Binder对象完成scheduleInstallProvider调用，这个过程比较简单，最终会调用到目标进程的<code>installProvider</code>方法，而这个方法我们在上文已经分析过了。我们看一下如果目标进程没有启动，会发生什么情况。</p>
<p>如果ContentProvider所在的进程已经死亡，那么会调用startProcessLocked来启动新的进程，<code>startProcessLocked</code>有一系列重载函数，我们一路跟踪，发现最终启动进程的操作交给了<code>Process</code>类的<code>start</code>方法完成，这个方法通过socket与Zygote进程进行通信，通知Zygote进程fork出一个子进程，然后通过反射调用了之前传递过来的一个入口类的main函数，一般来说这个入口类就是ActivityThread，因此子进程fork出来之后会执行ActivityThread类的main函数。</p>
<p>在我们继续观察子进程ActivityThread的main函数执行之前，我们看看AMS进程这时候会干什么——startProcessLocked之后AMS进程和fork出来的DemoB进程分道扬镳；AMS会继续往下面执行。我们暂时回到AMS的<code>getContentProviderImpl</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait for the provider to be published...</span></span><br><span class="line"><span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">    <span class="keyword">while</span> (cpr.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cpr.launchingApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.waiting = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cpr.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.waiting = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你没看错，一个死循环就是糊在上面：AMS进程会通过一个死循环等到进程B完成ContentProvider的安装，等待完成之后会把ContentProvider的信息返回给进程A。那么，我们现在的疑惑是，<strong>进程B在启动之后，在哪个时间点会完成ContentProvider的安装呢？</strong> </p>
<p>我们接着看ActivityThread的main函数，顺便寻找我们上面那个问题的答案；这个分析实际上就是Android App的启动过程，更详细的过程可以参阅老罗的文章 <a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="external">Android应用程序启动过程源代码分析</a>，这里只给出简要调用流程：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201605/1468313182087.png" alt="App启动简要流程"></p>
<p>最终，DemoB进程启动之后会执行ActivityThread类的handleBindApplication方法，这个方法相当之长，基本完成了App进程启动之后所有必要的操作；这里我们只关心ContentProvider相关的初始化操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class="line"><span class="comment">// a restricted environment with the base application class.</span></span><br><span class="line">Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">mInitialApplication = app;</span><br><span class="line"></span><br><span class="line"><span class="comment">// don't bring up providers in restricted mode; they may depend on the</span></span><br><span class="line"><span class="comment">// app's custom Application class</span></span><br><span class="line"><span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providers = data.providers;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        installContentProviders(app, providers);</span><br><span class="line">        <span class="comment">// For process that contains content providers, we want to</span></span><br><span class="line">        <span class="comment">// ensure that the JIT is enabled "at some point".</span></span><br><span class="line">        mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class="line"><span class="comment">// test thread at this point, and we don't want that racing.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细观察以上代码，你会发现：<strong>ContentProvider的安装比Application的onCreate回调还要早！！</strong>因此，分析到这里我们已经明白了前面提出的那个问题，<strong>进程启动之后会在Applition类的onCreate 回调之前，在Application对象创建之后完成ContentProvider的安装</strong>。</p>
<p>然后不要忘了，我们的AMS进程还在那傻傻等待DemoB进程完成ContentProviderAppB的安装呢！在DemoB的Application的onCreate回调之前，DemoB的ContentProviderAppB已经安装好了，因此AMS停止等待，把DemoB安装的结果返回给请求这个ContentProvider的DemoA。我们必须对这个时序保持敏感，有时候就是失之毫厘，差之千里！！</p>
<p>到这里，有关ContentProvider的调用过程以及简要的工作原理我们已经分析完毕，关于它如何共享数据，如何使用匿名共享内存这部分不是插件化的重点，感兴趣的可以参考 <a href="http://blog.csdn.net/luoshengyang/article/details/6967204" target="_blank" rel="external">Android应用程序组件Content Provider在应用程序之间共享数据的原理分析</a>。</p>
<h2 id="不同之处">不同之处</h2><p>在实现ContentProvider的插件化之前，通过分析这个组件的工作原理，我们可以得出它的一些与众不同的特性：</p>
<ol>
<li>ContentProvider本身是用来共享数据的，因此它提供一般的CURD服务；它类似HTTP这种无状态的服务，没有Activity，Service所谓的生命周期的概念，服务要么可用，要么不可用；对应着ContentProvider要么启动，要么随着进程死亡；而通常情况下，死亡之后还会被系统启动。所以，ContentProvider，只要有人需要这个服务，系统可以保证是永生的；这是与其他组件的最大不同；完全不用考虑生命周期的概念。</li>
<li>ContentProvider被设计为共享数据，这种数据量一般来说是相当大的；熟悉Binder的人应该知道，Binder进行数据传输有1M限制，因此如果要使用Binder传输大数据，必须使用类似socket的方式一段一段的读，也就是说需要自己在上层架设一层协议；ContentProvider并没有采取这种方式，而是采用了Android系统的匿名共享内存机制，利用Binder来传输这个文件描述符，进而实现文件的共享；这是第二个不同，因为其他的三个组建通信都是基于Binder的，只有ContentProvider使用了Ashmem。</li>
<li>一个App启动过程中，ContentProvider组件的启动是非常早的，甚至比Application的onCreate还要早；我们可以利用这个特性结合它不死的特点，完成一些有意义的事情。</li>
<li>ContentProvider存在优先查询本进程的特点，使得它的插件化甚至不需要Hook AMS就能完成。</li>
</ol>
<h2 id="思路分析">思路分析</h2><p>在分析ContentProvider的工作原理的过程中我们提出了一种插件化方案：在进程启动之初，手动把ContentProvider安装到本进程，使得后续对于插件ContentProvider的请求能够顺利完成。我们也指出它的一个严重缺陷，那就是它只能在插件系统内部掩耳盗铃，在插件系统之外，第三方App依然无法感知到插件中的ContentProvider的存在。</p>
<p>如果插件的ContentProvider组件仅仅是为了共享给其他插件或者宿主程序使用，那么这种方案可以解决问题；不需要Hook AMS，非常简单。</p>
<p>但是，如果希望把插件ContenProvider共享给整个系统呢？在分析AMS中获取ContentProvider的过程中我们了解到，ContentProvider信息的注册是在Android系统启动或者新安装App的时候完成的，而AMS把ContentProvider返回给第三方App也是在system_server进程完成；我们无法对其暗箱操作。</p>
<p>在完成Activity，Service组件的插件化之后，这种限制对我们来说已经是小case了：我们在宿主程序里面注册一个货真价实、被系统认可的StubContentProvider组件，把这个组件共享给第三方App；然后通过<strong>代理分发技术</strong>把第三方App对于插件ContentProvider的请求通过这个StubContentProvider分发给对应的插件。</p>
<p>但是这还存在一个问题，由于第三方App查阅的其实是StubContentProvider，因此他们查阅的URI也必然是StubContentProvider的authority，要查询到插件的ContentProvider，必须把要查询的真正的插件ContentProvider信息传递进来。这个问题的解决方案也很容易，我们可以制定一个「插件查询协议」来实现。</p>
<p>举个例子，假设插件系统的宿主程序在AndroidManifest.xml中注册了一个StubContentProvider，它的Authority为<code>com.test.host_authority</code>；由于这个组件被注册在AndroidManifest.xml中，是系统认可的ContentProvider组件，整个系统都是可以使用这个共享组件的，使用它的URI一般为<code>content://com.test.host_authority</code>；那么，如果插件系统中存在一个插件，这个插件提供了一个PluginContentProvider，它的Authority为<code>com.test.plugin_authorith</code>，因为这个插件的PluginContentProvider没有在宿主程序的AndroidMainifest.xml中注册（预先注册就失去插件的意义了），整个系统是无法感知到它的存在的；前面提到代理分发技术，也就是，我们让第三方App请求宿主程序的StubContentProvider，这个StubContentProvider把请求转发给合适的插件的ContentProvider就能完成了(插件内部通过预先installProvider可以查询所有的ContentProvider组件)；这个协议可以有很多，比如说：如果第三方App需要请求插件的StubContentProvider，可以以<code>content://com.test.host_authority/com.test.plugin_authorith</code>去查询系统；也就是说，我们假装请求StubContentProvider，把真正的需要请求的PluginContentProvider的Authority放在路径参数里面，StubContentProvider收到这个请求之后，拿到这个真正的Authority去请求插件的PluginContentProvider，拿到结果之后再返回给第三方App。</p>
<p>这样，我们通过「代理分发技术」以及「插件查询协议」可以完美解决「共享」的问题，开篇提到了我们之前对于Activity，Service组件插件化方案中对于「共享」功能的缺失，按照这个思路，基本可以解决这一系列问题。比如，对于第三方App无法绑定插件服务的问题，我们可以注册一个StubService，把真正需要bind的插件服务信息放在intent的某个字段中，然后在StubService的onBind中解析出这个插件服务信息，然后去拿到插件Service组件的Binder对象返回给第三方。</p>
<h2 id="实现">实现</h2><p>上文详细分析了如何实现ContentProvider的插件化，接下来我们就实现这个过程。</p>
<h3 id="预先installProvider">预先installProvider</h3><p>要实现预先installProvider，我们首先需要知道，所谓的「预先」到底是在什么时候？</p>
<p>前文我们提到过App进程安装ContentProvider的时机非常之早，在Application类的onCreate回调执行之前已经完成了；这意味着什么？</p>
<p>现在我们对于ContentProvider插件化的实现方式是通过「代理分发技术」，也就是说在请求插件ContentProvider的时候会先请求宿主程序的StubContentProvider；如果一个第三方App查询插件的ContentProvider，而宿主程序没有启动的话，AMS会启动宿主程序并等待宿主程序的StubContentProvider完成安装，<strong>一旦安装完成就会把得到的IContentProvider返回给这个第三方App</strong>；第三方App拿到IContentProvider这个Binder对象之后就可能发起CURD操作，如果这个时候插件ContentProvider还没有启动，那么肯定就会出异常；要记住，“这个时候”可能宿主程序的onCreate还没有执行完毕呢！！</p>
<p>所以，我们基本可以得出结论，预先安装这个所谓的「预先」必须早于Application的onCreate方法，在Android SDK给我们的回调里面，attachBaseContent这个方法是可以满足要求的，它在Application这个对象被创建之后就会立即调用。</p>
<p>解决了时机问题，那么我们接下来就可以安装ContentProvider了。</p>
<p>安装ContentProvider也就是要调用ActivityThread类的<code>installProvider</code>方法，这个方法需要的参数有点多，而且它的第二个参数IActivityManager.ContentProviderHolder是一个隐藏类，我们不知道如何构造，就算通过反射构造由于SDK没有暴露稳定性不易保证，我们看看有什么方法调用了这个installProvider。</p>
<p>installContentProviders这个方法直接调用installProvder看起来可以使用，但是它是一个private的方法，还有public的方法吗？继续往上寻找调用链，发现了installSystemProviders这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">installSystemProviders</span><span class="params">(List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        installContentProviders(mInitialApplication, providers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，我们说过ContentProvider的安装必须相当早，必须在Application类的attachBaseContent方法内，而这个<code>mInitialApplication</code>字段是在<code>onCreate</code>方法调用之后初始化的，所以，如果直接使用这个<code>installSystemProviders</code>势必抛出空指针异常；因此，我们只有退而求其次，选择<strong>通过installContentProviders这个方法完成ContentProvider的安装</strong></p>
<p>要调用这个方法必须拿到ContentProvider对应的ProviderInfo，这个我们在之前也介绍过，可以通过PackageParser类完成，当然这个类有一些兼容性问题，我们需要手动处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析Apk文件中的 &lt;provider&gt;, 并存储起来</span><br><span class="line"> * 主要是调用PackageParser类的generateProviderInfo方法</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> apkFile 插件对应的apk文件</span><br><span class="line"> * <span class="doctag">@throws</span> Exception 解析出错或者反射调用出错, 均会抛出异常</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ProviderInfo&gt; <span class="title">parseProviders</span><span class="params">(File apkFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; packageParserClass = Class.forName(<span class="string">"android.content.pm.PackageParser"</span>);</span><br><span class="line">    Method parsePackageMethod = packageParserClass.getDeclaredMethod(<span class="string">"parsePackage"</span>, File.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    Object packageParser = packageParserClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调用parsePackage获取到apk对象对应的Package对象</span></span><br><span class="line">    Object packageObj = parsePackageMethod.invoke(packageParser, apkFile, PackageManager.GET_PROVIDERS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取Package对象里面的services字段</span></span><br><span class="line">    <span class="comment">// 接下来要做的就是根据这个List&lt;Provider&gt; 获取到Provider对应的ProviderInfo</span></span><br><span class="line">    Field providersField = packageObj.getClass().getDeclaredField(<span class="string">"providers"</span>);</span><br><span class="line">    List providers = (List) providersField.get(packageObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用generateProviderInfo 方法, 把PackageParser.Provider转换成ProviderInfo</span></span><br><span class="line">    Class&lt;?&gt; packageParser$ProviderClass = Class.forName(<span class="string">"android.content.pm.PackageParser$Provider"</span>);</span><br><span class="line">    Class&lt;?&gt; packageUserStateClass = Class.forName(<span class="string">"android.content.pm.PackageUserState"</span>);</span><br><span class="line">    Class&lt;?&gt; userHandler = Class.forName(<span class="string">"android.os.UserHandle"</span>);</span><br><span class="line">    Method getCallingUserIdMethod = userHandler.getDeclaredMethod(<span class="string">"getCallingUserId"</span>);</span><br><span class="line">    <span class="keyword">int</span> userId = (Integer) getCallingUserIdMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">    Object defaultUserState = packageUserStateClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要调用 android.content.pm.PackageParser#generateProviderInfo</span></span><br><span class="line">    Method generateProviderInfo = packageParserClass.getDeclaredMethod(<span class="string">"generateProviderInfo"</span>,</span><br><span class="line">            packageParser$ProviderClass, <span class="keyword">int</span>.class, packageUserStateClass, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    List&lt;ProviderInfo&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 解析出intent对应的Provider组件</span></span><br><span class="line">    <span class="keyword">for</span> (Object service : providers) &#123;</span><br><span class="line">        ProviderInfo info = (ProviderInfo) generateProviderInfo.invoke(packageParser, service, <span class="number">0</span>, defaultUserState, userId);</span><br><span class="line">        ret.add(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析出ProviderInfo之后，就可以直接调用installContentProvider了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 在进程内部安装provider, 也就是调用 ActivityThread.installContentProviders方法</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> context you know</span><br><span class="line"> * <span class="doctag">@param</span> apkFile</span><br><span class="line"> * <span class="doctag">@throws</span> Exception</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installProviders</span><span class="params">(Context context, File apkFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providerInfos = parseProviders(apkFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo providerInfo : providerInfos) &#123;</span><br><span class="line">        providerInfo.applicationInfo.packageName = context.getPackageName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.d(<span class="string">"test"</span>, providerInfos.toString());</span><br><span class="line">    Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">    Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">    Method installProvidersMethod = activityThreadClass.getDeclaredMethod(<span class="string">"installContentProviders"</span>, Context.class, List.class);</span><br><span class="line">    installProvidersMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    installProvidersMethod.invoke(currentActivityThread, context, providerInfos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个安装过程<strong>必须在Application类的attachBaseContent里面完成</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 一定需要Application，并且在attachBaseContext里面Hook</span><br><span class="line"> * 因为provider的初始化非常早，比Application的onCreate还要早</span><br><span class="line"> * 在别的地方hook都晚了。</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> weishu</span><br><span class="line"> * <span class="doctag">@date</span> 16/3/29</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UPFApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File apkFile = getFileStreamPath(<span class="string">"testcontentprovider-debug.apk"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!apkFile.exists()) &#123;</span><br><span class="line">                Utils.extractAssets(base, <span class="string">"testcontentprovider-debug.apk"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            File odexFile = getFileStreamPath(<span class="string">"test.odex"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hook ClassLoader, 让插件中的类能够被成功加载</span></span><br><span class="line">            BaseDexClassLoaderHookHelper.patchClassLoader(getClassLoader(), apkFile, odexFile);</span><br><span class="line">            ProviderHelper.installProviders(base, getFileStreamPath(<span class="string">"testcontentprovider-debug.apk"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"hook failed"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代理分发以及协议解析">代理分发以及协议解析</h3><p>把插件中的ContentProvider安装到插件系统中之后，在插件内部就可以自由使用这些ContentProvider了；要把这些插件共享给整个系统，我们还需要一个货真价实的ContentProvider组件来执行分发：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">provider</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.example.weishu.contentprovider_management.StubContentProvider"</span></span><br><span class="line">    <span class="attribute">android:authorities</span>=<span class="value">"com.example.weishu.contentprovider_management.StubContentProvider"</span></span><br><span class="line">    <span class="attribute">android:process</span>=<span class="value">":p"</span></span><br><span class="line">    <span class="attribute">android:exported</span>=<span class="value">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>第三方App如果要查询到插件的ContentProvider，必须遵循一个「插件查询协议」，这样StubContentProvider才能把对于插件的请求分发到正确的插件组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 为了使得插件的ContentProvder提供给外部使用，我们需要一个StubProvider做中转；</span><br><span class="line"> * 如果外部程序需要使用插件系统中插件的ContentProvider，不能直接查询原来的那个uri</span><br><span class="line"> * 我们对uri做一些手脚，使得插件系统能识别这个uri；</span><br><span class="line"> *</span><br><span class="line"> * 这里的处理方式如下：</span><br><span class="line"> *</span><br><span class="line"> * 原始查询插件的URI应该为：</span><br><span class="line"> * content://plugin_auth/path/query</span><br><span class="line"> *</span><br><span class="line"> * 如果需要查询插件，需要修改为：</span><br><span class="line"> *</span><br><span class="line"> * content://stub_auth/plugin_auth/path/query</span><br><span class="line"> *</span><br><span class="line"> * 也就是，我们把插件ContentProvider的信息放在URI的path中保存起来；</span><br><span class="line"> * 然后在StubProvider中做分发。</span><br><span class="line"> *</span><br><span class="line"> * 当然，也可以使用QueryParamerter,比如：</span><br><span class="line"> * content://plugin_auth/path/query/ -&gt;  content://stub_auth/path/query?plugin=plugin_auth</span><br><span class="line"> * <span class="doctag">@param</span> raw 外部查询我们使用的URI</span><br><span class="line"> * <span class="doctag">@return</span> 插件真正的URI</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Uri <span class="title">getRealUri</span><span class="params">(Uri raw)</span> </span>&#123;</span><br><span class="line">    String rawAuth = raw.getAuthority();</span><br><span class="line">    <span class="keyword">if</span> (!AUTHORITY.equals(rawAuth)) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"rawAuth:"</span> + rawAuth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String uriString = raw.toString();</span><br><span class="line">    uriString = uriString.replaceAll(rawAuth + <span class="string">'/'</span>, <span class="string">""</span>);</span><br><span class="line">    Uri newUri = Uri.parse(uriString);</span><br><span class="line">    Log.i(TAG, <span class="string">"realUri:"</span> + newUri);</span><br><span class="line">    <span class="keyword">return</span> newUri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上过程我们就实现了ContentProvider的插件化。需要说明的是，DroidPlugind的插件化与上述介绍的方案有一些不同之处：</p>
<ol>
<li>首先DroidPlugin并没有选择预先安装的方案，而是选择Hook ActivityManagerNative，拦截它的getContentProvider以及publishContentProvider方法实现对于插件组件的控制；从这里可以看出它对ContentProvider与Service的插件化几乎是相同的，Hook才是DroidPlugin Style ^_^.</li>
<li>然后，关于携带插件信息，或者说「插件查询协议」方面；DroidPlugin把插件信息放在查询参数里面，本文呢则是路径参数；这一点完全看个人喜好。</li>
</ol>
<h2 id="小结">小结</h2><p>本文我们通过「代理分发技术」以及「插件查询协议」完成了ContentProvider组件的插件化，并且给出了对「插件共享组件」的问题的一般解决方案。值得一提的是，系统的ContentProvider其实是lazy load的，也就是说只有在需要使用的时候才会启动对应的ContentProvider，而我们对于插件的实现则是<strong>预先加载</strong>，这里还有改进的空间，读者可以思考一下解决方案。</p>
<p>由于ContentProvider的使用频度非常低，而很多它使用的场景（比如系统）并不太需要「插件化」，因此在实际的插件方案中，提供ContentProvider插件化的方案非常之少；就算需要实现ContentProvider的插件化，也只是解决插件内部之间共享组件的问题，并没有把插件组件暴露给整个系统。我个人觉得，如果只是希望插件化，那么是否支持ContentProvider无伤大雅，但是，如果希望实现虚拟化或者说容器技术，所有组件是必须支持插件化的。</p>
<p>至此，对于Android系统的四大组件的插件化已经全部介绍完毕；由于是最后一个要介绍的组件，我并没有像之前一样先给出组件的运行原理，然后一通分析最后给出插件方案，而是一边分析代码一边给出自己的思路，把思考——推翻——改进的整个过程完全展现了出来，Android的插件化已经到达了百花齐放的阶段，插件化之路也不只有一条，但是万变不离其宗，希望我的分析和思考对各位读者理解甚至创造插件化方案带来帮助。接下来我会介绍「插件通信机制」，它与本文的ContentProvider以及我反复强调过的一些特性密切相关，敬请期待！</p>
<p>喜欢就点个赞吧，兜里有一块钱的童鞋可以点击下面的打赏然后扫一下二维码哦～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a> 和我的 <a href="http://weishu.me">博客</a>! 另外很抱歉一个多月没有更新博客了，每天看到各位的来访记录深感惭愧，实在是业务繁忙，身不由已！不出意外接下来会以正常速度更新内容，谢谢支持 ^_^</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>目前为止我们已经完成了Android四大组件中Activity，Service以及BroadcastReceiver的插件化，这几个组件各不相同，我们根据它们的特点定制了不同的插件化方案；那么对于ContentProvider，它又有什么特点？应该如何实现它的插件化？</p>
<p>与Activity，BroadcastReceiver等频繁被使用的组件不同，我们接触和使用ContentProvider的机会要少得多；但是，ContentProvider这个组件对于Android系统有着特别重要的作用——作为一种极其方便的<strong>数据共享</strong>的手段，ContentProvider使得广大第三方App能够在壁垒森严的系统中自由呼吸。</p>
<p>在Android系统中，每一个应用程序都有自己的用户ID，而每一个应用程序所创建的文件的读写权限都是只赋予给自己所属的用户，这就限制了应用程序之间相互读写数据的操作。应用程序之间如果希望能够进行交互，只能采取跨进程通信的方式；Binder机制能够满足一般的IPC需求，但是如果应用程序之间需要共享大量数据，单纯使用Binder是很难办到的——我相信大家对于Binder 1M缓冲区以及TransactionTooLargeException一定不陌生；ContentProvider使用了匿名共享内存(Ashmem)机制完成数据共享，因此它可以很方便地完成大量数据的传输。Android系统的短信，联系人，相册，媒体库等等一系列的基础功能都依赖与ContentProvider，它的重要性可见一斑。</p>
<p>既然ContentProvider的核心特性是数据共享，那么要实现它的插件化，必须能让插件能够把它的ContentProvider共享给系统——如果不能「<strong>provide content</strong>」那还叫什么ContentProvider？</p>
<p>但是，如果回想一下Activity等组件的插件化方式，在涉及到「共享」这个问题上，一直没有较好的解决方案：<br>]]>
    
    </summary>
    
      <category term="ContentProvider" scheme="http://weishu.me/tags/ContentProvider/"/>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何调试Android Framework？]]></title>
    <link href="http://weishu.me/2016/05/30/how-to-debug-android-framework/"/>
    <id>http://weishu.me/2016/05/30/how-to-debug-android-framework/</id>
    <published>2016-05-30T09:26:05.000Z</published>
    <updated>2016-06-02T11:41:03.000Z</updated>
    <content type="html"><![CDATA[<p>Linus有一句名言广为人知：Read the fucking source code. 但其实，要深入理解某个软件、框架或者系统的工作原理，仅仅「看」代码是远远不够的。就拿Android Framework来说，整个代码量非常大不说，那些个动辄几万行的类如何去理解？所以我今天要说的就是：</p>
<p><strong>Debug the fucking source code!!</strong></p>
<p>之前分享过一个答案：<a href="https://www.zhihu.com/question/40300713/answer/86706105" target="_blank" rel="external">大家遇到过什么 Android 兼容性问题？</a>，这里面的有一些非常诡异的问题，我相信光靠看代码你是永远定位不出来的。还有我写的一系列<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">Android插件框架原理</a>的文章，这里面涉及到大量Android Framework层的知识，有小伙伴会问，这些Framework层的原理，你是如何学习的呢，有诀窍吗？有！那就是调试。</p>
<p>Debug是一项非常非常重要的技能，毋庸多言。今天我就给大家分享一下「调试Android Framework」的经验，一旦掌握这项技能，那么Java层的任何问题都拦不住你了。</p>
<a id="more"></a>
<h2 id="概览">概览</h2><p>其实整个调试过程非常简单：</p>
<ol>
<li>在你要调试进程的合适位置打上断点</li>
<li>跟踪代码（Step in/out/over等等）</li>
</ol>
<p>在展开讲述这两方面之前，有必要先简单了解下调试的基础知识。Java平台的调试是有一个规范化的标准的，那就是JPDA（Java Platform Debugger Architecture）；通过 JPDA 提供的 API，开发人员可以方便灵活的搭建 Java 调试应用程序。 JPDA 主要由三个部分组成：Java 虚拟机工具接口（JVMTI），Java 调试线协议（JDWP），以及 Java 调试接口（JDI）。</p>
<p>Java程序的调试无非就是通过一个调试器（debugger）获取对应Java虚拟机的信息，上文所述的JDWP就是调试器与虚拟机通信的桥梁。在dalvik虚拟机内部有一个专门的jdwp线程，Android系统的adbd进程通过socket与各个虚拟机的jdwp线程进行通信，外部调试器通过adb工具与adbd通信进而完成与jdwp的通信。我们通常所说的「attach debugger」指的就是这个意思——连接到指定的需要调试的进程。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201605/1464599537380.png" alt="调试器工作原理"></p>
<h2 id="如何在正确的地方下断点">如何在正确的地方下断点</h2><p>「正确的地方」包含两个含义：首先，调试是以进程为单位进行的，如果你需要调试运行在进程A 中的代码，却把debugger attach到了B进程，那么这个断点压根儿就是牛头不对马嘴；另外呢，比如你想调试Android的多媒体框架，你得知道media相关的类在哪吧，也就是说需要在正确的函数里面下断点。</p>
<h3 id="如何在合适的进程下断点？">如何在合适的进程下断点？</h3><p>如果是调试我们自己写的App，在Android Studio里面非常简单，在Run菜单de最后面有一个attach debugger to android process 的选项，点击之后会出现一个菜单，选择自己需要调试的进程即可；但是，如果需要调试Android Framework层的代码，这样做是达不到目的的——Framework层的代码通常运行在别的进程（比如ActivityManagerService运行在system_server进程），而这些进程通常情况下是不可调试的，也就是说在attach debugger to android process 的那个菜单里面不会有系统的进程，如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1464596347439.png" alt="普通的无法调试的Android设备"></p>
<p>为什么不可调试呢？上文我们简要讲述了调试器的工作原理，我们知道每一个虚拟机有一个jdwp线程，如果这个线程拒绝连接到调试器，你也就没办法对这个进程进行调试了。Android的所有App进程都是通过Zygote进程fork出来的，我们在<code>android.os.Process</code>这个类里面可以看到android进程的启动过程有这么一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != <span class="number">0</span>) &#123;</span><br><span class="line">    argsForZygote.add(<span class="string">"--enable-debugger"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，一个进程是否可以调试是由进程启动时候的参数决定的；普通的App进程如果是debug keystore默认是可以调试的，有或者你在AndroidManifest里面指定debuggable为true也是可以调试的。对系统进程，我们只有采取系统级别的手段：让整个系统可以调试——debug版或者编译参数debuggable为1的系统。</p>
<p>解决这个办法很简单：使用模拟器（真机也行，限Nexus系列刷原生Android系统，把系统启动的debuggable参数修改为1），我的Nexus 5 可以调试的进程如下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1464596367660.png" alt="可调试任意进程的设备"></p>
<p>这样，系统中所有的Android进程都可以调试了；这一点很重要，比如你要分析Activity的启动流程，相当多一部分代码是在ActivityManagerService所在的进程system_server执行的，如果你把断点打在别的进程，就会产生跟丢了的情况。在比如，你要调试ActivityThread的main函数，在main函数里面执行了一句attach，最终调用AMS的attachApplication的时候，代码就通过Binder IPC调用到了AMS的system_server进程。</p>
<p>明白你要执行的代码运行在哪一个进程相当重要，在Android中，由于Binder通信机制的存在，「进程迁移」使用的非常非常频繁，因此需要对binder机制有一定的了解；详细的话可以参考我的博客：<a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a></p>
<h3 id="如何在对应的代码处下断点？">如何在对应的代码处下断点？</h3><p>假设我们现在把debugger attach到了正确的进程，那么断点应该下在哪里呢？直观来讲，就是说我需要导入所有的Android源码吗？如果不是应该导入哪些代码，怎么导入？</p>
<p>首先，如果你需要调试的类在sdk里面导出了，你压根儿就不需要再导入源码，Android Studio自动帮你关联了这部分代码（前提是你用SDK Manager下载了sdk的源码，如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201605/1464596414635.png" alt="SDK manager下载源码"></p>
<p>比如你要调试ActivityManagerService类的attachApplication方法，那么很简单；创建一个空的Android项目，SDK版本选择与你要调试的模拟器/真机 的android相同（这很重要，下文会讲述）；然后attrach 到system_server进程（debugger显示的名字为system_process)，直接在attach_application上面打上断点；随便启动一个app，可以看到我们熟悉的调试界面：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201605/1464596428584.png" alt="调试attachApplication"></p>
<p>如果这部分类在sdk中没有导入（比如@hide)的，又或者压根儿不是SDK的类，（比如系统app的源码）那应该怎么办呢？直接导入这部分代码即可。不需要是Android项目，普通的Java项目即可；举个例子，假设你想调试原生Android系统的「系统设置」这个程序，该如何做呢？</p>
<p>根据上面的分析，我们首先得知道「系统设置˜」运行在哪一个进程，通常情况下进程名字就是包名；我们查出设置的包名即可，而包名是在源码的AndroidManifeist中声明的，因此，我们找到「系统设置」这个程序的源码即可；源码在 <a href="https://android.googlesource.com/" target="_blank" rel="external">https://android.googlesource.com/</a> ，系统App的源码在/packages这个子目录下面，我们一个个找，最终可以确定「系统设置」的源码在 <a href="https://android.googlesource.com/platform/packages/apps/Settings/" target="_blank" rel="external">https://android.googlesource.com/platform/packages/apps/Settings/</a> ；然后我们把这部分代码git clone下来，导入Android Studio：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201605/1464596441461.png" alt="调试Settings"></p>
<p>我们去AndroidManifest中查到，「系统设置」的包名为：com.android.settings，这样我们attach到这个进程 ：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201605/1464596456242.png" alt="attach setting进程"></p>
<p>然后，我们随便打个断点玩一玩，比如进入设置主界面的时候，断下来；我们在AndroidManifest中查到设置程序的入口界面为：Settings，我们在这个类的onCreate里面打一个断点，然后进入设置程序，发现完美滴断下来了：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201605/1464596476109.png" alt="在setting中断点成功"></p>
<p>OK，到这里；应该学会如何在正确的位置打断点了：正确的进程，正确的位置。接下来，要完成调试，还需要一些技巧。</p>
<h2 id="如何跟踪代码？">如何跟踪代码？</h2><p>或许你会说，跟踪代码不就是step in/out/over么，这有什么难的？但其实事情并没有你想象的那么简单，要优雅滴调试，还是需要一些姿势的。</p>
<h3 id="行号对应">行号对应</h3><p>跟踪代码一个首要的问题是行号对应。如果你在正确位置下了断点，但是跟踪的时候，单步调试，发现运行的代码和Android Studio里面的代码对不上号，那么就很蛋疼；要使得调试器的行号能够对应，必须保证设备上的代码和调试器的代码是同一份；简单来说，需要使用Android的原生系统（模拟器，Nexus系列真机），然后调试器里面使用的SDK版本，必须和设备的系统版本一致。</p>
<h3 id="行号不对应怎么办？">行号不对应怎么办？</h3><p>一定要注意行号对应这一点，这会使调试过程简单很多；如果没有办法，行号对不上，那该如何调试呢？</p>
<p>行号不对应带来的一个首要问题就是，下断点的时候都有可能出现问题；比如你在TestClass的第100行下了一个断点，但是由于行号不对应，有可能真正执行的代码第100行是没有意义的空行或者是在下一个函数里面，这样断点就没有起到应有的作用了。</p>
<p>要解决行好对应的问题，必须使用<strong>方法断点</strong>；我们直接在某个函数的入口设置断点，这样即使行号对不上，也能在正确的入口出断下来，这一点非常重要。</p>
<p>解决了如何下断点的问题，那么行号不对应，怎么知道执行到哪了，怎么查看局部变量？</p>
<p><strong>观察栈桢</strong></p>
<p>在Android Studio的调试器的左边，显示了每一个线程执行的栈桢，栈桢里面包含了当前线程丰富的信息：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201605/1464598434021.png" width="292"></p>
<p>看到没，真正运行的代码在哪一行，当前运行的是什么函数一目了然；接下来你在step into/out的时候，不能以源代码的行数为准，而应该以这个栈桢所显示的代码行数为准。</p>
<h3 id="熟练使用断点">熟练使用断点</h3><p>OK，现在不论行号是否能对应，我们都能正确滴下断点调试了。断点有很多种类型，方法断点，watch point，条件断点都能够很好滴辅助我们调试；如果你连这几个名词都没有听说过，一定要恶补一下；可以参阅我的博客：<a href="http://weishu.me/2015/12/21/android-studio-debug-tips-you-may-not-know/">Android Studio你不知道的调试技巧</a>；我就不再复述了。</p>
<p>如果你仔细看完了本文和我给出的链接，那么应该对Debug技术不再陌生了；接下来你可以选择Framework层的代码，手动调试一下加深理解；在日后的工作过程中，不断滴加强debug技术的练习，让它称为你解决复杂问题的条件反射，一定会事半功倍！还有记住：</p>
<blockquote>
<p>Debug the fucking source code.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Linus有一句名言广为人知：Read the fucking source code. 但其实，要深入理解某个软件、框架或者系统的工作原理，仅仅「看」代码是远远不够的。就拿Android Framework来说，整个代码量非常大不说，那些个动辄几万行的类如何去理解？所以我今天要说的就是：</p>
<p><strong>Debug the fucking source code!!</strong></p>
<p>之前分享过一个答案：<a href="https://www.zhihu.com/question/40300713/answer/86706105">大家遇到过什么 Android 兼容性问题？</a>，这里面的有一些非常诡异的问题，我相信光靠看代码你是永远定位不出来的。还有我写的一系列<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">Android插件框架原理</a>的文章，这里面涉及到大量Android Framework层的知识，有小伙伴会问，这些Framework层的原理，你是如何学习的呢，有诀窍吗？有！那就是调试。</p>
<p>Debug是一项非常非常重要的技能，毋庸多言。今天我就给大家分享一下「调试Android Framework」的经验，一旦掌握这项技能，那么Java层的任何问题都拦不住你了。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="debug" scheme="http://weishu.me/tags/debug/"/>
    
      <category term="framework" scheme="http://weishu.me/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 插件化原理解析——Service的插件化]]></title>
    <link href="http://weishu.me/2016/05/11/understand-plugin-framework-service/"/>
    <id>http://weishu.me/2016/05/11/understand-plugin-framework-service/</id>
    <published>2016-05-11T13:02:50.000Z</published>
    <updated>2016-05-12T04:11:53.000Z</updated>
    <content type="html"><![CDATA[<p>在 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 以及 <a href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/">广播的管理</a> 中我们详细探讨了Android系统中的Activity、BroadcastReceiver组件的工作原理以及它们的插件化方案，相信读者已经对Android Framework和插件化技术有了一定的了解；本文将探讨Android四大组件之一——Service组件的插件化方式。</p>
<p>与Activity, BroadcastReceiver相比，Service组件的不同点在哪里呢？我们能否用与之相同的方式实现Service的插件化？如果不行，它们的差别在哪里，应该如何实现Service的插件化？</p>
<p>我们接下来将围绕这几个问题展开，最终给出Service组件的插件化方式；阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的 service-management 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<a id="more"></a>
<h2 id="Service工作原理">Service工作原理</h2><p>连Service的工作原理都不了解，谈何插件化？知己知彼。</p>
<p>Service分为两种形式：以startService<strong>启动</strong>的服务和用bindService<strong>绑定</strong>的服务；由于这两个过程大体相似，这里以稍复杂的<code>bindService</code>为例分析Service组件的工作原理。</p>
<p>绑定Service的过程是通过<code>Context</code>类的<code>bindService</code>完成的，这个方法需要三个参数：第一个参数代表想要绑定的Service的Intent，第二个参数是一个ServiceConnetion，我们可以通过这个对象接收到Service绑定成功或者失败的回调；第三个参数则是绑定时候的一些FLAG；关于服务的基本概念，可以参阅 <a href="http://developer.android.com/intl/zh-cn/guide/components/services.html" target="_blank" rel="external">官方文档</a>。（现在汉化了哦，E文不好童鞋的福音）</p>
<p>Context的具体实现在ContextImpl类，ContextImpl中的<code>bindService</code>方法直接调用了<code>bindServiceCommon</code>方法，此方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span><br><span class="line">        UserHandle user)</span> </span>&#123;</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// important</span></span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),</span><br><span class="line">                mMainThread.getHandler(), flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess();</span><br><span class="line">        <span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Not allowed to bind to service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致观察就能发现这个方法最终通过ActivityManagerNative借助AMS进而完成Service的绑定过程，在跟踪AMS的<code>bindService</code>源码之前，我们关注一下这个方法开始处创建的<code>sd</code>变量。这个变量的类型是<code>IServiceConnection</code>，如果读者还有印象，我们在 <a href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/">广播的管理</a> 一文中也遇到过类似的处理方式——IIntentReceiver；所以，这个IServiceConnection与IApplicationThread以及IIntentReceiver相同，都是ActivityThread给AMS提供的用来与之进行通信的Binder对象；这个接口的实现类为LoadedApk.ServiceDispatcher。</p>
<p>这个方法最终调用了ActivityManagerNative的bindService，而这个方法的真正实现在AMS里面，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags, String callingPackage,</span><br><span class="line">        <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"bindService"</span>);</span><br><span class="line">    <span class="comment">// 略去参数校检</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bindService这个方法相当简单，只是做了一些参数校检之后直接调用了ActivityServices类的<code>bindServiceLocked</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags,</span><br><span class="line">        String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">    <span class="comment">// 参数校检，略</span></span><br><span class="line"></span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="keyword">true</span>, callerFg);</span><br><span class="line">    <span class="comment">// 结果校检， 略</span></span><br><span class="line">    ServiceRecord s = res.record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... 不关心， 略</span></span><br><span class="line"></span><br><span class="line">        mAm.startAssociationLocked(callerApp.uid, callerApp.processName,</span><br><span class="line">                s.appInfo.uid, s.name, s.processName);</span><br><span class="line"></span><br><span class="line">        AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        ConnectionRecord c = <span class="keyword">new</span> ConnectionRecord(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent);</span><br><span class="line">        IBinder binder = connection.asBinder();</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对connection进行处理， 方便存取，略</span></span><br><span class="line">        clist.add(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="keyword">false</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与BIND_AUTO_CREATE不同的启动FLAG，原理与后续相同，略</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法比较长，我这里省去了很多无关代码，只列出关键逻辑；首先它通过<code>retrieveServiceLocked</code>方法获取到了intent匹配到的需要bind到的Service组件<code>res</code>；然后把ActivityThread传递过来的IServiceConnection使用ConnectionRecord进行了包装，方便接下来使用；最后如果启动的FLAG为BIND_AUTO_CREATE，那么调用<code>bringUpServiceLocked</code>开始创建Service，我们跟踪这个方法：（非这种FLAG的代码已经省略，可以自行跟踪）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span><br><span class="line">        <span class="keyword">boolean</span> whileRestarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 略。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line">                <span class="comment">// 1. important !!!</span></span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when starting service "</span> + r.shortName, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not running -- get it started, and enqueue this service record</span></span><br><span class="line">    <span class="comment">// to be executed when the app comes up.</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. important !!!</span></span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">                <span class="string">"service"</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bringDownServiceLocked(r);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 略。。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方案同样也很长，但是实际上非常简单：注意我注释的两个important的地方，如果Service所在的进程已经启动，那么直接调用<code>realStartServiceLocked</code>方法来<strong>真正</strong>启动Service组件；如果Service所在的进程还没有启动，那么先在AMS中记下这个要启动的Service组件，然后通过<code>startProcessLocked</code>启动新的进程。</p>
<p>我们先看Service进程已经启动的情况，也即<code>realStartServiceLocked</code>分支：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span><br><span class="line">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 略。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.ensurePackageDexOpt(r.serviceInfo.packageName);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 略。。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不关心，略。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法首先调用了app.thread的scheduleCreateService方法，我们知道，这是一个IApplicationThread对象，它是App所在进程提供给AMS的用来与App进程进行通信的Binder对象，这个Binder的Server端在ActivityThread的ApplicationThread类，因此，我们跟踪ActivityThread类，这个方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span><br><span class="line">        ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.info = info;</span><br><span class="line">    s.compatInfo = compatInfo;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它不过是转发了一个消息给ActivityThread的<code>H</code>这个Handler，<code>H</code>类收到这个消息之后，直接调用了ActivityThread类的<code>handleCreateService</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManagerNative.getDefault());</span><br><span class="line">        service.onCreate();</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// nothing to do.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这段代码，是不是似曾相识？！没错，这里与Activity组件的创建过程如出一辙！所以这里就不赘述了，可以参阅 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a>。</p>
<p>需要注意的是，这里Service类的创建过程与Activity是略微有点不同的，虽然都是通过ClassLoader通过反射创建，但是Activity却把创建过程委托给了Instrumentation类，而Service则是直接进行。</p>
<p>OK，现在ActivityThread里面的<code>handleCreateService</code>方法成功创建出了Service对象，并且调用了它的<code>onCreate</code>方法；到这里我们的Service已经启动成功。<code>scheduleCreateService</code>这个Binder调用过程结束，代码又回到了AMS进程的<code>realStartServiceLocked</code>方法。这里我们不得不感叹Binder机制的精妙，如此简洁方便高效的跨进程调用，在进程之间来回穿梭，游刃有余。</p>
<p><code>realStartServiceLocked</code>方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span><br><span class="line">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 略。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.ensurePackageDexOpt(r.serviceInfo.packageName);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 略。。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不关心，略。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法在完成<code>scheduleCreateService</code>这个binder调用之后，执行了一个<code>requestServiceBindingsLocked</code>方法；看方法名好像于「绑定服务」有关，它简单地执行了一个遍历然后调用了另外一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span><br><span class="line">        <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.app == <span class="keyword">null</span> || r.app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">"bind"</span>);</span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.repProcState);</span><br><span class="line">        <span class="comment">// 不关心，略。。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里又通过IApplicationThread这个Binder进行了一次IPC调用，我们跟踪ActivityThread类里面的ApplicationThread的<code>scheduleBindService</code>方法，发现这个方法不过通过Handler转发了一次消息，真正的处理代码在<code>handleBindService</code>里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                    IBinder binder = s.onBind(data.intent);</span><br><span class="line">                    ActivityManagerNative.getDefault().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要Bind的Service终于在这里完成了绑定！绑定之后又通过ActivityManagerNative这个Binder进行一次IPC调用，我们查看AMS的<code>publishService</code>方法，这个方法简单第调用了<code>publishServiceLocked</code>方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; !b.received) &#123;</span><br><span class="line">                b.binder = service;</span><br><span class="line">                b.requested = <span class="keyword">true</span>;</span><br><span class="line">                b.received = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> conni=r.connections.size()-<span class="number">1</span>; conni&gt;=<span class="number">0</span>; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        ConnectionRecord c = clist.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            c.conn.connected(r.name, service);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得我们之前提到的那个IServiceConnection吗？在<code>bindServiceLocked</code>方法里面，我们把这个IServiceConnection放到了一个ConnectionRecord的List中存放在ServiceRecord里面，这里所做的就是取出已经被Bind的这个Service对应的IServiceConnection对象，然后调用它的<code>connected</code>方法；我们说过，这个IServiceConnection也是一个Binder对象，它的Server端在LoadedApk.ServiceDispatcher里面。代码到这里已经很明确了，由于分析过程过长，再继续估计大家要瞌睡了；接下来的过程非常简单，感兴趣的读者自行查阅LoadedApk.ServiceDispatcher的<code>connected</code>方法，一路跟踪弄清楚ServiceConnection回调过程，完成最后的拼图！</p>
<p>最后提一点，以上我们分析了Service所在进程已经存在的情况，如果Service所在进程不存在，那么会调用startProcessLocked方法创建一个新的进程，并把需要启动的Service放在一个队列里面；创建进程的过程通过Zygote fork出来，进程创建成功之后会调用ActivityThread的main方法，在这个main方法里面间接调用到了AMS的attachApplication方法，在AMS的attachApplication里面会检查刚刚那个待启动Service队列里面的内容，并执行Service的启动操作；之后的启动过程与进程已经存在的情况下相同；可以自行分析。</p>
<h2 id="Service的插件化思路">Service的插件化思路</h2><p>现在我们已经明白了Service组件的工作原理，可对如何实现Service的插件化依然是一头雾水。</p>
<p>从上文的源码分析来看，Service组件与Activity有着非常多的相似之处：它们都是通过Context类完成启动，接着通过ActivityMnagaerNative进入AMS，最后又通过IApplicationThread这个Binder IPC到App进程的Binder线程池，然后通过H转发消息到App进程的主线程，最终完成组件生命周期的回调；对于Service组件，看起来好像可以沿用Activity组件的插件化方式：Hook掉ActivityManagerNative以及<code>H</code>类，但事实真的如此吗？</p>
<h3 id="Service与Activity的异同">Service与Activity的异同</h3><p>Service组件和Activity组件有什么不同？这些不同使得我们对于插件化方案的选择又有什么影响？</p>
<h4 id="用户交互对于生命周期的影响">用户交互对于生命周期的影响</h4><p>首先，Activity与Service组件最大的不同点在于，Activity组件可以与用户进行交互；这一点意味着用户的行为会对Activity组件产生影响，对我们来说最重要的影响就是Activity组件的生命周期；用户点击按钮从界面A跳转到界面B，会引起A和B这两个Activity一系列生命周期的变化。而Service组件则代表后台任务，除了内存不足系统回收之外，它的生命周期完全由我们的代码控制，与用户的交互无关。</p>
<p>这意味着什么？</p>
<p>Activity组件的生命周期受用户交互影响，而这种变化只有Android系统才能感知，因此我们必须把插件的Activity交给系统管理，才能拥有完整的生命周期；但Service组件的生命周期不受外界因素影响，那么自然而然，我们可以<strong>手动控制它的生命周期</strong>，就像我们对于BroadcastReceiver的插件化方式一样！Activity组件的插件化无疑是比较复杂的，为了把插件Activity交给系统管理进而拥有完整生命周期，我们设计了一个天衣无缝的方案骗过了AMS；既然Service的生命周期可以由我们自己控制，那么我们可以有更简单的方案实现它的插件化。</p>
<h4 id="Activity的任务栈">Activity的任务栈</h4><p>上文指出了Activity和Service组件在处理用户交互方面的不同，这使得我们对于Service组建的插件化可以选择一种较为简单的方式；也许你会问，那采用Activity插件化的那一套技术能够实现Service组件的插件化吗？</p>
<p>很遗憾，答案是不行的。虽然Activity的插件化技术更复杂，但是这种方案并不能完成Service组件的插件化——复杂的方案并不意味了它能处理更多的问题。</p>
<p>原因在于Activity拥有任务栈的概念。或许你觉得任务栈并不是什么了不起的东西，但是，这确实是Service组件与Activity组件插件化方式分道扬镳的根本原因。</p>
<p>任务栈的概念使得Activtiy的创建就代表着入栈，销毁则代表出栈；又由于Activity代表着与用户交互的界面，所以这个栈的深度不可能太深——Activity栈太深意味着用户需要狂点back键才能回到初始界面，这种体验显然有问题；因此，插件框架要处理的Activity数量其实是有限的，所以我们在AndroidManifest.xml中声明有限个StubActivity就能满足插件启动近乎无限个插件Activity的需求。</p>
<p>但是Service组件不一样，理论情况下，可以启动的Service组件是无限的——除了硬件以及内存资源，没有什么限制它的数目；如果采用Activity的插件化方式，就算我们在AndroidMafenist.xml中声明再多的StubService，总有不能满足插件中要启动的Service数目的情况出现。也许有童鞋会说，可以用一个StubService对应多个插件Service，这确实能解决部分问题；但是，下面的这个区别让这种设想彻底泡汤。</p>
<h4 id="Service无法拥有多实例">Service无法拥有多实例</h4><p>Service组件与Activity组件另外一个不同点在于，对同一个Service调用多次startService并不会启动多个Service实例，而非特定Flag的Activity是可以允许这种情况存在的，因此如果用StubService的方式，为了实现Service的这种特性，必须建立一个StubService到插件Service的一个Map，Map的这种一一对应关系使得我们使用一个StubService对应多个插件Service的计划成为天方夜谭。</p>
<p>至此，结论已经非常清晰——对于Service组件的插件化，我们不能简单地套用Activity的方案。</p>
<h3 id="如何实现Service的插件化？">如何实现Service的插件化？</h3><p>上文指出，我们不能套用Activity的方案实现Service组件的插件化，可以通过手动控制Service组件的生命周期实现；我们先来看一下Service的生命周期：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1462949033406.png" alt="Service生命周期"></p>
<p>从图中可以看出，Service的生命周期相当简单：整个生命周期从调用 onCreate() 开始起，到 onDestroy() 返回时结束。对于非绑定服务，就是从startService调用到stopService或者stopSelf调用。对于绑定服务，就是bindService调用到unbindService调用；</p>
<p>如果要手动控制Service组件的生命周期，我们只需要模拟出这个过程即可；而实现这一点并不复杂：</p>
<ol>
<li>如果以startService方式启动插件Service，直接回调要启动的Service对象的onStartCommand方法即可；如果用stopService或者stopSelf的方式停止Service，只需要回调对应的Service组件的onDestroy方法。</li>
<li>如果用bindService方式绑定插件Service，可以调用对应Service对应的onBind方法，获取onBind方法返回的Binder对象，然后通过ServiceConnection对象进行回调统计；unBindService的实现同理。</li>
</ol>
<h4 id="完全手动控制">完全手动控制</h4><p>现在我们已经有了实现思路，那么具体如何实现呢？</p>
<p>我们必须在startService,stopService等方法被调用的时候拿到控制权，才能手动去控制Service的生命周期；要达到这一目的非常简单——Hook ActivityManagerNative即可。在Activity的插件化方案中我们就通过这种方式接管了startActivity调用，相信读者并不陌生。</p>
<p>我们Hook掉ActivityManagerNative之后，可以拦截对于startService以及stopService等方法的调用；拦截之后，我们可以直接对插件Service进行操作：</p>
<ol>
<li>拦截到startService之后，如果Service还没有创建就直接创建Service对象（可能需要加载插件），然后调用这个Service的onCreate,onStartCommond方法；如果Service已经创建，获取到原来创建的Service对象并执行其onStartCommand方法。</li>
<li>拦截到stopService之后，获取到对应的Service对象，直接调用这个Service的onDestroy方法。</li>
</ol>
<p>这种方案简直简单得让人不敢相信！很可惜，这么干是不行的。</p>
<p>首先，Service存在的意义在于它作为一个后台任务，拥有相对较高运行时优先级；除非在内存及其不足威胁到前台Activity的时候，这个组件才会被系统杀死。上述这种实现完全把Service当作一个普通的Java对象使用了，因此并没有完全实现Service所具备的能力。</p>
<p>其次，Activity以及Service等组件是可以指定进程的，而让Service运行在某个特定进程的情况非常常见——所谓的远程Service；用上述这种办法压根儿没有办法让某个Service对象运行在一个别的进程。Android系统给开发者控制进程的机会太少了，要么在AndroidManifest.xml中通过process属性指定，要么借助Java的Runtime类或者native的fork；这几种方式都无法让我们以一种简单的方式配合上述方案达到目的。</p>
<h4 id="代理分发技术">代理分发技术</h4><p>既然我们希望插件的Service具有一定的运行时优先级，那么一个货真价实的Service组件是必不可少的——只有这种被系统认可的真正的Service组件才具有所谓的运行时优先级。</p>
<p>因此，我们可以注册一个真正的Service组件ProxyService，让这个Service承载一个真正的Service组件所具备的能力（进程优先级等）；当启动插件的服务比如PluginService的时候，我们统一启动这个ProxyService，当这个ProxyService运行起来之后，再在它的onStartCommand等方法里面进行分发，执行PluginService的onStartCommond等对应的方法；我们把这种方案形象地称为「代理分发技术」</p>
<p>代理分发技术也可以完美解决插件Service可以运行在不同的进程的问题——我们可以在AndroidManifest.xml中注册多个ProxyService，指定它们的process属性，让它们运行在不同的进程；当启动的插件Service希望运行在一个新的进程时，我们可以选择某一个合适的ProxyService进行分发。也许有童鞋会说，那得注册多少个ProxyService才能满足需求啊？理论上确实存在这问题，但事实上，一个App使用超过10个进程的几乎没有；因此这种方案是可行的。</p>
<h2 id="Service插件化的实现">Service插件化的实现</h2><p>现在我们已经设计出了Service组件的插件化方案，接下来我们以startService以及stopService为例实现这个过程。</p>
<h3 id="注册代理Service">注册代理Service</h3><p>我们需要一个货真价实的Service组件来承载进程优先级等功能，因此需要在AndroidManifest.xml中声明一个或者多个（用以支持多进程）这样的Sevice：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"com.weishu.upf.service_management.app.ProxyService"</span></span><br><span class="line">        <span class="attribute">android:process</span>=<span class="value">"plugin01"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="拦截startService等调用过程">拦截startService等调用过程</h3><p>要手动控制Service组件的生命周期，需要拦截startService,stopService等调用，并且把启动插件Service全部重定向为启动ProxyService（保留原始插件Service信息）；这个拦截过程需要Hook ActvityManagerNative，我们对这种技术应该是轻车熟路了；不了解的童鞋可以参考之前的文章 <a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Hook机制之AMS&amp;PMS</a> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookActivityManagerNative</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException,</span><br><span class="line">        NoSuchMethodException, InvocationTargetException,</span><br><span class="line">        IllegalAccessException, NoSuchFieldException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; activityManagerNativeClass = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line"></span><br><span class="line">    Field gDefaultField = activityManagerNativeClass.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">    gDefaultField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    Object gDefault = gDefaultField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gDefault是一个 android.util.Singleton对象; 我们取出这个单例里面的字段</span></span><br><span class="line">    Class&lt;?&gt; singleton = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line">    Field mInstanceField = singleton.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">    mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ActivityManagerNative 的gDefault对象里面原始的 IActivityManager对象</span></span><br><span class="line">    Object rawIActivityManager = mInstanceField.get(gDefault);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个这个对象的代理对象, 然后替换这个字段, 让我们的代理对象帮忙干活</span></span><br><span class="line">    Class&lt;?&gt; iActivityManagerInterface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iActivityManagerInterface &#125;, <span class="keyword">new</span> IActivityManagerHandler(rawIActivityManager));</span><br><span class="line">    mInstanceField.set(gDefault, proxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在收到startService,stopService之后可以进行具体的操作，对于startService来说，就是直接替换启动的插件Service为ProxyService等待后续处理，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"startService"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="comment">// API 23:</span></span><br><span class="line">    <span class="comment">// public ComponentName startService(IApplicationThread caller, Intent service,</span></span><br><span class="line">    <span class="comment">//        String resolvedType, int userId) throws RemoteException</span></span><br><span class="line">    <span class="comment">// 找到参数里面的第一个Intent 对象</span></span><br><span class="line">    Pair&lt;Integer, Intent&gt; integerIntentPair = foundFirstIntentOfArgs(args);</span><br><span class="line">    Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">    <span class="comment">// 代理Service的包名, 也就是我们自己的包名</span></span><br><span class="line">    String stubPackage = UPFApplication.getContext().getPackageName();</span><br><span class="line">    <span class="comment">// 这里我们把启动的Service替换为ProxyService, 让ProxyService接收生命周期回调</span></span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(stubPackage, ProxyService.class.getName());</span><br><span class="line">    newIntent.setComponent(componentName);</span><br><span class="line">    <span class="comment">// 把我们原始要启动的TargetService先存起来</span></span><br><span class="line">    newIntent.putExtra(AMSHookHelper.EXTRA_TARGET_INTENT, integerIntentPair.second);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 替换掉Intent, 达到欺骗AMS的目的</span></span><br><span class="line">    args[integerIntentPair.first] = newIntent;</span><br><span class="line">    Log.v(TAG, <span class="string">"hook method startService success"</span>);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对stopService的处理略有不同但是大同小异，读者可以上 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">github</a> 查阅源码。</p>
<h3 id="分发Service">分发Service</h3><p>Hook ActivityManagerNative之后，所有的插件Service的启动都被重定向了到了我们注册的ProxyService，这样可以保证我们的插件Service有一个真正的Service组件作为宿主；但是要执行特定插件Service的任务，我们必须把这个任务分发到真正要启动的Service上去；以<code>onStart</code>为例，在启动ProxyService之后，会收到ProxyService的<code>onStart</code>回调，我们可以在这个方法里面把具体的任务交给原始要启动的插件Service组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"onStart() called with "</span> + <span class="string">"intent = ["</span> + intent + <span class="string">"], startId = ["</span> + startId + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分发Service</span></span><br><span class="line">    ServiceManager.getInstance().onStart(intent, startId);</span><br><span class="line">    <span class="keyword">super</span>.onStart(intent, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加载Service">加载Service</h4><p>我们可以在ProxyService里面把任务转发给真正要启动的插件Service组件，要完成这个过程肯定需要创建一个对应的插件Service对象，比如PluginService；但是通常情况下插件存在与单独的文件之中，正常的方式是无法创建这个PluginService对象的，宿主程序默认的ClassLoader无法加载插件中对应的这个类；所以，要创建这个对应的PluginService对象，必须先完成插件的加载过程，让这个插件中的所有类都可以被正常访问；这种技术我们在之前专门讨论过，并给出了「激进方案」和「保守方案」，不了解的童鞋可以参考文章 <a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">插件加载机制</a>；这里我选择代码较少的「保守方案」为例（Droid Plugin中采用的激进方案）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patchClassLoader</span><span class="params">(ClassLoader cl, File apkFile, File optDexFile)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, NoSuchMethodException, IOException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 BaseDexClassLoader : pathList</span></span><br><span class="line">    Field pathListField = DexClassLoader.class.getSuperclass().getDeclaredField(<span class="string">"pathList"</span>);</span><br><span class="line">    pathListField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object pathListObj = pathListField.get(cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 PathList: Element[] dexElements</span></span><br><span class="line">    Field dexElementArray = pathListObj.getClass().getDeclaredField(<span class="string">"dexElements"</span>);</span><br><span class="line">    dexElementArray.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object[] dexElements = (Object[]) dexElementArray.get(pathListObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Element 类型</span></span><br><span class="line">    Class&lt;?&gt; elementClass = dexElements.getClass().getComponentType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个数组, 用来替换原始的数组</span></span><br><span class="line">    Object[] newElements = (Object[]) Array.newInstance(elementClass, dexElements.length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造插件Element(File file, boolean isDirectory, File zip, DexFile dexFile) 这个构造函数</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = elementClass.getConstructor(File.class, <span class="keyword">boolean</span>.class, File.class, DexFile.class);</span><br><span class="line">    Object o = constructor.newInstance(apkFile, <span class="keyword">false</span>, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(), optDexFile.getAbsolutePath(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Object[] toAddElementArray = <span class="keyword">new</span> Object[] &#123; o &#125;;</span><br><span class="line">    <span class="comment">// 把原始的elements复制进去</span></span><br><span class="line">    System.arraycopy(dexElements, <span class="number">0</span>, newElements, <span class="number">0</span>, dexElements.length);</span><br><span class="line">    <span class="comment">// 插件的那个element复制进去</span></span><br><span class="line">    System.arraycopy(toAddElementArray, <span class="number">0</span>, newElements, dexElements.length, toAddElementArray.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    dexElementArray.set(pathListObj, newElements);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="匹配过程">匹配过程</h4><p>上文中我们把启动插件Service重定向为启动ProxyService，现在ProxyService已经启动，因此必须把控制权交回原始的PluginService；在加载插件的时候，我们存储了插件中所有的Service组件的信息，因此，只需要根据Intent里面的Component信息就可以取出对应的PluginService。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ServiceInfo <span class="title">selectPluginService</span><span class="params">(Intent pluginIntent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ComponentName componentName : mServiceInfoMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (componentName.equals(pluginIntent.getComponent())) &#123;</span><br><span class="line">            <span class="keyword">return</span> mServiceInfoMap.get(componentName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建以及分发">创建以及分发</h4><p>插件被加载之后，我们就需要创建插件Service对应的Java对象了；由于这些类是在运行时动态加载进来的，肯定不能直接使用<code>new</code>关键字——我们需要使用反射机制。但是下面的代码创建出插件Service对象能满足要求吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = getClassLoader();</span><br><span class="line">Service service = cl.loadClass(<span class="string">"com.plugin.xxx.PluginService1"</span>);</span><br></pre></td></tr></table></figure>
<p>Service作为Android系统的组件，最重要的特点是它具有<code>Context</code>；所以，直接通过反射创建出来的这个PluginService就是一个壳子——没有Context的Service能干什么？因此我们需要给将要创建的Service类创建出Conetxt；但是Context应该如何创建呢？我们平时压根儿没有这么干过，Context都是系统给我们创建好的。既然这样，我们可以参照一下系统是如何创建Service对象的；在上文的Service源码分析中，在ActivityThread类的handleCreateService完成了这个步骤，摘要如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">    service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">    context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">    Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">    service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">            ActivityManagerNative.getDefault());</span><br><span class="line">    service.onCreate();</span><br></pre></td></tr></table></figure>
<p>可以看到，系统也是通过反射创建出了对应的Service对象，然后也创建了对应的Context，并给Service注入了活力。如果我们模拟系统创建Context这个过程，势必需要进行一系列反射调用，那么我们何不直接反射handleCreateService方法呢？</p>
<p>当然，handleCreateService这个方法并没有把创建出来的Service对象作为返回值返回，而是存放在ActivityThread的成员变量<code>mService</code>之中，这个是小case，我们反射取出来就行；所以，创建Service对象的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 通过ActivityThread的handleCreateService方法创建出Service对象</span><br><span class="line"> * <span class="doctag">@param</span> serviceInfo 插件的ServiceInfo</span><br><span class="line"> * <span class="doctag">@throws</span> Exception</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">proxyCreateService</span><span class="params">(ServiceInfo serviceInfo)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    IBinder token = <span class="keyword">new</span> Binder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建CreateServiceData对象, 用来传递给ActivityThread的handleCreateService 当作参数</span></span><br><span class="line">    Class&lt;?&gt; createServiceDataClass = Class.forName(<span class="string">"android.app.ActivityThread$CreateServiceData"</span>);</span><br><span class="line">    Constructor&lt;?&gt; constructor  = createServiceDataClass.getDeclaredConstructor();</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object createServiceData = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入我们创建的createServiceData的token字段, ActivityThread的handleCreateService用这个作为key存储Service</span></span><br><span class="line">    Field tokenField = createServiceDataClass.getDeclaredField(<span class="string">"token"</span>);</span><br><span class="line">    tokenField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    tokenField.set(createServiceData, token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入info对象</span></span><br><span class="line">    <span class="comment">// 这个修改是为了loadClass的时候, LoadedApk会是主程序的ClassLoader, 我们选择Hook BaseDexClassLoader的方式加载插件</span></span><br><span class="line">    serviceInfo.applicationInfo.packageName = UPFApplication.getContext().getPackageName();</span><br><span class="line">    Field infoField = createServiceDataClass.getDeclaredField(<span class="string">"info"</span>);</span><br><span class="line">    infoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    infoField.set(createServiceData, serviceInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入compatInfo字段</span></span><br><span class="line">    <span class="comment">// 获取默认的compatibility配置</span></span><br><span class="line">    Class&lt;?&gt; compatibilityClass = Class.forName(<span class="string">"android.content.res.CompatibilityInfo"</span>);</span><br><span class="line">    Field defaultCompatibilityField = compatibilityClass.getDeclaredField(<span class="string">"DEFAULT_COMPATIBILITY_INFO"</span>);</span><br><span class="line">    Object defaultCompatibility = defaultCompatibilityField.get(<span class="keyword">null</span>);</span><br><span class="line">    Field compatInfoField = createServiceDataClass.getDeclaredField(<span class="string">"compatInfo"</span>);</span><br><span class="line">    compatInfoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    compatInfoField.set(createServiceData, defaultCompatibility);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">    Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private void handleCreateService(CreateServiceData data) &#123;</span></span><br><span class="line">    Method handleCreateServiceMethod = activityThreadClass.getDeclaredMethod(<span class="string">"handleCreateService"</span>, createServiceDataClass);</span><br><span class="line">    handleCreateServiceMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    handleCreateServiceMethod.invoke(currentActivityThread, createServiceData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handleCreateService创建出来的Service对象并没有返回, 而是存储在ActivityThread的mServices字段里面, 这里我们手动把它取出来</span></span><br><span class="line">    Field mServicesField = activityThreadClass.getDeclaredField(<span class="string">"mServices"</span>);</span><br><span class="line">    mServicesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Map mServices = (Map) mServicesField.get(currentActivityThread);</span><br><span class="line">    Service service = (Service) mServices.get(token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到之后, 移除这个service, 我们只是借花献佛</span></span><br><span class="line">    mServices.remove(token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将此Service存储起来</span></span><br><span class="line">    mServiceMap.put(serviceInfo.name, service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们已经创建出了对应的PluginService，并且拥有至关重要的Context对象；接下来就可以把消息分发给原始的PluginService组件了，这个分发的过程很简单，直接执行消息对应的回调(onStart, onDestroy等）即可；因此，完整的startService分发过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent proxyIntent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Intent targetIntent = proxyIntent.getParcelableExtra(AMSHookHelper.EXTRA_TARGET_INTENT);</span><br><span class="line">    ServiceInfo serviceInfo = selectPluginService(targetIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serviceInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"can not found service : "</span> + targetIntent.getComponent());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mServiceMap.containsKey(serviceInfo.name)) &#123;</span><br><span class="line">            <span class="comment">// service还不存在, 先创建</span></span><br><span class="line">            proxyCreateService(serviceInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Service service = mServiceMap.get(serviceInfo.name);</span><br><span class="line">        service.onStart(targetIntent, startId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们已经实现了Service组件的插件化；完整的代码见 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">github</a>，代码以startService, stopService为例进行了说明，bindService以及unbindService的原理是一样的，感兴趣的读者可以自行实现；欢迎PR。</p>
<h2 id="小节">小节</h2><p>本文中我们以绑定服务为例分析了Service组件的工作原理，并指出用户交导致组件生命周期的变化是Activity与Service的根本差别，这种差别使得插件方案对于它们必须采取不同的处理方式；最后我们通过手动控制Service组件的生命周期结合「代理分发技术」成功地实现了Service组件的插件化；这种插件化方案堪称「完美」，如果非要吹毛求疵，那只能说由于同一个进程的所有Service都挂载在同一个ProxyService上面，如果系统可用内存不够必须回收Service，杀死一个ProxyService会导致一大票的插件Service歇菜。</p>
<p>实际使用过程中，Service组件的更新频度并不高，因此直接把插件Service注册到主程序也是可以接受的；而且如果需要绑定远程Service，完全可以使用一个Service组件根据不同的Intent返回不同的IBinder，所以不实现Service组件的插件化也能满足工程需要。值得一提的是，我们对于Service组件的插件化方案实际上是一种「代理」的方式，用这种方式也能实现Activity组件的插件化，有一些开源的插件方案比如 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">DL</a> 就是这么做的。</p>
<p>迄今为止，我们讲述了了Activity、BroadcastReceiver以及Service的插件化方式，不知读者思索过没有，实现插件化的关键点在哪里？</p>
<p>Service，Activity等不过就是一些普通的Java类，它们之所称为四大组件，是因为他们有生命周期；这也是简单地采用Java的动态加载技术无法实现插件化的原因——动态加载进来的Service等类如果没有它的生命周期，无异于一个没有灵魂的傀儡。对于Activity组件，由于他的生命周期受用户交互影响，只有系统本身才能对这种交互有全局掌控力，因此它的插件化方式是Hook AMS，但是生命周期依然交由系统管理；而Service以及BroadcastReceiver的生命周期没有额外的因素影响，因此我们选择了手动控制其生命周期的方式。不论是借尸还魂还是女娲造人，对这些组件的插件化终归结底是要赋予组件“生命”。</p>
<p>插件化系列的文章有整整一个月没有更新了，非常抱歉！这段时间发生了很多事情，我实在抽不出时间照顾博客；而写这种文章又需要足够的时间准备，要跟踪源码分析过程，要找联系DroidPlugin作者确认设计思路，还要亲自写demo验证。<br>喜欢就点个赞吧，兜里有一块钱的童鞋可以点击下面的打赏然后扫一下二维码哦～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a> 和我的 <a href="http://weishu.me">博客</a>! </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 以及 <a href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/">广播的管理</a> 中我们详细探讨了Android系统中的Activity、BroadcastReceiver组件的工作原理以及它们的插件化方案，相信读者已经对Android Framework和插件化技术有了一定的了解；本文将探讨Android四大组件之一——Service组件的插件化方式。</p>
<p>与Activity, BroadcastReceiver相比，Service组件的不同点在哪里呢？我们能否用与之相同的方式实现Service的插件化？如果不行，它们的差别在哪里，应该如何实现Service的插件化？</p>
<p>我们接下来将围绕这几个问题展开，最终给出Service组件的插件化方式；阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework">understand-plugin-framework</a>，参考此项目的 service-management 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
      <category term="service" scheme="http://weishu.me/tags/service/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android插件化原理解析——广播的管理]]></title>
    <link href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/"/>
    <id>http://weishu.me/2016/04/12/understand-plugin-framework-receiver/</id>
    <published>2016-04-12T11:08:16.000Z</published>
    <updated>2016-04-12T11:09:56.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 以及 <a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">插件加载机制</a> 中我们详细讲述了插件化过程中对于Activity组件的处理方式，为了实现Activity的插件化我们付出了相当多的努力；那么Android系统的其他组件，比如BroadcastReceiver，Service还有ContentProvider，它们又该如何处理呢？</p>
<p>相比Activity，BroadcastReceiver要简单很多——广播的生命周期相当简单；如果希望插件能够支持广播，这意味着什么？</p>
<p>回想一下我们日常开发的时候是如何使用BroadcastReceiver的：<strong>注册</strong>, <strong>发送</strong>和<strong>接收</strong>；因此，要实现BroadcastReceiver的插件化就这三种操作提供支持；接下来我们将一步步完成这个过程。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的<code>receiver-management</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<a id="more"></a>
<p>如果连BroadcastReceiver的工作原理都不清楚，又怎么能让插件支持它？老规矩，知己知彼。</p>
<h2 id="源码分析">源码分析</h2><p>我们可以注册一个BroadcastReceiver然后接收我们感兴趣的广播，也可以给某有缘人发出某个广播；因此，我们对源码的分析按照两条路线展开：</p>
<h3 id="注册过程">注册过程</h3><p>不论是静态广播还是动态广播，在使用之前都是需要注册的；动态广播的注册需要借助Context类的registerReceiver方法，而静态广播的注册直接在AndroidManifest.xml中声明即可；我们首先分析一下动态广播的注册过程。</p>
<p>Context类的registerReceiver的真正实现在ContextImpl里面，而这个方法间接调用了registerReceiverInternal，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="keyword">int</span> userId,</span><br><span class="line">        IntentFilter filter, String broadcastPermission,</span><br><span class="line">        Handler scheduler, Context context)</span> </span>&#123;</span><br><span class="line">    IIntentReceiver rd = <span class="keyword">null</span>; <span class="comment">// Important !!!!!</span></span><br><span class="line">    <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ActivityManagerNative.getDefault().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName,</span><br><span class="line">                rd, filter, broadcastPermission, userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，BroadcastReceiver的注册也是通过<code>AMS</code>完成的；在进入<code>AMS</code>跟踪它的registerReceiver方法之前，我们先弄清楚这个<code>IIntentReceiver</code>类型的变量<code>rd</code>是什么。首先查阅API文档，很遗憾SDK里面没有导出这个类，我们直接去 <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.0.1_r1/android/content/IIntentReceiver.java?av=f" target="_blank" rel="external">grepcode</a> 上看，文档如下：</p>
<blockquote>
<p>System private API for dispatching intent broadcasts. This is given to the activity manager as part of registering for an intent broadcasts, and is called when it receives intents.</p>
</blockquote>
<p>这个类是通过AIDL工具生成的，它是一个Binder对象，因此可以用来跨进程传输；文档说的很清楚，它是用来进行广播分发的。什么意思呢？</p>
<p>由于广播的分发过程是在AMS中进行的，而AMS所在的进程和BroadcastReceiver所在的进程不一样，因此要把广播分发到BroadcastReceiver具体的进程需要进行跨进程通信，这个<strong>通信的载体</strong>就是IIntentReceiver类。其实这个类的作用跟 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 中提到的 <code>IApplicationThread</code>相同，都是App进程给AMS进程用来进行通信的对象。另外，<code>IIntentReceiver</code>是一个接口，从上述代码中可以看出，它的实现类为LoadedApk.ReceiverDispatcher。</p>
<p>OK，我们继续跟踪源码，AMS类的registerReceiver方法代码有点多，这里不一一解释了，感兴趣的话可以自行查阅；这个方法主要做了以下两件事：</p>
<ol>
<li>对发送者的身份和权限做出一定的校检</li>
<li>把这个BroadcastReceiver以BroadcastFilter的形式存储在AMS的<code>mReceiverResolver</code>变量中，供后续使用。</li>
</ol>
<p>就这样，被传递过来的BroadcastReceiver已经成功地注册在系统之中，能够接收特定类型的广播了；那么注册在AndroidManifest.xml中的静态广播是如何被系统感知的呢？</p>
<p>在 <a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">插件加载机制</a> 中我们知道系统会通过PackageParser解析Apk中的AndroidManifest.xml文件，因此我们有理由认为，系统会在解析AndroidMafest.xml的&lt;receiver&gt;标签（也即静态注册的广播）的时候保存相应的信息；而Apk的解析过程是在PMS中进行的，因此<strong>静态注册广播的信息存储在PMS中</strong>。接下来的分析会证实这一结论。</p>
<h3 id="发送和接收过程">发送和接收过程</h3><h4 id="发送过程">发送过程</h4><p>发送广播很简单，就是一句context.sendBroadcast()，我们顺藤摸瓜，跟踪这个方法。前文也提到过，Context中方法的调用都会委托到ContextImpl这个类，我们直接看ContextImpl对这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.prepareToLeaveProcess();</span><br><span class="line">        ActivityManagerNative.getDefault().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</span><br><span class="line">                Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，发送广播也是通过AMS进行的，我们直接查看ActivityManagerService类的broadcastIntent方法，这个方法仅仅是调用了broadcastIntentLocked方法，我们继续跟踪；broadcastIntentLocked这个方法相当长，处理了诸如粘性广播，顺序广播，各种Flag以及动态广播静态广播的接收过程，这些我们暂时不关心；值得注意的是，在这个方法中我们发现，其实<strong>广播的发送和接收是融为一体的</strong>。某个广播被发送之后，AMS会找出所有注册过的BroadcastReceiver中与这个广播匹配的接收者，然后将这个广播分发给相应的接收者处理。</p>
<h4 id="匹配过程">匹配过程</h4><p>某一条广播被发出之后，并不是阿猫阿狗都能接收它并处理的；BroadcastReceiver可能只对某些类型的广播感兴趣，因此它也只能接收和处理这种特定类型的广播；在broadcastIntentLocked方法内部有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure out who all will receive this broadcast.</span></span><br><span class="line">List receivers = <span class="keyword">null</span>;</span><br><span class="line">List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Need to resolve the intent to interested receivers...</span></span><br><span class="line"><span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">         == <span class="number">0</span>) &#123;</span><br><span class="line">    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123;</span><br><span class="line">        <span class="comment">// Query one target user at a time, excluding shell-restricted users</span></span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                resolvedType, <span class="keyword">false</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个列表<code>receivers</code>和<code>registeredReceivers</code>，看名字好像是广播接收者的列表；下面是它们的赋值过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, <span class="keyword">false</span>, userId);</span><br></pre></td></tr></table></figure>
<p>读者可以自行跟踪这两个方法的代码，过程比较简单，我这里直接给出结论：</p>
<ol>
<li><code>receivers</code>是对这个广播感兴趣的<strong>静态BroadcastReceiver</strong>列表；collectReceiverComponents 通过PackageManager获取了与这个广播匹配的静态BroadcastReceiver信息；这里也证实了我们在分析BroadcasrReceiver注册过程中的推论——静态BroadcastReceiver的注册过程的确实在PMS中进行的。</li>
<li><code>mReceiverResolver</code>存储了<strong>动态注册</strong>的BroadcastReceiver的信息；还记得这个<code>mReceiverResolver</code>吗？我们在分析动态广播的注册过程中发现，动态注册的BroadcastReceiver的相关信息最终存储在此对象之中；在这里，通过mReceiverResolver对象匹配出了对应的BroadcastReceiver供进一步使用。</li>
</ol>
<p>现在系统通过PMS拿到了所有符合要求的静态BroadcastReceiver，然后从AMS中获取了符合要求的动态BroadcastReceiver；因此接下来的工作非常简单：唤醒这些广播接受者。简单来说就是回调它们的<code>onReceive</code>方法。</p>
<h4 id="接收过程">接收过程</h4><p>通过上文的分析过程我们知道，在AMS的broadcastIntentLocked方法中找出了符合要求的所有BroadcastReceiver；接下来就需要把这个广播分发到这些接收者之中。在broadcastIntentLocked方法的后半部分有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">        callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">        requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">        resultData, resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line"><span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">    queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">    queue.scheduleBroadcastsLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先创建了一个BroadcastRecord代表此次发送的这条广播，然后把它丢进一个队列，最后通过scheduleBroadcastsLocked通知队列对广播进行处理。</p>
<p>在BroadcastQueue中通过Handle调度了对于广播处理的消息，调度过程由processNextBroadcast方法完成，而这个方法通过performReceiveLocked最终调用了IIntentReceiver的performReceive方法。</p>
<p>这个<code>IIntentReceiver</code>正是在广播注册过程中由App进程提供给AMS进程的Binder对象，现在AMS通过这个Binder对象进行IPC调用通知广播接受者所在进程完成余下操作。在上文我们分析广播的注册过程中提到过，这个IItentReceiver的实现是LoadedApk.ReceiverDispatcher；我们查看这个对象的performReceive方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span><br><span class="line">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">    Args args = <span class="keyword">new</span> Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">    <span class="keyword">if</span> (!mActivityThread.post(args)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法创建了一个<code>Args</code>对象，然后把它post到了mActivityThread这个Handler中；我们查看<code>Args</code>类的<code>run</code>方法：(坚持一下，马上就分析完了 ^ ^)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BroadcastReceiver receiver = mReceiver;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> ordered = mOrdered;  </span><br><span class="line">    <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">    <span class="keyword">final</span> Intent intent = mCurIntent;</span><br><span class="line">    mCurIntent = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || mForgotten) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassLoader cl =  mReceiver.getClass().getClassLoader(); <span class="comment">// Important!! load class</span></span><br><span class="line">        intent.setExtrasClassLoader(cl);</span><br><span class="line">        setExtrasClassLoader(cl);</span><br><span class="line">        receiver.setPendingResult(<span class="keyword">this</span>);</span><br><span class="line">        receiver.onReceive(mContext, intent); <span class="comment">// callback</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mInstrumentation == <span class="keyword">null</span> ||</span><br><span class="line">                !mInstrumentation.onException(mReceiver, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Error receiving broadcast "</span> + intent</span><br><span class="line">                + <span class="string">" in "</span> + mReceiver, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们看到了相应BroadcastReceiver的<code>onReceive</code>回调；因此，广播的工作原理到这里就水落石出了；我们接下来将探讨如何实现对于广播的插件化。</p>
<h2 id="思路分析">思路分析</h2><p>上文中我们分析了BroadcastReceiver的工作原理，那么怎么才能实现对BroadcastReceiver的插件化呢？</p>
<p>从分析过程中我们发现，Framework对于静态广播和动态广播的处理是不同的；不过，这个不同之处仅仅体现在<strong>注册过程</strong>——静态广播需要在AndroidManifest.xml中注册，并且注册的信息存储在PMS中；动态广播不需要预注册，注册的信息存储在AMS中。</p>
<p>从实现Activity的插件化过程中我们知道，需要在AndroidManifest.xml中预先注册是一个相当麻烦的事情——我们需要使用『替身』并在合适的时候进行『偷梁换柱』；因此看起来动态广播的处理要容易那么一点，我们先讨论一下如何实现动态注册BroadcastReceiver的插件化。</p>
<p>首先，广播并没有复杂的生命周期，它的整个存活过程其实就是一个<code>onReceive</code>回调；而动态广播又不需要在AndroidManifest.xml中预先注册，所以动态注册的BroadcastReceiver其实可以当作一个普通的Java对象；我们完全可以用纯ClassLoader技术实现它——不就是把插件中的Receiver加载进来，然后想办法让它能接受<code>onReceive</code>回调嘛。</p>
<p>静态BroadcastReceiver看起来要复杂一些，但是我们连Activity都搞定了，还有什么难得到我们呢？对于实现静态BroadcastReceiver插件化的问题，有的童鞋或许会想，我们可以借鉴Activity的工作方式——用替身和Hook解决。但是很遗憾，这样是行不通的。为什么呢？</p>
<p>BroadcastReceiver有一个IntentFilter的概念，也就是说，每一个BroadcastReceiver只对特定的Broadcast感兴趣；而且，AMS在进行广播分发的时候，也会对这些BroadcastReceiver与发出的广播进行匹配，只有Intent匹配的Receiver才能收到广播；在分析源码的时候也提到了这个匹配过程。如果我们尝试用替身Receiver解决静态注册的问题，那么它的IntentFilter该写什么？我们无法预料插件中静态注册的Receiver会使用什么类型的IntentFilter，就算我们在AndroidManifest.xml中声明替身也没有用——我们压根儿收不到与我们的IntentFilter不匹配的广播。其实，我们对于Activity的处理方式也有这个问题；如果你尝试用IntentFilter的方式启动Activity，这并不能成功；这算得上是DroidPlugin的缺陷之一。</p>
<p>那么，我们就真的对静态BroadcastReceiver无能为力吗？想一想这里的难点是什么？</p>
<p>没错，主要是在静态BroadcastReceiver里面这个IntentFilter我们事先无法确定，它是动态变化的；但是，动态BroadcastReceiver不是可以动态添加IntentFilter吗！！！</p>
<p><strong>可以把静态广播当作动态广播处理</strong></p>
<p>既然都是广播，它们的功能都是订阅一个特定的消息然后执行某个特定的操作，我们完全可以把插件中的静态广播全部注册为动态广播，这样就解决了静态广播的问题。当然，这样也是有缺陷的，静态BroadcastReceiver与动态BroadcastReceiver一个非常大的不同之处在于：动态BroadcastReceiver在进程死亡之后是无法接收广播的，而静态BroadcastReceiver则可以——系统会唤醒Receiver所在进程；这算得上缺陷之二，当然，瑕不掩瑜。</p>
<h2 id="静态广播非静态的实现">静态广播非静态的实现</h2><p>上文我们提到，可以把静态BroadcastReceiver当作动态BroadcastReceiver处理；我们接下来实现这个过程。</p>
<h3 id="解析">解析</h3><p>要把插件中的静态BroadcastReceiver当作动态BroadcastReceiver处理，我们首先得知道插件中到底注册了哪些广播；这个过程归根结底就是获取AndroidManifest.xml中的&lt;receiver&gt;标签下面的内容，我们可以选择手动解析xml文件；这里我们选择使用系统的 PackageParser 帮助解析，这种方式在之前的 [插件加载过程][] 中也用到过，如果忘记了可以温习一下。</p>
<p>PackageParser中有一系列方法用来提取Apk中的信息，可是翻遍了这个类也没有找到与「Receiver」名字相关的方法；最终我们发现BroadcastReceiver信息是用与Activity相同的类存储的！这一点可以在PackageParser的内部类Package中发现端倪——成员变量<code>receivers</code>和<code>activities</code>的范型类型相同。所以，我们要解析apk的&lt;receiver&gt;的信息，可以使用PackageParser的<code>generateActivityInfo</code>方法。</p>
<p>知道这一点之后，代码就比较简单了；使用反射调用相应的隐藏接口，并且在必要的时候构造相应参数的方式我们在插件化系列文章中已经讲述过很多，相信读者已经熟练，这里就不赘述，直接贴代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parserReceivers</span><span class="params">(File apkFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; packageParserClass = Class.forName(<span class="string">"android.content.pm.PackageParser"</span>);</span><br><span class="line">    Method parsePackageMethod = packageParserClass.getDeclaredMethod(<span class="string">"parsePackage"</span>, File.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    Object packageParser = packageParserClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先调用parsePackage获取到apk对象对应的Package对象</span></span><br><span class="line">    Object packageObj = parsePackageMethod.invoke(packageParser, apkFile, PackageManager.GET_RECEIVERS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取Package对象里面的receivers字段,注意这是一个 List&lt;Activity&gt; (没错,底层把&lt;receiver&gt;当作&lt;activity&gt;处理)</span></span><br><span class="line">    <span class="comment">// 接下来要做的就是根据这个List&lt;Activity&gt; 获取到Receiver对应的 ActivityInfo (依然是把receiver信息用activity处理了)</span></span><br><span class="line">    Field receiversField = packageObj.getClass().getDeclaredField(<span class="string">"receivers"</span>);</span><br><span class="line">    List receivers = (List) receiversField.get(packageObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用generateActivityInfo 方法, 把PackageParser.Activity 转换成</span></span><br><span class="line">    Class&lt;?&gt; packageParser$ActivityClass = Class.forName(<span class="string">"android.content.pm.PackageParser$Activity"</span>);</span><br><span class="line">    Class&lt;?&gt; packageUserStateClass = Class.forName(<span class="string">"android.content.pm.PackageUserState"</span>);</span><br><span class="line">    Class&lt;?&gt; userHandler = Class.forName(<span class="string">"android.os.UserHandle"</span>);</span><br><span class="line">    Method getCallingUserIdMethod = userHandler.getDeclaredMethod(<span class="string">"getCallingUserId"</span>);</span><br><span class="line">    <span class="keyword">int</span> userId = (Integer) getCallingUserIdMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line">    Object defaultUserState = packageUserStateClass.newInstance();</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; componentClass = Class.forName(<span class="string">"android.content.pm.PackageParser$Component"</span>);</span><br><span class="line">    Field intentsField = componentClass.getDeclaredField(<span class="string">"intents"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要调用 android.content.pm.PackageParser#generateActivityInfo(android.content.pm.ActivityInfo, int, android.content.pm.PackageUserState, int)</span></span><br><span class="line">    Method generateReceiverInfo = packageParserClass.getDeclaredMethod(<span class="string">"generateActivityInfo"</span>,</span><br><span class="line">            packageParser$ActivityClass, <span class="keyword">int</span>.class, packageUserStateClass, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析出 receiver以及对应的 intentFilter</span></span><br><span class="line">    <span class="keyword">for</span> (Object receiver : receivers) &#123;</span><br><span class="line">        ActivityInfo info = (ActivityInfo) generateReceiverInfo.invoke(packageParser, receiver, <span class="number">0</span>, defaultUserState, userId);</span><br><span class="line">        List&lt;? extends IntentFilter&gt; filters = (List&lt;? extends IntentFilter&gt;) intentsField.get(receiver);</span><br><span class="line">        sCache.put(info, filters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册">注册</h3><p>我们已经解析得到了插件中静态注册的BroadcastReceiver的信息，现在我们只需要把这些静态广播动态注册一遍就可以了；但是，由于BroadcastReceiver的实现类存在于插件之后，我们需要手动用ClassLoader来加载它；这一点在 <a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">插件加载机制</a> 已有讲述，不啰嗦了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (ActivityInfo activityInfo : ReceiverHelper.sCache.keySet()) &#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"preload receiver:"</span> + activityInfo.name);</span><br><span class="line">    List&lt;? extends IntentFilter&gt; intentFilters = ReceiverHelper.sCache.get(activityInfo);</span><br><span class="line">    <span class="keyword">if</span> (cl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cl = CustomClassLoader.getPluginClassLoader(apk, activityInfo.packageName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把解析出来的每一个静态Receiver都注册为动态的</span></span><br><span class="line">    <span class="keyword">for</span> (IntentFilter intentFilter : intentFilters) &#123;</span><br><span class="line">        BroadcastReceiver receiver = (BroadcastReceiver) cl.loadClass(activityInfo.name).newInstance();</span><br><span class="line">        context.registerReceiver(receiver, intentFilter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这样，我们对插件静态BroadcastReceiver的支持已经完成了，是不是相当简单？至于插件中的动态广播如何实现插件化，这一点<strong>交给读者自行完成</strong>，希望你在解决这个问题的过程中能够加深对于插件方案的理解 ^ ^</p>
<h2 id="小节">小节</h2><p>本文我们介绍了BroadcastReceiver组件的插件化方式，可以看到，插件方案对于BroadcastReceiver的处理相对简单；同时「静态广播非静态」的特性以及BroadcastReceiver先天的一些特点导致插件方案没有办法做到尽善尽美，不过这都是大醇小疵——在绝大多数情况下，这样的处理方式是可以满足需求的。</p>
<p>虽然对于BroadcastReceiver的处理方式相对简单，但是文章的内容却并不短——我们花了大量的篇幅讲述BroadcastReceiver的原理，这也是我的初衷：借助DroidPlugin更深入地了解Android Framework。</p>
<p>接下来为文章会讲述四大组件中的另外两个——Service和ContentProvider的插件化方案；喜欢就点个赞吧～持续更新，请关注github项目 <a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">understand-plugin-framework</a> 和我的 <a href="http://weishu.me">博客</a> ! 如果你觉得能从文中学到皮毛，还请支持一下 :)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 以及 <a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">插件加载机制</a> 中我们详细讲述了插件化过程中对于Activity组件的处理方式，为了实现Activity的插件化我们付出了相当多的努力；那么Android系统的其他组件，比如BroadcastReceiver，Service还有ContentProvider，它们又该如何处理呢？</p>
<p>相比Activity，BroadcastReceiver要简单很多——广播的生命周期相当简单；如果希望插件能够支持广播，这意味着什么？</p>
<p>回想一下我们日常开发的时候是如何使用BroadcastReceiver的：<strong>注册</strong>, <strong>发送</strong>和<strong>接收</strong>；因此，要实现BroadcastReceiver的插件化就这三种操作提供支持；接下来我们将一步步完成这个过程。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework">understand-plugin-framework</a>，参考此项目的<code>receiver-management</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="broadcastreceiver" scheme="http://weishu.me/tags/broadcastreceiver/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 插件化原理解析——插件加载机制]]></title>
    <link href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/"/>
    <id>http://weishu.me/2016/04/05/understand-plugin-framework-classloader/</id>
    <published>2016-04-05T12:13:01.000Z</published>
    <updated>2016-04-12T11:09:45.000Z</updated>
    <content type="html"><![CDATA[<p>上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 中我们地完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的任务；通过Hook <code>AMS</code>和拦截ActivityThread中<code>H</code>类对于组件调度我们成功地绕过了AndroidMAnifest.xml的限制。</p>
<p>但是我们启动的『没有在AndroidManifet.xml中显式声明』的Activity和宿主程序存在于同一个Apk中；通常情况下，插件均以独立的文件存在甚至通过网络获取，这时候插件中的Activity能否成功启动呢？</p>
<p>要启动Activity组件肯定先要创建对应的Activity类的对象，从上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 知道，创建Activity类对象的过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">        cl, component.getClassName(), r.intent);</span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>也就是说，系统通过<code>ClassLoader</code>加载了需要的Activity类并通过反射调用构造函数创建出了Activity对象。如果Activity组件存在于独立于宿主程序的文件之中，系统的ClassLoader怎么知道去哪里加载呢？因此，如果不做额外的处理，插件中的Activity对象甚至都没有办法创建出来，谈何启动？</p>
<p>因此，要使存在于独立文件或者网络中的插件被成功启动，首先就需要解决这个<strong>插件类加载</strong>的问题。<br>下文将围绕此问题展开，完成『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的<code>classloader-hook</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<a id="more"></a>
<h2 id="ClassLoader机制">ClassLoader机制</h2><p>或许有的童鞋还不太了解Java的ClassLoader机制，我这里简要介绍一下。</p>
<blockquote>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校检、转换解析和初始化的，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br>与那些在编译时进行链连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以同代拓展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。例如，如果编写一个面相接口的应用程序，可以等到运行时在制定实际的实现类；用户可以通过Java与定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为代码的一部分，这种组装应用程序的方式目前已经广泛应用于Java程序之中。从最基础的Applet，JSP到复杂的OSGi技术，都使用了Java语言运行期类加载的特性。</p>
</blockquote>
<p>Java的类加载是一个相对复杂的过程；它包括加载、验证、准备、解析和初始化五个阶段；对于开发者来说，可控性最强的是<strong>加载阶段</strong>；加载阶段主要完成三件事：</p>
<ol>
<li>根据一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为JVM方法区中的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>『通过一个类的全限定名获取描述此类的二进制字节流』这个过程被抽象出来，就是Java的类加载器模块，也即JDK中ClassLoader API。</p>
<p>Android Framework提供了DexClassLoader这个类，简化了『通过一个类的全限定名获取描述次类的二进制字节流』这个过程；我们只需要告诉DexClassLoader一个dex文件或者apk文件的路径就能完成类的加载。因此本文的内容用一句话就可以概括：</p>
<p><strong>将插件的dex或者apk文件告诉『合适的』DexClassLoader，借助它完成插件类的加载</strong></p>
<p>关于CLassLoader机制更多的内容，请参阅『深入理解Java虚拟机』这本书。</p>
<h2 id="思路分析">思路分析</h2><p>Android系统使用了ClassLoader机制来进行Activity等组件的加载；apk被安装之后，APK文件的代码以及资源会被系统存放在固定的目录（比如/data/app/package_name/base-1.apk )系统在进行类加载的时候，会自动去这一个或者几个特定的路径来寻找这个类；但是系统并不知道存在于插件中的Activity组件的信息(插件可以是任意位置，甚至是网络，系统无法提前预知)，因此正常情况下系统无法加载我们插件中的类；因此也没有办法创建Activity的对象，更不用谈启动组件了。</p>
<p>解决这个问题有两个思路，要么全盘接管这个类加载的过程；要么告知系统我们使用的插件存在于哪里，让系统帮忙加载；这两种方式或多或少都需要<strong>干预</strong>这个类加载的过程。老规矩，知己知彼，百战不殆。我们首先分析一下，系统是如果完成这个类加载过程的。</p>
<p>我们再次搬出Activity的创建过程的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>这里可以很明显地看到，系统通过待启动的Activity的类名<code>className</code>，然后使用ClassLoader对象<code>cl</code>把这个类加载进虚拟机，最后使用反射创建了这个Activity类的实例对象。要想干预这个ClassLoader（告知它我们的路径或者替换他），我们首先得看看这玩意到底是个什么来头。（从哪里创建的）</p>
<p><code>cl</code>这个ClasssLoader对象通过<code>r.packageInfo</code>对象的getClassLoader()方法得到，r.packageInfo是一个LoadedApk类的对象；那么，LoadedApk到底是个什么东西？？</p>
<p>我们查阅LoadedApk类的文档，只有一句话，不过说的很明白：</p>
<blockquote>
<p>Local state maintained about a currently loaded .apk.</p>
</blockquote>
<p><strong>LoadedApk对象是APK文件在内存中的表示。</strong> Apk文件的相关信息，诸如Apk文件的代码和资源，甚至代码里面的Activity，Service等组件的信息我们都可以通过此对象获取。</p>
<p>OK, 我们知道这个LoadedApk是何方神圣了；接下来我们要搞清楚的是：这个 <code>r.packageInfo</code> 到底是从哪里获取的？</p>
<p>我们顺着 performLaunchActivity上溯，辗转handleLaunchActivity回到了 <code>H</code> 类的LAUNCH_ACTIVITY消息，找到了<code>r.packageInfo</code>的来源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">        r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">handleLaunchActivity(r, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>getPackageInfoNoCheck方法很简单，直接调用了getPackageInfo方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">getPackageInfoNoCheck</span><span class="params">(ApplicationInfo ai,</span><br><span class="line">        CompatibilityInfo compatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getPackageInfo(ai, compatInfo, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个getPackageInfo方法里面我们发现了端倪：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LoadedApk <span class="title">getPackageInfo</span><span class="params">(ApplicationInfo aInfo, CompatibilityInfo compatInfo,</span><br><span class="line">        ClassLoader baseLoader, <span class="keyword">boolean</span> securityViolation, <span class="keyword">boolean</span> includeCode,</span><br><span class="line">        <span class="keyword">boolean</span> registerPackage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取userid信息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));</span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">    <span class="comment">// 尝试获取缓存信息</span></span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        <span class="keyword">if</span> (differentUser) &#123;</span><br><span class="line">            <span class="comment">// Caching not supported across users</span></span><br><span class="line">            ref = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">            ref = mPackages.get(aInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ref = mResourcePackages.get(aInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LoadedApk packageInfo = ref != <span class="keyword">null</span> ? ref.get() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span> || (packageInfo.mResources != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">                <span class="comment">// 缓存没有命中，直接new</span></span><br><span class="line">            packageInfo =</span><br><span class="line">                <span class="keyword">new</span> LoadedApk(<span class="keyword">this</span>, aInfo, compatInfo, baseLoader,</span><br><span class="line">                        securityViolation, includeCode &amp;&amp;</span><br><span class="line">                        (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != <span class="number">0</span>, registerPackage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略。。更新缓存</span></span><br><span class="line">        <span class="keyword">return</span> packageInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很重要，我们必须弄清楚每一步；</p>
<p>首先，它判断了调用方和或许App信息的一方是不是同一个userId；如果是同一个user，那么可以共享缓存数据（要么缓存的代码数据，要么缓存的资源数据）</p>
<p>接下来尝试获取缓存数据；如果没有命中缓存数据，才通过LoadedApk的构造函数创建了LoadedApk对象；创建成功之后，如果是同一个uid还放入了缓存。</p>
<p>提到缓存数据，看过<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Hook机制之Binder Hook</a>的童鞋可能就知道了，我们之前成功借助ServiceManager的本地代理使用缓存的机制Hook了各种Binder；因此这里完全可以如法炮制——我们拿到这一份缓存数据，修改里面的ClassLoader；自己控制类加载的过程，这样加载插件中的Activity类的问题就解决了。这就引出了我们加载插件类的第一种方案：</p>
<h2 id="激进方案：Hook掉ClassLoader，自己操刀">激进方案：Hook掉ClassLoader，自己操刀</h2><p>从上述分析中我们得知，在获取LoadedApk的过程中使用了一份缓存数据；这个缓存数据是一个<code>Map</code>，从包名到LoadedApk的一个映射。正常情况下，我们的插件肯定不会存在于这个对象里面；但是<strong>如果我们手动把我们插件的信息添加到里面呢？</strong>系统在查找缓存的过程中，会直接命中缓存！进而使用我们添加进去的LoadedApk的ClassLoader来加载这个特定的Activity类！这样我们就能接管我们自己插件类的加载过程了！</p>
<!--但是，细心的读者可能会发现；缓存命中还有一个条件——UID相同，因此我们需要**共享UID**-->
<p>这个缓存对象<code>mPackages</code>存在于ActivityThread类中；老方法，我们首先获取这个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到 mPackages 这个静态成员变量, 这里缓存了dex包的信息</span></span><br><span class="line">Field mPackagesField = activityThreadClass.getDeclaredField(<span class="string">"mPackages"</span>);</span><br><span class="line">mPackagesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Map mPackages = (Map) mPackagesField.get(currentActivityThread);</span><br></pre></td></tr></table></figure>
<p>拿到这个Map之后接下来怎么办呢？<strong>我们需要填充这个map，把插件的信息塞进这个map里面</strong>，以便系统在查找的时候能命中缓存。但是这个填充这个Map我们出了需要包名之外，还需要一个LoadedApk对象；如何创建一个LoadedApk对象呢？</p>
<p>我们当然可以直接反射调用它的构造函数直接创建出需要的对象，但是万一哪里有疏漏，构造参数填错了怎么办？又或者Android的不同版本使用了不同的参数，导致我们创建出来的对象与系统创建出的对象不一致，无法work怎么办？</p>
<p>因此我们需要使用与系统完全相同的方式创建LoadedApk对象；从上文分析得知，系统创建LoadedApk对象是通过<code>getPackageInfo</code>来完成的，因此我们可以调用这个函数来创建LoadedApk对象；但是这个函数是<code>private</code>的，我们无法使用。</p>
<p>有的童鞋可能会有疑问了，<code>private</code>不是也能反射到吗？我们确实能够调用这个函数，但是<code>private</code>表明这个函数是内部实现，或许那一天Google高兴，把这个函数改个名字我们就直接GG了；但是public函数不同，public被导出的函数你无法保证是否有别人调用它，因此大部分情况下不会修改；我们最好调用public函数来保证尽可能少的遇到兼容性问题。（当然，如果实在木有路可以考虑调用私有方法，自己处理兼容性问题，这个我们以后也会遇到）</p>
<p>间接调用<code>getPackageInfo</code>这个私有函数的public函数有同名的getPackageInfo系列和getPackageInfoNoCheck；简单查看源代码发现，getPackageInfo除了获取包的信息，还检查了包的一些组件；为了绕过这些验证，我们选择使用<code>getPackageInfoNoCheck</code>获取LoadedApk信息。</p>
<h3 id="构建插件LoadedApk对象">构建插件LoadedApk对象</h3><p>我们这一步的目的很明确，通过getPackageInfoNoCheck函数创建出我们需要的LoadedApk对象，以供接下来使用。</p>
<p>这个函数的签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">getPackageInfoNoCheck</span><span class="params">(ApplicationInfo ai,</span><br><span class="line">            CompatibilityInfo compatInfo)</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>因此，为了调用这个函数，我们需要构造两个参数。其一是ApplicationInfo，其二是CompatibilityInfo；第二个参数顾名思义，代表这个App的兼容性信息，比如targetSDK版本等等，这里我们只需要提取出app的信息，因此直接使用默认的兼容性即可；在CompatibilityInfo类里面有一个公有字段DEFAULT_COMPATIBILITY_INFO代表默认兼容性信息；因此，我们的首要目标是获取这个ApplicationInfo信息。</p>
<h3 id="构建插件ApplicationInfo信息">构建插件ApplicationInfo信息</h3><p>我们首先看看ApplicationInfo代表什么，这个类的文档说的很清楚：</p>
<blockquote>
<p>Information you can retrieve about a particular application.  This corresponds to information collected from the AndroidManifest.xml’s &lt;application&gt; tag.</p>
</blockquote>
<p>也就是说，这个类就是AndroidManifest.xml里面的<application> 这个标签下面的信息；这个AndroidManifest.xml无疑是一个标准的xml文件，因此我们完全可以自己使用parse来解析这个信息。</application></p>
<p>那么，系统是如何获取这个信息的呢？其实Framework就有一个这样的parser，也即PackageParser；理论上，我们也可以借用系统的parser来解析AndroidMAnifest.xml从而得到ApplicationInfo的信息。但遗憾的是，<strong>这个类的兼容性很差</strong>；Google几乎在每一个Android版本都对这个类动刀子，如果坚持使用系统的解析方式，必须写一系列兼容行代码！！DroidPlugin就选择了这种方式，相关类如下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829051777.png" width="283" alt="DroidPlugin的PackageParser"></p>
<p>看到这里我就问你怕不怕！！！这也是我们之前提到的<strong>私有或者隐藏的API可以使用，但必须处理好兼容性问题</strong>；如果Android 7.0发布，这里估计得添加一个新的类PackageParseApi24。</p>
<p>我这里使用API 23作为演示，<strong>版本不同的可能无法运行</strong>请自行查阅 DroidPlugin 不同版本如何处理。</p>
<p>OK回到正题，我们决定使用PackageParser类来提取ApplicationInfo信息。下图是API 23上，PackageParser的部分类结构图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1459829674687.png" width="481"></p>
<p>看起来有我们需要的方法 generateApplication；确实如此，依靠这个方法我们可以成功地拿到ApplicationInfo。<br>由于PackageParser是@hide的，因此我们需要通过反射进行调用。我们根据这个generateApplicationInfo方法的签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationInfo <span class="title">generateApplicationInfo</span><span class="params">(Package p, <span class="keyword">int</span> flags,</span><br><span class="line">   PackageUserState state)</span></span></span><br></pre></td></tr></table></figure>
<p>可以写出调用generateApplicationInfo的反射代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; packageParserClass = Class.forName(<span class="string">"android.content.pm.PackageParser"</span>);</span><br><span class="line"><span class="comment">// 首先拿到我们得终极目标: generateApplicationInfo方法</span></span><br><span class="line"><span class="comment">// API 23 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment">// public static ApplicationInfo generateApplicationInfo(Package p, int flags,</span></span><br><span class="line"><span class="comment">//    PackageUserState state) &#123;</span></span><br><span class="line"><span class="comment">// 其他Android版本不保证也是如此.</span></span><br><span class="line">Class&lt;?&gt; packageParser$PackageClass = Class.forName(<span class="string">"android.content.pm.PackageParser$Package"</span>);</span><br><span class="line">Class&lt;?&gt; packageUserStateClass = Class.forName(<span class="string">"android.content.pm.PackageUserState"</span>);</span><br><span class="line">Method generateApplicationInfoMethod = packageParserClass.getDeclaredMethod(<span class="string">"generateApplicationInfo"</span>,</span><br><span class="line">        packageParser$PackageClass,</span><br><span class="line">        <span class="keyword">int</span>.class,</span><br><span class="line">                packageUserStateClass);</span><br></pre></td></tr></table></figure>
<p>要成功调用这个方法，还需要三个参数；因此接下来我们需要一步一步构建调用此函数的参数信息。</p>
<h4 id="构建PackageParser-Package">构建PackageParser.Package</h4><p>generateApplicationInfo方法需要的第一个参数是PackageParser.Package；从名字上看这个类代表某个apk包的信息，我们看看文档怎么解释：</p>
<blockquote>
<p>Representation of a full package parsed from APK files on disk. A package consists of a single base APK, and zero or more split APKs.</p>
</blockquote>
<p>果然，这个类代表从PackageParser中解析得到的某个apk包的信息，是磁盘上apk文件在内存中的数据结构表示；因此，要获取这个类，肯定需要解析整个apk文件。PackageParser中解析apk的核心方法是parsePackage，这个方法返回的就是一个Package类型的实例，因此我们调用这个方法即可；使用反射代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先, 我们得创建出一个Package对象出来供这个方法调用</span></span><br><span class="line"><span class="comment">// 而这个需要得对象可以通过 android.content.pm.PackageParser#parsePackage 这个方法返回得 Package对象得字段获取得到</span></span><br><span class="line"><span class="comment">// 创建出一个PackageParser对象供使用</span></span><br><span class="line">Object packageParser = packageParserClass.newInstance();</span><br><span class="line"><span class="comment">// 调用 PackageParser.parsePackage 解析apk的信息</span></span><br><span class="line">Method parsePackageMethod = packageParserClass.getDeclaredMethod(<span class="string">"parsePackage"</span>, File.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上是一个 android.content.pm.PackageParser.Package 对象</span></span><br><span class="line">Object packageObj = parsePackageMethod.invoke(packageParser, apkFile, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这样，我们就得到了generateApplicationInfo的第一个参数；第二个参数是解析包使用的flag，我们直接选择解析全部信息，也就是0；</p>
<h4 id="构建PackageUserState">构建PackageUserState</h4><p>第三个参数是PackageUserState，代表不同用户中包的信息。由于Android是一个多任务多用户系统，因此不同的用户同一个包可能有不同的状态；这里我们只需要获取包的信息，因此直接使用默认的即可；</p>
<p>至此，generateApplicaionInfo的参数我们已经全部构造完成，直接调用此方法即可得到我们需要的applicationInfo对象；在返回之前我们需要做一点小小的修改：使用系统系统的这个方法解析得到的ApplicationInfo对象中并没有apk文件本身的信息，所以我们把解析的apk文件的路径设置一下（ClassLoader依赖dex文件以及apk的路径）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三个参数 mDefaultPackageUserState 我们直接使用默认构造函数构造一个出来即可</span></span><br><span class="line">Object defaultPackageUserState = packageUserStateClass.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 万事具备!!!!!!!!!!!!!!</span></span><br><span class="line">ApplicationInfo applicationInfo = (ApplicationInfo) generateApplicationInfoMethod.invoke(packageParser,</span><br><span class="line">        packageObj, <span class="number">0</span>, defaultPackageUserState);</span><br><span class="line">String apkPath = apkFile.getPath();</span><br><span class="line">applicationInfo.sourceDir = apkPath;</span><br><span class="line">applicationInfo.publicSourceDir = apkPath;</span><br></pre></td></tr></table></figure>
<h3 id="替换ClassLoader">替换ClassLoader</h3><h4 id="获取LoadedApk信息">获取LoadedApk信息</h4><p>方才为了获取ApplicationInfo我们费了好大一番精力；回顾一下我们的初衷：</p>
<p>我们最终的目的是调用getPackageInfoNoCheck得到LoadedApk的信息，并替换其中的mClassLoader然后把把添加到ActivityThread的mPackages缓存中；从而达到我们使用自己的ClassLoader加载插件中的类的目的。</p>
<p>现在我们已经拿到了getPackageInfoNoCheck这个方法中至关重要的第一个参数applicationInfo；上文提到第二个参数CompatibilityInfo代表设备兼容性信息，直接使用默认的值即可；因此，两个参数都已经构造出来，我们可以调用getPackageInfoNoCheck获取LoadedApk：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.content.res.CompatibilityInfo</span></span><br><span class="line">Class&lt;?&gt; compatibilityInfoClass = Class.forName(<span class="string">"android.content.res.CompatibilityInfo"</span>);</span><br><span class="line">Method getPackageInfoNoCheckMethod = activityThreadClass.getDeclaredMethod(<span class="string">"getPackageInfoNoCheck"</span>, ApplicationInfo.class, compatibilityInfoClass);</span><br><span class="line"></span><br><span class="line">Field defaultCompatibilityInfoField = compatibilityInfoClass.getDeclaredField(<span class="string">"DEFAULT_COMPATIBILITY_INFO"</span>);</span><br><span class="line">defaultCompatibilityInfoField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Object defaultCompatibilityInfo = defaultCompatibilityInfoField.get(<span class="keyword">null</span>);</span><br><span class="line">ApplicationInfo applicationInfo = generateApplicationInfo(apkFile);</span><br><span class="line"></span><br><span class="line">Object loadedApk = getPackageInfoNoCheckMethod.invoke(currentActivityThread, applicationInfo, defaultCompatibilityInfo);</span><br></pre></td></tr></table></figure>
<p>我们成功地构造出了LoadedAPK, 接下来我们需要替换其中的ClassLoader，然后把它添加进ActivityThread的mPackages中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String odexPath = Utils.getPluginOptDexDir(applicationInfo.packageName).getPath();</span><br><span class="line">String libDir = Utils.getPluginLibDir(applicationInfo.packageName).getPath();</span><br><span class="line">ClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(apkFile.getPath(), odexPath, libDir, ClassLoader.getSystemClassLoader());</span><br><span class="line">Field mClassLoaderField = loadedApk.getClass().getDeclaredField(<span class="string">"mClassLoader"</span>);</span><br><span class="line">mClassLoaderField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">mClassLoaderField.set(loadedApk, classLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于是弱引用, 因此我们必须在某个地方存一份, 不然容易被GC; 那么就前功尽弃了.</span></span><br><span class="line">sLoadedApk.put(applicationInfo.packageName, loadedApk);</span><br><span class="line"></span><br><span class="line">WeakReference weakReference = <span class="keyword">new</span> WeakReference(loadedApk);</span><br><span class="line">mPackages.put(applicationInfo.packageName, weakReference);</span><br></pre></td></tr></table></figure>
<p>我们的这个CustomClassLoader非常简单，直接继承了DexClassLoader，什么都没有做；当然这里可以直接使用DexClassLoader，这里重新创建一个类是为了更有区分度；以后也可以通过修改这个类实现对于类加载的控制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">DexClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, optimizedDirectory, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们已经成功地把把插件的信息放入ActivityThread中，这样我们插件中的类能够成功地被加载；因此插件中的Activity实例能被成功第创建；由于整个流程较为复杂，我们简单梳理一下：</p>
<ol>
<li>在ActivityThread接收到IApplication的 scheduleLaunchActivity远程调用之后，将消息转发给<code>H</code></li>
<li><code>H</code>类在handleMessage的时候，调用了getPackageInfoNoCheck方法来获取待启动的组件信息。在这个方法中会优先查找<code>mPackages</code>中的缓存信息，而我们已经手动把插件信息添加进去；因此能够成功命中缓存，获取到独立存在的插件信息。</li>
<li><code>H</code>类然后调用handleLaunchActivity最终转发到performLaunchActivity方法；这个方法使用从getPackageInfoNoCheck中拿到LoadedApk中的mClassLoader来加载Activity类，进而使用反射创建Activity实例；接着创建Application，Context等完成Activity组件的启动。</li>
</ol>
<p>看起来好像已经天衣无缝万事大吉了；但是运行一下会出现一个异常，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">04</span>-<span class="number">05</span> <span class="number">02</span>:<span class="number">49</span>:<span class="number">53.742</span>  <span class="number">11759</span>-<span class="number">11759</span>/com.weishu.upf.hook_classloader E/AndroidRuntime﹕ FATAL EXCEPTION: main</span><br><span class="line">    Process: com.weishu.upf.hook_classloader, PID: <span class="number">11759</span></span><br><span class="line">    java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.weishu.upf.ams_pms_hook.app/com.weishu.upf.ams_pms_hook.app.MainActivity&#125;: java.lang.RuntimeException: Unable to instantiate application android.app.Application: java.lang.IllegalStateException: Unable to get <span class="keyword">package</span> info <span class="keyword">for</span> com.weishu.upf.ams_pms_hook.app; is <span class="keyword">package</span> not installed?</span><br></pre></td></tr></table></figure>
<p>错误提示说是无法实例化 <code>Application</code>，而Application的创建也是在performLaunchActivity中进行的，这里有些蹊跷，我们仔细查看一下。</p>
<h4 id="绕过系统检查">绕过系统检查</h4><p>通过ActivityThread的performLaunchActivity方法可以得知，Application通过LoadedApk的makeApplication方法创建，我们查看这个方法，在源码中发现了上文异常抛出的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (!mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">        initializeJavaContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">    app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">            cl, appClass, appContext);</span><br><span class="line">    appContext.setOuterContext(app);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Unable to instantiate application "</span> + appClass</span><br><span class="line">            + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>木有办法，我们只有一行一行地查看到底是哪里抛出这个异常的了；所幸代码不多。（所以说，缩小异常范围是一件多么重要的事情！！！）</p>
<p>第一句 getClassLoader() 没什么可疑的，虽然方法很长，但是它木有抛出任何异常（当然，它调用的代码可能抛出异常，万一找不到只能进一步深搜了；所以我觉得这里应该使用受检异常）。</p>
<p>然后我们看第二句，如果包名不是<code>android</code>开头，那么调用了一个叫做initializeJavaContextClassLoader的方法；我们查阅这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeJavaContextClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    android.content.pm.PackageInfo pi;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pi = pm.getPackageInfo(mPackageName, <span class="number">0</span>, UserHandle.myUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to get package info for "</span></span><br><span class="line">                + mPackageName + <span class="string">"; is system dying?"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pi == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to get package info for "</span></span><br><span class="line">                + mPackageName + <span class="string">"; is package not installed?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> sharedUserIdSet = (pi.sharedUserId != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">boolean</span> processNameNotDefault =</span><br><span class="line">        (pi.applicationInfo != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">         !mPackageName.equals(pi.applicationInfo.processName));</span><br><span class="line">    <span class="keyword">boolean</span> sharable = (sharedUserIdSet || processNameNotDefault);</span><br><span class="line">    ClassLoader contextClassLoader =</span><br><span class="line">        (sharable)</span><br><span class="line">        ? <span class="keyword">new</span> WarningContextClassLoader()</span><br><span class="line">        : mClassLoader;</span><br><span class="line">    Thread.currentThread().setContextClassLoader(contextClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们找出了这个异常的来源：原来这里调用了<code>getPackageInfo</code>方法获取包的信息；而我们的插件<strong>并没有安装在系统上</strong>，因此系统肯定认为插件没有安装，这个方法肯定返回null。所以，我们还要欺骗一下PMS，让系统觉得<strong>插件已经安装在系统上了</strong>；至于如何欺骗 PMS，<a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Hook机制之AMS&amp;PMS</a> 有详细解释，这里直接给出代码，不赘述了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookPackageManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一步是因为 initializeJavaContextClassLoader 这个方法内部无意中检查了这个包是否在系统安装</span></span><br><span class="line">    <span class="comment">// 如果没有安装, 直接抛出异常, 这里需要临时Hook掉 PMS, 绕过这个检查.</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">    currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取ActivityThread里面原始的 sPackageManager</span></span><br><span class="line">    Field sPackageManagerField = activityThreadClass.getDeclaredField(<span class="string">"sPackageManager"</span>);</span><br><span class="line">    sPackageManagerField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备好代理对象, 用来替换原始的对象</span></span><br><span class="line">    Class&lt;?&gt; iPackageManagerInterface = Class.forName(<span class="string">"android.content.pm.IPackageManager"</span>);</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iPackageManagerInterface &#125;,</span><br><span class="line">            <span class="keyword">new</span> IPackageManagerHookHandler(sPackageManager));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 替换掉ActivityThread里面的 sPackageManager 字段</span></span><br><span class="line">    sPackageManagerField.set(currentActivityThread, proxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK到这里，我们已经能够成功地加载<strong>简单的</strong>独立的存在于外部文件系统中的apk了。至此 关于 DroidPlugin 对于Activity生命周期的管理已经完全讲解完毕了；这是一种极其复杂的Activity管理方案，我们仅仅写一个用来理解的demo就Hook了相当多的东西，在Framework层来回牵扯；这其中的来龙去脉要完全把握清楚还请读者亲自翻阅源码。另外，我在此 对DroidPlugin 作者献上我的膝盖～这其中的玄妙让人叹为观止！</p>
<p>上文给出的方案中，我们全盘接管了插件中类的加载过程，这是一种相对暴力的解决方案；能不能更温柔一点呢？通俗来说，我们可以选择改革，而不是革命——告诉系统ClassLoader一些必要信息，让它帮忙完成插件类的加载。</p>
<h2 id="保守方案：委托系统，让系统帮忙加载">保守方案：委托系统，让系统帮忙加载</h2><p>我们再次搬出ActivityThread中加载Activity类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">        cl, component.getClassName(), r.intent);</span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>我们知道 这个r.packageInfo中的<code>r</code>是通过getPackageInfoNoCheck获取到的；在『激进方案』中我们把插件apk手动添加进缓存，采用自己加载办法解决；如果我们不干预这个过程，导致无法命中mPackages中的缓存，会发生什么？</p>
<p>查阅 getPackageInfo方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LoadedApk <span class="title">getPackageInfo</span><span class="params">(ApplicationInfo aInfo, CompatibilityInfo compatInfo,</span><br><span class="line">        ClassLoader baseLoader, <span class="keyword">boolean</span> securityViolation, <span class="keyword">boolean</span> includeCode,</span><br><span class="line">        <span class="keyword">boolean</span> registerPackage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));</span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        <span class="keyword">if</span> (differentUser) &#123;</span><br><span class="line">            <span class="comment">// Caching not supported across users</span></span><br><span class="line">            ref = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">            ref = mPackages.get(aInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ref = mResourcePackages.get(aInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LoadedApk packageInfo = ref != <span class="keyword">null</span> ? ref.get() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span> || (packageInfo.mResources != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">            packageInfo =</span><br><span class="line">                <span class="keyword">new</span> LoadedApk(<span class="keyword">this</span>, aInfo, compatInfo, baseLoader,</span><br><span class="line">                        securityViolation, includeCode &amp;&amp;</span><br><span class="line">                        (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != <span class="number">0</span>, registerPackage);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，没有命中缓存的情况下，系统直接new了一个LoadedApk；注意这个构造函数的第二个参数<code>aInfo</code>，这是一个ApplicationInfo类型的对象。在『激进方案』中我们为了获取独立插件的ApplicationInfo花了不少心思；那么如果不做任何处理这里传入的这个<code>aInfo</code>参数是什么？</p>
<p>追本溯源不难发现，这个aInfo是从我们的替身StubActivity中获取的！而StubActivity存在于宿主程序中，所以，这个<code>aInfo</code>对象代表的实际上就是宿主程序的Application信息！</p>
<p>我们知道，接下来会使用new出来的这个LoadedApk的getClassLoader()方法获取到ClassLoader来对插件的类进行加载；而获取到的这个ClassLoader是宿主程序使用的ClassLoader，因此现在还无法加载插件的类；那么，<strong>我们能不能让宿主的ClasLoader获得加载插件类的能力呢？</strong>；如果我们告诉宿主使用的ClassLoader插件使用的类在哪里，就能帮助他完成加载！</p>
<h3 id="宿主的ClassLoader在哪里，是唯一的吗？">宿主的ClassLoader在哪里，是唯一的吗？</h3><p>上面说到，我们可以通过告诉宿主程序的ClassLoader插件使用的类，让宿主的ClasLoader完成对于插件类的加载；那么问题来了，我们如何获取到宿主的ClassLoader？宿主程序使用的ClasLoader默认情况下是全局唯一的吗？</p>
<p>答案是肯定的。</p>
<p>因为在FrameWork中宿主程序也是使用LoadedApk表示的，如同Activity启动是加载Activity类一样，宿主中的类也都是通过LoadedApk的getClassLoader()方法得到的ClassLoader加载的；由类加载机制的『双亲委派』特性，只要有一个应用程序类由某一个ClassLoader加载，那么它引用到的别的类除非父加载器能加载，否则都是由这同一个加载器加载的（不遵循双亲委派模型的除外）。</p>
<p>表示宿主的LoadedApk在Application类中有一个成员变量<code>mLoadedApk</code>，而这个变量是从ContextImpl中获取的；ContextImpl重写了getClassLoader方法，因此<strong>我们在Context环境中直接getClassLoader()获取到的就是宿主程序唯一的ClassLoader</strong>。</p>
<h3 id="LoadedApk的ClassLoader到底是什么？">LoadedApk的ClassLoader到底是什么？</h3><p>现在我们确保了『使用宿主ClassLoader帮助加载插件类』可行性；那么我们应该如何完成这个过程呢？</p>
<p>知己知彼，百战不殆。</p>
<p>不论是宿主程序还是插件程序都是通过LoadedApk的getClassLoader()方法返回的ClassLoader进行类加载的，返回的这个ClassLoader到底是个什么东西？？这个方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mIncludeCode &amp;&amp; !mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 略...</span></span><br><span class="line">            mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib,</span><br><span class="line">                    mBaseClassLoader);</span><br><span class="line"></span><br><span class="line">            StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBaseClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mClassLoader = mBaseClassLoader;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，非<code>android</code>开头的包和<code>android</code>开头的包分别使用了两种不同的ClassLoader，我们只关心第一种；因此继续跟踪ApplicationLoaders类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">(String zip, String libPath, ClassLoader parent)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLoaders) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = baseParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent == baseParent) &#123;</span><br><span class="line">            ClassLoader loader = mLoaders.get(zip);</span><br><span class="line">            <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> loader;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">            PathClassLoader pathClassloader =</span><br><span class="line">                <span class="keyword">new</span> PathClassLoader(zip, libPath, parent);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">            mLoaders.put(zip, pathClassloader);</span><br><span class="line">            <span class="keyword">return</span> pathClassloader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">        PathClassLoader pathClassloader = <span class="keyword">new</span> PathClassLoader(zip, parent);</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        <span class="keyword">return</span> pathClassloader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，应用程序使用的ClassLoader都是PathClassLoader类的实例。那么，这个PathClassLoader是什么呢？从Android SDK给出的源码只能看出这么多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((String)<span class="keyword">null</span>, (File)<span class="keyword">null</span>, (String)<span class="keyword">null</span>, (ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDK没有导出这个类的源码，我们去<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java" target="_blank" rel="external">androidxref</a>上面看；发现其实这个类真的就这么多内容；我们继续查看它的父类<a href="http://androidxref.com/6.0.1_r10/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="external">BaseDexClassLoader</a>；ClassLoader嘛，我们查看findClass或者defineClass方法，BaseDexClassLoader的findClass方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">        <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">            cnfe.addSuppressed(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> cnfe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，查找Class的任务通过<code>pathList</code>完成；这个<code>pathList</code>是一个<code>DexPathList</code>类的对象，它的<code>findClass</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">       DexFile dex = element.dexFile;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">           <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> clazz;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">       suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个DexPathList内部有一个叫做dexElements的数组，然后findClass的时候会遍历这个数组来查找Class；<strong>如果我们把插件的信息塞进这个数组里面，那么不就能够完成类的加载过程吗？！！</strong></p>
<h3 id="给默认ClassLoader打补丁">给默认ClassLoader打补丁</h3><p>通过上述分析，我们知道，可以把插件的相关信息放入BaseDexClassLoader的表示dex文件的数组里面，这样宿主程序的ClassLoader在进行类加载，遍历这个数组的时候，会自动遍历到我们添加进去的插件信息，从而完成插件类的加载！</p>
<p>接下来，我们实现这个过程；我们会用到一些较为复杂的反射技术哦～不过代码非常短：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patchClassLoader</span><span class="params">(ClassLoader cl, File apkFile, File optDexFile)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, NoSuchMethodException, IOException, InvocationTargetException, InstantiationException, NoSuchFieldException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 BaseDexClassLoader : pathList</span></span><br><span class="line">    Field pathListField = DexClassLoader.class.getSuperclass().getDeclaredField(<span class="string">"pathList"</span>);</span><br><span class="line">    pathListField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object pathListObj = pathListField.get(cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 PathList: Element[] dexElements</span></span><br><span class="line">    Field dexElementArray = pathListObj.getClass().getDeclaredField(<span class="string">"dexElements"</span>);</span><br><span class="line">    dexElementArray.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object[] dexElements = (Object[]) dexElementArray.get(pathListObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Element 类型</span></span><br><span class="line">    Class&lt;?&gt; elementClass = dexElements.getClass().getComponentType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个数组, 用来替换原始的数组</span></span><br><span class="line">    Object[] newElements = (Object[]) Array.newInstance(elementClass, dexElements.length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造插件Element(File file, boolean isDirectory, File zip, DexFile dexFile) 这个构造函数</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = elementClass.getConstructor(File.class, <span class="keyword">boolean</span>.class, File.class, DexFile.class);</span><br><span class="line">    Object o = constructor.newInstance(apkFile, <span class="keyword">false</span>, apkFile, DexFile.loadDex(apkFile.getCanonicalPath(), optDexFile.getAbsolutePath(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Object[] toAddElementArray = <span class="keyword">new</span> Object[] &#123; o &#125;;</span><br><span class="line">    <span class="comment">// 把原始的elements复制进去</span></span><br><span class="line">    System.arraycopy(dexElements, <span class="number">0</span>, newElements, <span class="number">0</span>, dexElements.length);</span><br><span class="line">    <span class="comment">// 插件的那个element复制进去</span></span><br><span class="line">    System.arraycopy(toAddElementArray, <span class="number">0</span>, newElements, dexElements.length, toAddElementArray.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换</span></span><br><span class="line">    dexElementArray.set(pathListObj, newElements);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>短短的二十几行代码，我们就完成了『委托宿主ClassLoader加载插件类』的任务；因此第二种方案也宣告完成！我们简要总结一下这种方式的原理：</p>
<ol>
<li>默认情况下performLacunchActivity会使用替身StubActivity的ApplicationInfo也就是宿主程序的CLassLoader加载所有的类；我们的思路是告诉宿主ClassLoader我们在哪，让其帮助完成类加载的过程。</li>
<li>宿主程序的ClassLoader最终继承自BaseDexClassLoader，BaseDexClassLoader通过DexPathList进行类的查找过程；而这个查找通过遍历一个dexElements的数组完成；<strong>我们通过把插件dex添加进这个数组</strong>就让宿主ClasLoader获取了加载插件类的能力。</li>
</ol>
<h2 id="小结">小结</h2><p>本文中我们采用两种方案成功完成了『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>『激进方案』中我们自定义了插件的ClassLoader，并且绕开了Framework的检测；利用ActivityThread对于LoadedApk的缓存机制，我们把携带这个自定义的ClassLoader的插件信息添加进<code>mPackages</code>中，进而完成了类的加载过程。</p>
<p>『保守方案』中我们深入探究了系统使用ClassLoader findClass的过程，发现应用程序使用的非系统类都是通过同一个PathClassLoader加载的；而这个类的最终父类BaseDexClassLoader通过DexPathList完成类的查找过程；我们hack了这个查找过程，从而完成了插件类的加载。</p>
<p>这两种方案孰优孰劣呢？</p>
<p>很显然，『激进方案』比较麻烦，从代码量和分析过程就可以看出来，这种机制异常复杂；而且在解析apk的时候我们使用的PackageParser的兼容性非常差，我们不得不手动处理每一个版本的apk解析api；另外，它Hook的地方也有点多：不仅需要Hook AMS和<code>H</code>，还需要Hook ActivityThread的<code>mPackages</code>和PackageManager！</p>
<p>『保守方案』则简单得多（虽然原理也不简单），不仅代码很少，而且Hook的地方也不多；有一点正本清源的意思，从最最上层Hook住了整个类的加载过程。</p>
<p>但是，我们不能简单地说『保守方案』比『激进方案』好。从根本上说，这两种方案的差异在哪呢？</p>
<p>『激进方案』是<strong>多ClassLoader构架</strong>，每一个插件都有一个自己的ClassLoader，因此类的隔离性非常好——如果不同的插件使用了同一个库的不同版本，它们相安无事！『保守方案』是<strong>单ClassLoader方案</strong>，插件和宿主程序的类全部都通过宿主的ClasLoader加载，虽然代码简单，但是鲁棒性很差；一旦插件之间甚至插件与宿主之间使用的类库有冲突，那么直接GG。</p>
<p>多ClassLoader还有一个优点：可以真正完成代码的热加载！如果插件需要升级，直接重新创建一个自定的ClassLoader加载新的插件，然后替换掉原来的版本即可（Java中，不同ClassLoader加载的同一个类被认为是不同的类）；单ClassLoader的话实现非常麻烦，有可能需要重启进程。</p>
<p>在J2EE领域中广泛使用ClasLoader的地方均采用多ClassLoader架构，比如Tomcat服务器，Java模块化事实标准的OSGi技术；所以，我们有足够的理由认为<strong>选择多ClassLoader架构在大多数情况下是明智之举</strong>。</p>
<p>目前开源的插件方案中，DroidPlugin采用的『激进方案』，Small采用的『保守方案』那么，有没有两种优点兼顾的方案呢？？</p>
<p>答案自然是有的。</p>
<p>DroidPlugin和Small的共同点是<strong>两者都是非侵入式的插件框架</strong>；什么是『非侵入式』呢？打个比方，你启动一个插件Activity，直接使用<code>startActivity</code>即可，就跟开发普通的apk一样，开发插件和普通的程序对于开发者来说没有什么区别。</p>
<p>如果我们一定程度上放弃这种『侵入性』，那么我们就能实现一个两者优点兼而有之的插件框架！这里我先卖个关子～</p>
<p>OK，本文的内容就到这里了；关于『插件机制对于Activity的处理方式』也就此完结。要说明的是，在本文的『保守方案』其实只处理了代码的加载过程，它并不能加载有资源的apk！所以目前我这个实现基本没什么暖用；当然我这里只是就『代码加载』进行举例；至于资源，那牵扯到另外一个问题——<strong>插件系统的资源管理机制</strong>这个在后续文章的合适机会我会单独讲解。</p>
<p>接下来的文章，会讲述Android四大组件的另外三个<code>Service</code>，<code>BroadCastReceiver</code>, <code>ContentProvider</code>的处理方式。喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>和我的 <a href="http://weishu.me">博客</a>! 这文章我前前后后准备了快两个星期，如果你看到了这里，还请支持一下 :) </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 中我们地完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的任务；通过Hook <code>AMS</code>和拦截ActivityThread中<code>H</code>类对于组件调度我们成功地绕过了AndroidMAnifest.xml的限制。</p>
<p>但是我们启动的『没有在AndroidManifet.xml中显式声明』的Activity和宿主程序存在于同一个Apk中；通常情况下，插件均以独立的文件存在甚至通过网络获取，这时候插件中的Activity能否成功启动呢？</p>
<p>要启动Activity组件肯定先要创建对应的Activity类的对象，从上文 <a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a> 知道，创建Activity类对象的过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">        cl, component.getClassName(), r.intent);</span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">r.intent.setExtrasClassLoader(cl);</span><br></pre></td></tr></table></figure>
<p>也就是说，系统通过<code>ClassLoader</code>加载了需要的Activity类并通过反射调用构造函数创建出了Activity对象。如果Activity组件存在于独立于宿主程序的文件之中，系统的ClassLoader怎么知道去哪里加载呢？因此，如果不做额外的处理，插件中的Activity对象甚至都没有办法创建出来，谈何启动？</p>
<p>因此，要使存在于独立文件或者网络中的插件被成功启动，首先就需要解决这个<strong>插件类加载</strong>的问题。<br>下文将围绕此问题展开，完成『启动没有在AndroidManifest.xml中显示声明，并且存在于外部插件中的Activity』的任务。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework">understand-plugin-framework</a>，参考此项目的<code>classloader-hook</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="binder" scheme="http://weishu.me/tags/binder/"/>
    
      <category term="classloader" scheme="http://weishu.me/tags/classloader/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 插件化原理解析——Activity生命周期管理]]></title>
    <link href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/"/>
    <id>http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/</id>
    <published>2016-03-21T11:43:32.000Z</published>
    <updated>2016-06-15T02:19:58.000Z</updated>
    <content type="html"><![CDATA[<p>之前的 <a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">Android插件化原理解析</a> 系列文章揭开了Hook机制的神秘面纱，现在我们手握倚天屠龙，那么如何通过这种技术完成插件化方案呢？具体来说，插件中的Activity，Service等组件如何在Android系统上运行起来？</p>
<p>在Java平台要做到动态运行模块、热插拔可以使用<code>ClassLoader</code>技术进行动态类加载，比如广泛使用的<code>OSGi</code>技术。在Android上当然也可以使用动态加载技术，但是仅仅把类加载进来就足够了吗？<code>Activity</code>，<code>Service</code>等组件是有生命周期的，它们统一由系统服务<code>AMS</code>管理；使用<code>ClassLoader</code>可以从插件中创建Activity对象，但是，一个没有生命周期的Activity对象有什么用？所以在Android系统上，仅仅完成动态类加载是不够的；我们需要想办法把我们加载进来的Activity等组件交给系统管理，让<code>AMS</code>赋予组件生命周期；这样才算是一个有血有肉的完善的插件化方案。</p>
<p>接下来的系列文章会讲述 DroidPlugin对于Android四大组件的处理方式，我们且看它如何采用Hook技术坑蒙拐骗把系统玩弄于股掌之中，最终赋予Activity，Service等组件生命周期，完成借尸还魂的。</p>
<a id="more"></a>
<p>首先，我们来看看DroidPlugin对于<code>Activity</code>组件的处理方式。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的intercept-activity模块。另外，如果对于Hook技术不甚了解，请先查阅我之前的文章：</p>
<ol>
<li><a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Hook机制之动态代理</a></li>
<li><a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Hook机制之Binder Hook</a></li>
<li><a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Hook机制之AMS&amp;PMS</a></li>
</ol>
<h2 id="AndroidManifest-xml的限制">AndroidManifest.xml的限制</h2><p>读到这里，或许有部分读者觉得疑惑了，启动Activity不就是一个<code>startActivity</code>的事吗，有这么神秘兮兮的？</p>
<p>启动Activity确实非常简单，但是Android却有一个限制：<strong>必须在AndroidManifest.xml中显示声明使用的Activity</strong>；我相信读者肯定会遇到下面这种异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">03</span>-<span class="number">18</span> <span class="number">15</span>:<span class="number">29</span>:<span class="number">56.074</span>  <span class="number">20709</span>-<span class="number">20709</span>/com.weishu.intercept_activity.app E/AndroidRuntime﹕ FATAL EXCEPTION: main</span><br><span class="line">    Process: com.weishu.intercept_activity.app, PID: <span class="number">20709</span></span><br><span class="line">    android.content.ActivityNotFoundException: Unable to find explicit activity <span class="class"><span class="keyword">class</span> </span>&#123;com.weishu.intercept_activity.app/com.weishu.intercept_activity.app.TargetActivity&#125;; have you declared <span class="keyword">this</span> activity in your AndroidManifest.xml?</span><br></pre></td></tr></table></figure>
<p>『必须在AndroidManifest.xml中显示声明使用的Activity』这个硬性要求很大程度上限制了插件系统的发挥：假设我们需要启动一个插件的Activity，插件使用的Activity是无法预知的，这样肯定也不会在Manifest文件中声明；如果插件新添加一个Activity，主程序的AndroidManifest.xml就需要更新；既然双方都需要修改升级，何必要使用插件呢？这已经违背了动态加载的初衷：不修改插件框架而动态扩展功能。</p>
<p>能不能想办法绕过这个限制呢？</p>
<p>束手无策啊，怎么办？借刀杀人偷梁换柱无中生有以逸待劳乘火打劫瞒天过海…等等！偷梁换柱瞒天过海？貌似可以一试。</p>
<p>我们可以耍个障眼法：既然AndroidManifest文件中必须声明，那么我就声明一个（或者有限个）替身Activity好了，当需要启动插件的某个Activity的时候，先让系统以为启动的是AndroidManifest中声明的那个替身，暂时骗过系统；然后到合适的时候又替换回我们需要启动的真正的Activity；所谓瞒天过海，莫过如此！</p>
<p>现在有了方案了，但是该如何做呢？兵书又说，知己知彼百战不殆！如果连Activity的启动过程都不熟悉，怎么完成这个瞒天过海的过程？</p>
<h2 id="Activity启动过程">Activity启动过程</h2><p>启动Activity非常简单，一个<code>startActivity</code>就完事了；那么在这个简单调用的背后发生了什么呢？Look the fucking source code！</p>
<p>关于Activity 的启动过程，也不是三言两语能解释清楚的，如果按照源码一步一步走下来，插件化系列文章就不用写了；所以这里我就给出一个大致流程，只列出关键的调用点（以Android 6.0源码为例）；如果读者希望更详细的讲解，可以参考老罗的 <a href="http://blog.csdn.net/luoshengyang/article/details/6685853" target="_blank" rel="external"> Android应用程序的Activity启动过程简要介绍和学习计划</a></p>
<p>首先是Activity类的<code>startActivity</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟着这个方法一步一步跟踪，会发现它最后在<code>startActivityForResult</code>里面调用了Instrument对象的<code>execStartActivity</code>方法；接着在这个函数里面调用了ActivityManagerNative类的<code>startActivity</code>方法；这个过程在前文已经反复举例讲解了，我们知道接下来会通过Binder IPC到<code>AMS</code>所在进程调用<code>AMS</code>的<code>startActivity</code>方法；Android系统的组件生命周期管理就是在<code>AMS</code>里面完成的，那么在<code>AMS</code>里面到底做了什么呢？</p>
<p>ActivityManagerService的<code>startActivity</code>方法如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">int</span> startActivity(IApplicationThread caller, <span class="keyword">String</span> callingPackage,</span><br><span class="line">        Intent intent, <span class="keyword">String</span> resolvedType, IBinder resultTo,</span><br><span class="line">        <span class="keyword">String</span> resultWho, <span class="built_in">int</span> requestCode, <span class="built_in">int</span> startFlags,</span><br><span class="line">        <span class="keyword">String</span> profileFile, ParcelFileDescriptor profileFd, Bundle options) &#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode,</span><br><span class="line">            startFlags, profileFile, profileFd, options, UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，直接调用了<code>startActivityAsUser</code>这个方法；接着是<code>ActivityStackSupervisor</code>类的<code>startActivityMayWait</code>方法。这个ActivityStackSupervisor类到底是个啥？如果仔细查阅，低版本的Android源码上是没有这个类的；后来AMS的代码进行了部分重构，关于Activity栈管理的部分单独提取出来成为了<code>ActivityStackSupervisor</code>类；好了，继续看代码。</p>
<p>startActivityMayWait这个方法前面对参数进行了一系列处理，我们需要知道的是，在这个方法内部对传进来的Intent进行了解析，并尝试从中取出关于启动Activity的信息。</p>
<p>然后这个方法调用了startActivityLocked方法；在startActivityLocked方法内部进行了一系列重要的检查：比如权限检查，Activity的exported属性检查等等；我们上文所述的，启动没有在Manifestfest中显示声明的Activity抛异常也是这里发生的：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">err</span> == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123;</span><br><span class="line">    <span class="comment">// We couldn't find the specific class specified in the Intent.</span></span><br><span class="line">    <span class="comment">// Also the end of the line.</span></span><br><span class="line">    <span class="keyword">err</span> = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里返回ActivityManager.START_CLASS_NOT_FOUND之后，在Instrument的execStartActivity返回之后会检查这个值，然后跑出异常：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">    <span class="keyword">if</span> (intent <span class="keyword">instanceof</span> Intent &amp;&amp; ((Intent)intent).getComponent() != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                <span class="string">"Unable to find explicit activity class "</span></span><br><span class="line">                + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                + <span class="string">"; have you declared this activity in your AndroidManifest.xml?"</span>);</span><br></pre></td></tr></table></figure>
<p>源码看到这里，我们已经确认了『必须在AndroidManifest.xml中显示声明使用的Activity』的原因；然而这个校检过程发生在<code>AMS</code>所在的进程<code>system_server</code>，我们没有办法篡改，只能另寻他路。</p>
<p>OK，我们继续跟踪源码；在startActivityLocked之后处理的都是Activity任务栈相关内容，这一系列ActivityStack和ActivityStackSupervisor纠缠不清的调用看下图就明白了；不明白也没关系: D 目前用处不大。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1458296458099.png" alt="调用流程图"></p>
<p>这一系列调用最终到达了ActivityStackSupervisor的realStartActivityLocked方法；人如其名，这个方法开始了真正的“启动Activity”：它调用了ApplicationThread的scheduleLaunchActivity方法，开始了真正的Activity对象创建以及启动过程。</p>
<p>这个ApplicationThread是什么，是一个线程吗？与ActivityThread有什么区别和联系？</p>
<p>不要被名字迷惑了，这个ApplicationThread实际上是一个Binder对象，是App所在的进程与AMS所在进程system_server通信的桥梁；在Activity启动的过程中，App进程会频繁地与AMS进程进行通信：</p>
<ol>
<li>App进程会委托AMS进程完成Activity生命周期的管理以及任务栈的管理；这个通信过程AMS是Server端，App进程通过持有AMS的client代理ActivityManagerNative完成通信过程；</li>
<li>AMS进程完成生命周期管理以及任务栈管理后，会把控制权交给App进程，让App进程完成Activity类对象的创建，以及生命周期回调；这个通信过程也是通过Binder完成的，App所在server端的Binder对象存在于ActivityThread的内部类ApplicationThread；AMS所在client通过持有IApplicationThread的代理对象完成对于App进程的通信。</li>
</ol>
<p>App进程与AMS进程的通信过程如图所示：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1458300329231.png" width="500"></p>
<p>App进程内部的ApplicationThread server端内部有自己的Binder线程池，它与App主线程的通信通过Handler完成，这个Handler存在于ActivityThread类，它的名字很简单就叫<code>H</code>，这一点我们接下来就会讲到。</p>
<p>现在我们明白了这个ApplicationThread到底是个什么东西，接上文继续跟踪Activity的启动过程；我们查看ApplicationThread的<code>scheduleLaunchActivity</code>方法，这个方法很简单，就是包装了参数最终使用Handler发了一个消息。</p>
<p>正如刚刚所说，ApplicationThread所在的Binder服务端使用Handler与主线程进行通信，这里的scheduleLaunchActivity方法直接把启动Activity的任务通过一个消息转发给了主线程；我们查看Handler类对于这个消息的处理：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart")<span class="comment">;</span></span><br><span class="line">ActivityClientRecord r = (ActivityClientRecord)msg.obj<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">        r.activityInfo.applicationInfo, r.compatInfo)<span class="comment">;</span></span><br><span class="line">handleLaunchActivity(r, null)<span class="comment">;</span></span><br><span class="line">Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里直接调用了ActivityThread的handleLaunchActivity方法，在这个方法内部有一句非常重要：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Activity a = performLaunchActivity<span class="list">(<span class="keyword">r</span>, customIntent)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>绕了这么多弯，我们的Activity终于被创建出来了！继续跟踪这个performLaunchActivity方法看看发生了什么；由于这个方法较长，我就不贴代码了，读者可以自行查阅；要指出的是，这个方法做了两件很重要的事情：</p>
<ol>
<li>使用ClassLoader加载并通过反射创建Activity对象</li>
</ol>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassLoader cl = r.packageInfo.getClassLoader()<span class="comment">;</span></span><br><span class="line">activity = mInstrumentation.newActivity(</span><br><span class="line">        cl, component.getClassName(), r.intent)<span class="comment">;</span></span><br><span class="line">StrictMode.incrementExpectedActivityCount(activity.getClass())<span class="comment">;</span></span><br><span class="line">r.intent.setExtrasClassLoader(cl)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果Application还没有创建，那么创建Application对象并回调相应的生命周期方法；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity的启动过程到这里就结束了，可能读者还是觉得迷惑：不就是调用了一系列方法吗？具体做了什么还是不太清楚，而且为什么Android要这么设计？</p>
<p>方法调用链再长也木有关系，有两点需要明白：</p>
<ol>
<li>平时我们所说的Application被创建了，onCreate方法被调用了，我们或许并没有意识到我们所说的<code>Application, Activity</code>除了代表Android应用层通常所代表的“组件”之外，它们其实都是普通的Java对象，也是需要被构造函数构造出来的对象的；在这个过程中，我们明白了这些对象到底是如何被创建的。</li>
<li>为什么需要一直与AMS进行通信？哪些操作是在AMS中进行的？其实<code>AMS</code>正如名字所说，管理所有的“活动”，整个系统的Activity堆栈，Activity生命周期回调都是由AMS所在的系统进程system_server帮开发者完成的；Android的Framework层帮忙完成了诸如生命周期管理等繁琐复杂的过程，简化了应用层的开发。</li>
</ol>
<h2 id="瞒天过海——启动不在AndroidManifest-xml中声明的Activity">瞒天过海——启动不在AndroidManifest.xml中声明的Activity</h2><h3 id="简要分析">简要分析</h3><p>通过上文的分析，我们已经对Activity的启动过程了如指掌了；就让我们干点坏事吧 :D</p>
<p>对与『必须在AndroidManifest.xml中显示声明使用的Activity』这个问题，上文给出了思路——瞒天过海；我们可以在AndroidManifest.xml里面声明一个替身Activity，然后<strong>在合适的时候</strong>把这个假的替换成我们真正需要启动的Activity就OK了。</p>
<p>那么问题来了，『合适的时候』到底是什么时候？在前文<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Hook机制之动态代理</a>中我们提到过Hook过程最重要的一步是<strong>寻找Hook点</strong>；如果是在同一个进程，<code>startActivity</code>到Activity真正启动起来这么长的调用链，我们随便找个地方Hook掉就完事儿了；但是问题木有这么简单。</p>
<p>Activity启动过程中很多重要的操作（正如上文分析的『必须在AndroidManifest.xml中显式声明要启动的Activity』)都不是在App进程里面执行的，而是在AMS所在的系统进程system_server完成，由于<strong>进程隔离</strong>的存在，我们对别的进程无能为力；所以这个Hook点就需要花点心思了。</p>
<p>这时候Activity启动过程的知识就派上用场了；虽然整个启动过程非常复杂，但其实一张图就能总结：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1458532084072.png" alt="简要启动过程"></p>
<p>先从App进程调用<code>startActivity</code>；然后通过IPC调用进入系统进程system_server，完成Activity管理以及一些校检工作，最后又回到了APP进程完成真正的Activioty对象创建。</p>
<p>由于这个检验过程是在AMS进程完成的，我们对system_server进程里面的操作无能为力，只有在我们APP进程里面执行的过程才是有可能被Hook掉的，也就是第一步和第三步；具体应该怎么办呢？</p>
<p>既然需要一个显式声明的Activity，那就声明一个！<strong>可以在第一步假装启动一个已经在AndroidManifest.xml里面声明过的替身Activity，让这个Activity进入AMS进程接受检验；最后在第三步的时候换成我们真正需要启动的Activity</strong>；这样就成功欺骗了AMS进程，瞒天过海！</p>
<p>说到这里，是不是有点小激动呢？我们写个demo验证一下：『启动一个并没有在AndroidManifest.xml中显示声明的Activity』</p>
<h3 id="实战过程">实战过程</h3><p>具体来说，我们打算实现如下功能：在MainActivity中启动一个并没有在AndroidManifest.xml中声明的TargetActivity；按照上文分析，我们需要声明一个替身Activity，我们叫它StubActivity；</p>
<p>那么，我们的AndroidManifest.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">          <span class="attribute">package</span>=<span class="value">"com.weishu.intercept_activity.app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span></span><br><span class="line">            <span class="attribute">android:allowBackup</span>=<span class="value">"true"</span></span><br><span class="line">            <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">            <span class="attribute">android:icon</span>=<span class="value">"@mipmap/ic_launcher"</span></span><br><span class="line">            &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 替身Activity, 用来欺骗AMS  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".StubActivity"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>OK，那么我们启动TargetActivity很简单，就是个<code>startActivity</code>调用的事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TargetActivity.class));</span><br></pre></td></tr></table></figure>
<p>如果你直接这么运行，肯定会直接抛出ActivityNotFoundException然后直接退出；我们接下来要做的就是让这个调用成功启动TargetActivity。</p>
<h4 id="狸猫换太子——使用替身Activity绕过AMS">狸猫换太子——使用替身Activity绕过AMS</h4><p>由于<code>AMS</code>进程会对Activity做显式声明验证，因此在<br>启动Activity的控制权转移到<code>AMS</code>进程之前，我们需要想办法<strong>临时</strong>把TargetActivity替换成替身StubActivity；在这之间有很长的一段调用链，我们可以轻松Hook掉；选择什么地方Hook是一个很自由的事情，但是Hook的步骤越后越可靠——Hook得越早，后面的调用就越复杂，越容易出错。</p>
<p>我们可以选择在进入<code>AMS</code>进程的入口进行Hook，具体来说也就是Hook <code>AMS</code>在本进程的代理对象ActivityManagerNative。如果你不知道如何Hook掉这个AMS的代理对象，请查阅我之前的文章 <a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Hook机制之AMS&amp;PMS</a> </p>
<p>我们Hook掉ActivityManagerNative对于startActivity方法的调用，替换掉交给AMS的intent对象，将里面的TargetActivity的暂时替换成已经声明好的替身StubActivity；这种Hook方式 <a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">前文</a> 讲述的很详细，不赘述；替换的关键代码如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="comment">// 只拦截这个方法</span></span><br><span class="line">    <span class="comment">// 替换参数, 任你所为;甚至替换原始Activity启动别的Activity偷梁换柱</span></span><br><span class="line">    <span class="comment">// API 23:</span></span><br><span class="line">    <span class="comment">// public final Activity startActivityNow(Activity parent, String id,</span></span><br><span class="line">    <span class="comment">// Intent intent, ActivityInfo activityInfo, IBinder token, Bundle state,</span></span><br><span class="line">    <span class="comment">// Activity.NonConfigurationInstances lastNonConfigurationInstances) &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到参数里面的第一个Intent 对象</span></span><br><span class="line"></span><br><span class="line">    Intent raw;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    raw = (Intent) args[index];</span><br><span class="line"></span><br><span class="line">    Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里包名直接写死,如果再插件里,不同的插件有不同的包  传递插件的包名即可</span></span><br><span class="line">    String targetPackage = <span class="string">"com.weishu.intercept_activity.app"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里我们把启动的Activity临时替换为 StubActivity</span></span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(targetPackage, StubActivity.class.getCanonicalName());</span><br><span class="line">    newIntent.setComponent(componentName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把我们原始要启动的TargetActivity先存起来</span></span><br><span class="line">    newIntent.putExtra(HookHelper.EXTRA_TARGET_INTENT, raw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换掉Intent, 达到欺骗AMS的目的</span></span><br><span class="line">    args[index] = newIntent;</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"hook success"</span>);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> method.invoke(mBase, args);</span><br></pre></td></tr></table></figure>
<p>通过这个替换过程，在ActivityManagerNative的startActivity调用之后，system_server端收到Binder驱动的消息，开始执行ActivityManagerService里面真正的<code>startActivity</code>方法；这时候AMS看到的<code>intent</code>参数里面的组件已经是<code>StubActivity</code>了，因此可以成功绕过检查，这时候如果不做后面的Hook，直接调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, TargetActivity.class));</span><br></pre></td></tr></table></figure>
<p>也不会出现上文的ActivityNotFoundException</p>
<h4 id="借尸还魂——拦截Callback从恢复真身">借尸还魂——拦截Callback从恢复真身</h4><p>行百里者半九十。现在我们的<code>startActivity</code>启动一个没有显式声明的Activity已经不会抛异常了，但是要真正正确地把TargetActivity启动起来，还有一些事情要做。其中最重要的一点是，我们用替身StubActivity临时换了TargetActivity，肯定需要在『合适的』时候替换回来；接下来我们就完成这个过程。</p>
<p>在AMS进程里面我们是没有办法换回来的，因此我们要等AMS把控制权交给App所在进程，也就是上面那个『Activity启动过程简图』的第三步。AMS进程转移到App进程也是通过Binder调用完成的，承载这个功能的Binder对象是IApplicationThread；在App进程它是Server端，在Server端接受Binder远程调用的是Binder线程池，Binder线程池通过Handler将消息转发给App的主线程；（我这里不厌其烦地叙述Binder调用过程，希望读者不要反感，其一加深印象，其二懂Binder真的很重要）我们可以在这个<strong>Handler里面将替身恢复成真身</strong>。</p>
<p>这里不打算讲述Handler 的原理，我们简单看一下Handler是如何处理接收到的Message的，如果我们能拦截这个Message的接收过程，就有可能完成替身恢复工作；Handler类的<code>dispathMesage</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个方法可以看出来，Handler类消息分发的过程如下：</p>
<ol>
<li>如果传递的Message本身就有callback，那么直接使用Message对象的callback方法；</li>
<li>如果Handler类的成员变量<code>mCallback</code>存在，那么首先执行这个<code>mCallback</code>回调；</li>
<li>如果<code>mCallback</code>的回调返回<code>true</code>，那么表示消息已经成功处理；直接结束。</li>
<li>如果<code>mCallback</code>的回调返回<code>false</code>，那么表示消息没有处理完毕，会继续使用Handler类的<code>handleMessage</code>方法处理消息。</li>
</ol>
<p>那么，ActivityThread中的Handler类<code>H</code>是如何实现的呢？<code>H</code>的部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">            ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line"></span><br><span class="line">            r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                    r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">            handleLaunchActivity(r, <span class="keyword">null</span>);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RELAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityRestart"</span>);</span><br><span class="line">            ActivityClientRecord r = (ActivityClientRecord)msg.obj;</span><br><span class="line">            handleRelaunchActivity(r);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下略</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>H</code>类仅仅重载了<code>handleMessage</code>方法；通过dispathMessage的消息分发过程得知，我们可以拦截这一过程：<strong>把这个<code>H</code>类的<code>mCallback</code>替换为我们的自定义实现</strong>，这样<code>dispathMessage</code>就会首先使用这个自定义的<code>mCallback</code>，然后看情况使用<code>H</code>重载的<code>handleMessage</code>。</p>
<p>这个<code>Handler.Callback</code>是一个接口，我们可以使用动态代理或者普通代理完成Hook，这里我们使用普通的静态代理方式；创建一个自定义的Callback类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* package */</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThreadHandlerCallback</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Handler mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActivityThreadHandlerCallback</span><span class="params">(Handler base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="comment">// ActivityThread里面 "LAUNCH_ACTIVITY" 这个字段的值是100</span></span><br><span class="line">            <span class="comment">// 本来使用反射的方式获取最好, 这里为了简便直接使用硬编码</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">                handleLaunchActivity(msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mBase.handleMessage(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里简单起见,直接取出TargetActivity;</span></span><br><span class="line"></span><br><span class="line">        Object obj = msg.obj;</span><br><span class="line">        <span class="comment">// 根据源码:</span></span><br><span class="line">        <span class="comment">// 这个对象是 ActivityClientRecord 类型</span></span><br><span class="line">        <span class="comment">// 我们修改它的intent字段为我们原来保存的即可.</span></span><br><span class="line"><span class="comment">/*        switch (msg.what) &#123;</span><br><span class="line">/             case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">/                 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart");</span><br><span class="line">/                 final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">/</span><br><span class="line">/                 r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">/                         r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">/                 handleLaunchActivity(r, null);</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把替身恢复成真身</span></span><br><span class="line">            Field intent = obj.getClass().getDeclaredField(<span class="string">"intent"</span>);</span><br><span class="line">            intent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Intent raw = (Intent) intent.get(obj);</span><br><span class="line"></span><br><span class="line">            Intent target = raw.getParcelableExtra(HookHelper.EXTRA_TARGET_INTENT);</span><br><span class="line">            raw.setComponent(target.getComponent());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Callback类的使命很简单：<strong>把替身StubActivity恢复成真身TargetActivity</strong>；有了这个自定义的Callback之后我们需要把ActivityThread里面处理消息的Handler类<code>H</code>的的<code>mCallback</code>修改为自定义callback类的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Field currentActivityThreadField = activityThreadClass.getDeclaredField(<span class="string">"sCurrentActivityThread"</span>);</span><br><span class="line">currentActivityThreadField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于ActivityThread一个进程只有一个,我们获取这个对象的mH</span></span><br><span class="line">Field mHField = activityThreadClass.getDeclaredField(<span class="string">"mH"</span>);</span><br><span class="line">mHField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Handler mH = (Handler) mHField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置它的回调, 根据源码:</span></span><br><span class="line"><span class="comment">// 我们自己给他设置一个回调,就会替代之前的回调;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        public void dispatchMessage(Message msg) &#123;</span></span><br><span class="line"><span class="comment">//            if (msg.callback != null) &#123;</span></span><br><span class="line"><span class="comment">//                handleCallback(msg);</span></span><br><span class="line"><span class="comment">//            &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                if (mCallback != null) &#123;</span></span><br><span class="line"><span class="comment">//                    if (mCallback.handleMessage(msg)) &#123;</span></span><br><span class="line"><span class="comment">//                        return;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                handleMessage(msg);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">Field mCallBackField = Handler.class.getDeclaredField(<span class="string">"mCallback"</span>);</span><br><span class="line">mCallBackField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">mCallBackField.set(mH, <span class="keyword">new</span> ActivityThreadHandlerCallback(mH));</span><br></pre></td></tr></table></figure>
<p>到这里，我们已经成功地绕过<code>AMS</code>，完成了『启动没有在AndroidManifest.xml中显式声明的Activity』的过程；瞒天过海，这种玩弄系统与股掌之中的快感你们能体会到吗？</p>
<h4 id="僵尸or活人？——能正确收到生命周期回调吗">僵尸or活人？——能正确收到生命周期回调吗</h4><p>虽然我们完成了『启动没有在AndroidManifest.xml中显式声明的Activity 』，但是启动的TargetActivity是否有自己的生命周期呢，我们还需要额外的处理过程吗？</p>
<p>实际上TargetActivity已经是一个有血有肉的Activity了：它具有自己正常的生命周期；可以运行<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">Demo代码</a>验证一下。</p>
<p>这个过程是如何完成的呢？我们以<code>onDestroy</code>为例简要分析一下：</p>
<blockquote>
<p>从Activity的<code>finish</code>方法开始跟踪，最终会通过ActivityManagerNative到<code>AMS</code>然后接着通过ApplicationThread到ActivityThread，然后通过<code>H</code>转发消息到ActivityThread的handleDestroyActivity，接着这个方法把任务交给performDestroyActivity完成。</p>
</blockquote>
<p>在真正分析这个方法之前，需要说明一点的是：不知读者是否感受得到，App进程与<code>AMS</code>交互几乎都是这么一种模式，几个角色 ActivityManagerNative, ApplicationThread, ActivityThread以及Handler类<code>H</code>分工明确，读者可以按照这几个角色的功能分析<code>AMS</code>的任何调用过程，屡试不爽；这也是我的初衷——希望分析插件框架的过程中能帮助深入理解Android Framework。</p>
<p>好了继续分析performDestroyActivity，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityClientRecord r = mActivities.get(token);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line">mInstrumentation.callActivityOnDestroy(r.activity);</span><br></pre></td></tr></table></figure>
<p>这里通过<code>mActivities</code>拿到了一个ActivityClientRecord，然后直接把这个record里面的Activity交给Instrument类完成了onDestroy的调用。</p>
<p>在我们这个demo的场景下，r.activity是TargetActivity还是StubActivity？按理说，由于我们欺骗了<code>AMS</code>，<code>AMS</code>应该只知道<code>StubActivity</code>的存在，它压根儿就不知道TargetActivity是什么，为什么它能正确完成对TargetActivity生命周期的回调呢？</p>
<p>一切的秘密在<code>token</code>里面。<code>AMS</code>与<code>ActivityThread</code>之间对于Activity的生命周期的交互，并没有直接使用Activity对象进行交互，而是使用一个token来标识，这个token是binder对象，因此可以方便地跨进程传递。Activity里面有一个成员变量<code>mToken</code>代表的就是它，token可以唯一地标识一个Activity对象，它在Activity的<code>attach</code>方法里面初始化；</p>
<p>在<code>AMS</code>处理Activity的任务栈的时候，使用这个token标记Activity，因此在我们的demo里面，<code>AMS</code>进程里面的token对应的是StubActivity，也就是<code>AMS</code>还在傻乎乎地操作StubActivity（关于这一点，你可以dump出任务栈的信息，可以观察到dump出的确实是StubActivity）。但是在我们App进程里面，token对应的却是TargetActivity！因此，在ActivityThread执行回调的时候，能正确地回调到TargetActivity相应的方法。</p>
<p>为什么App进程里面，token对应的是TargetActivity呢？</p>
<p>回到代码，ActivityClientRecord是在<code>mActivities</code>里面取出来的，确实是根据token取；那么这个token是什么时候添加进去的呢？我们看performLaunchActivity就完成明白了：它通过classloader加载了TargetActivity，然后完成一切操作之后把这个activity添加进了<code>mActivities</code>！另外，在这个方法里面我们还能看到对Ativity<code>attach</code>方法的调用，它传递给了新创建的Activity一个token对象，而这个token是在ActivityClientRecord构造函数里面初始化的。</p>
<p>至此我们已经可以确认，通过这种方式启动的Activity有它自己完整而独立的生命周期！</p>
<h2 id="小节">小节</h2><p>本文讲述了『启动一个并没有在AndroidManifest.xml中显示声明的Activity』的解决办法，我们成功地绕过了Android的这个限制，这个是插件Activity管理技术的基础；但是要做到启动一个插件Activity问题远没有这么简单。</p>
<p>首先，在Android中，Activity有不同的启动模式；我们声明了一个替身StubActivity，肯定没有满足所有的要求；因此，我们需要在AndroidManifest.xml中声明一系列的有不同launchMode的Activity，还需要完成替身与真正Activity launchMode的匹配过程；这样才能完成启动各种类型Activity的需求，关于这一点，在 DroidPlugin 的com.morgoo.droidplugin.stub包下面可以找到。</p>
<p>另外，每启动一个插件的Activity都需要一个StubActivity，但是AndroidManifest.xml中肯定只能声明有限个，如果一直<code>startActivity</code>而不finish的话，那么理论上就需要无限个StubActivity；这个问题该如何解决呢？事实上，这个问题在技术上没有好的解决办法。但是，如果你的App startActivity了十几次，而没有finish任何一个Activity，这样在Activity的回退栈里面有十几个Activity，用户难道按back十几次回到主页吗？有这种需求说明你的产品设计有问题；一个App一级页面，二级页面..到五六级的页面已经影响体验了，所以，每种LauchMode声明十个StubActivity绝对能满足需求了。</p>
<p>最后，在本文所述例子中，TargetActivity与StubActivity存在于同一个Apk，因此系统的ClassLoader能够成功加载并创建TargetActivity的实例。但是在实际的插件系统中，要启动的目标Activity肯定存在于一个单独的文件中，系统默认的ClassLoader无法加载插件中的Activity类——系统压根儿就不知道要加载的插件在哪，谈何加载？因此还有一个很重要的问题需要处理：</p>
<p><strong>我们要完成插件系统中类的加载</strong>，这可以通过自定义ClassLoader实现。解决了『启动没有在AndroidManifest.xml中显式声明的，并且存在于外部文件中的Activity』的问题，插件系统对于Activity的管理才算得上是一个完全体。篇幅所限，欲知后事如何，请听下回分解！</p>
<p>喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>和我的 <a href="http://weishu.me">博客</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前的 <a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">Android插件化原理解析</a> 系列文章揭开了Hook机制的神秘面纱，现在我们手握倚天屠龙，那么如何通过这种技术完成插件化方案呢？具体来说，插件中的Activity，Service等组件如何在Android系统上运行起来？</p>
<p>在Java平台要做到动态运行模块、热插拔可以使用<code>ClassLoader</code>技术进行动态类加载，比如广泛使用的<code>OSGi</code>技术。在Android上当然也可以使用动态加载技术，但是仅仅把类加载进来就足够了吗？<code>Activity</code>，<code>Service</code>等组件是有生命周期的，它们统一由系统服务<code>AMS</code>管理；使用<code>ClassLoader</code>可以从插件中创建Activity对象，但是，一个没有生命周期的Activity对象有什么用？所以在Android系统上，仅仅完成动态类加载是不够的；我们需要想办法把我们加载进来的Activity等组件交给系统管理，让<code>AMS</code>赋予组件生命周期；这样才算是一个有血有肉的完善的插件化方案。</p>
<p>接下来的系列文章会讲述 DroidPlugin对于Android四大组件的处理方式，我们且看它如何采用Hook技术坑蒙拐骗把系统玩弄于股掌之中，最终赋予Activity，Service等组件生命周期，完成借尸还魂的。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 插件化原理解析——Hook机制之AMS&PMS]]></title>
    <link href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/"/>
    <id>http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/</id>
    <published>2016-03-07T08:35:46.000Z</published>
    <updated>2016-03-09T02:51:05.000Z</updated>
    <content type="html"><![CDATA[<p>在前面的文章中我们介绍了DroidPlugin的Hook机制，也就是<strong>代理方式</strong>和<strong>Binder Hook</strong>；插件框架通过AOP实现了插件使用和开发的透明性。在讲述DroidPlugin如何实现四大组件的插件化之前，有必要说明一下它对ActivityManagerServiche以及PackageManagerService的Hook方式（以下简称AMS，PMS）。</p>
<p>ActivityManagerService对于FrameWork层的重要性不言而喻，Android的四大组件无一不与它打交道：</p>
<ol>
<li><code>startActivity</code>最终调用了AMS的<code>startActivity</code>系列方法，实现了Activity的启动；Activity的生命周期回调，也在AMS中完成；</li>
<li><code>startService,bindService</code>最终调用到AMS的startService和bindService方法；</li>
<li>动态广播的注册和接收在<code>AMS</code>中完成（静态广播在<code>PMS</code>中完成）</li>
<li><code>getContentResolver</code>最终从<code>AMS</code>的<code>getContentProvider</code>获取到ContentProvider</li>
</ol>
<p>而<code>PMS</code>则完成了诸如权限校捡(<code>checkPermission,checkUidPermission</code>)，Apk meta信息获取(<code>getApplicationInfo</code>等)，四大组件信息获取(<code>query</code>系列方法)等重要功能。</p>
<p>在上文<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Android插件化原理解析——Hook机制之Binder Hook</a>中讲述了DroidPlugin的Binder Hook机制；我们知道<code>AMS</code>和<code>PMS</code>就是以Binder方式提供给应用程序使用的系统服务，理论上我们也可以采用这种方式Hook掉它们。但是由于这两者使用得如此频繁，Framework给他们了一些“特别优待”，这也给了我们相对于Binder Hook更加稳定可靠的hook方式。</p>
<a id="more"></a>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的<code>ams-pms-hook</code>模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<h2 id="AMS获取过程">AMS获取过程</h2><p>前文提到Android的四大组件无一不与<code>AMS</code>相关，也许读者还有些许疑惑；这里我就挑一个例子，依据Android源码来说明，一个简单的<code>startActivity</code>是如何调用<code>AMS</code>最终通过IPC到system_server的。</p>
<p>不论读者是否知道，我们使用<code>startActivity</code>有两种形式：</p>
<ol>
<li>直接调用<code>Context</code>类的<code>startActivity</code>方法；这种方式启动的Activity没有Activity栈，因此不能以standard方式启动，必须加上<code>FLAG_ACTIVITY_NEW_TASK</code>这个Flag。</li>
<li>调用被<code>Activity</code>类重载过的<code>startActivity</code>方法，通常在我们的Activity中直接调用这个方法就是这种形式；</li>
</ol>
<h3 id="Context-startActivity">Context.startActivity</h3><p>我们查看<code>Context</code>类的<code>startActivity</code>方法，发现这竟然是一个抽象类；查看<code>Context</code>的类继承关系图如下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1457322345547.png" width="329"></p>
<p>我们看到诸如<code>Activity</code>，<code>Service</code>等并没有直接继承<code>Context</code>，而是继承了<code>ContextWrapper</code>；继续查看<code>ContextWrapper</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    mBase.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WTF!! 果然人如其名，只是一个wrapper而已；这个<code>mBase</code>是什么呢？这里我先直接告诉你，它的真正实现是<code>ContextImpl</code>类；至于为什么，有一条思路：<em>mBase是在ContextWrapper构造的时候传递进来的，那么在ContextWrapper构造的时候可以找到答案</em><br>什么时候会构造ContextWrapper呢？它的子类<code>Application</code>，<code>Service</code>等被创建的时候。</p>
<p>可以在App的主线程<code>AcitivityThread</code>的<code>performLaunchActivit</code>方法里面找到答案；更详细的解析可以参考老罗的<a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="external"> Android应用程序启动过程源代码分析</a></p>
<p>好了，我们姑且当作已经知道Context.startActivity最终使用了ContextImpl里面的方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                <span class="string">"Calling startActivity() from outside of an Activity "</span></span><br><span class="line">                + <span class="string">" context requires the FLAG_ACTIVITY_NEW_TASK flag."</span></span><br><span class="line">                + <span class="string">" Is this really what you want?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">        getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">        (Activity)<span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码相当简单；我们知道了两件事：</p>
<ol>
<li>其一，我们知道了在Service等非Activity的Context里面启动Activity为什么需要添加<code>FLAG_ACTIVITY_NEW_TASK</code>；</li>
<li>其二，真正的<code>startActivity</code>使用了<code>Instrumentation</code>类的<code>execStartActivity</code>方法；继续跟踪：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ... 省略无关代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess();</span><br><span class="line">        <span class="comment">// ----------------look here!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们发现真正调用的是<code>ActivityManagerNative</code>的<code>startActivity</code>方法；如果你不清楚<code>ActivityManager</code>，<code>ActivityManagerService</code>以及<code>ActivityManagerNative</code>之间的关系；建议先仔细阅读我之前关于Binder的文章 <a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a>。</p>
<h3 id="Activity-startActivity">Activity.startActivity</h3><p>Activity类的<code>startActivity</code>方法相比Context而言直观了很多；这个<code>startActivity</code>通过若干次调用辗转到达<code>startActivityForResult</code>这个方法，在这个方法内部有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instrumentation.ActivityResult ar =</span><br><span class="line">    mInstrumentation.execStartActivity(</span><br><span class="line">        <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">        intent, requestCode, options);</span><br></pre></td></tr></table></figure>
<p>可以看到，其实通过Activity和ContextImpl类启动Activity并无本质不同，他们都通过<code>Instrumentation</code>这个辅助类调用到了<code>ActivityManagerNative</code>的方法。</p>
<h2 id="Hook_AMS">Hook AMS</h2><p>OK，我们到现在知道；其实<code>startActivity</code>最终通过<code>ActivityManagerNative</code>这个方法远程调用了<code>AMS</code>的<code>startActivity</code>方法。那么这个<code>ActivityManagerNative</code>是什么呢？</p>
<p>ActivityManagerNative实际上就是<code>ActivityManagerService</code>这个远程对象的Binder代理对象；每次需要与AMS打交道的时候，需要借助这个代理对象通过驱动进而完成IPC调用。</p>
<p>我们继续看<code>ActivityManagerNative</code>的<code>getDefault()</code>方法做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gDefault</code>这个静态变量的定义如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    protected IActivityManager create() &#123;</span><br><span class="line">        IBinder b = ServiceManager.getService("activity</span><br><span class="line">        IActivityManager am = asInterface(</span><br><span class="line">        return am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于整个Framework与AMS打交道是如此频繁，framework使用了一个单例把这个<code>AMS</code>的代理对象保存了起来；这样只要需要与<code>AMS</code>进行IPC调用，获取这个单例即可。这是<code>AMS</code>这个系统服务与其他普通服务的不同之处，也是我们不通过Binder Hook的原因——我们只需要简单地Hook掉这个单例即可。</p>
<p>这里还有一点小麻烦：Android不同版本之间对于如何保存这个单例的代理对象是不同的；Android 2.x系统直接使用了一个简单的静态变量存储，Android 4.x以上抽象出了一个Singleton类；具体的差异可以使用<code>grepcode</code>进行比较：<a href="http://grepcode.com/file_/repository.grepcode.com/java/ext/com.google.android/android/4.0.1_r1/android/app/ActivityManagerNative.java/?v=diff&amp;id2=2.3.3_r1" target="_blank" rel="external">差异</a></p>
<p>我们以4.x以上的代码为例说明如何Hook掉<code>AMS</code>；方法使用的动态代理，如果有不理解的，可以参考之前的系列文章<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Android插件化原理解析——Hook机制之动态代理</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; activityManagerNativeClass = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 gDefault 这个字段, 想办法替换它</span></span><br><span class="line">Field gDefaultField = activityManagerNativeClass.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">gDefaultField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object gDefault = gDefaultField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.x以上的gDefault是一个 android.util.Singleton对象; 我们取出这个单例里面的字段</span></span><br><span class="line">Class&lt;?&gt; singleton = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line">Field mInstanceField = singleton.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityManagerNative 的gDefault对象里面原始的 IActivityManager对象</span></span><br><span class="line">Object rawIActivityManager = mInstanceField.get(gDefault);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个这个对象的代理对象, 然后替换这个字段, 让我们的代理对象帮忙干活</span></span><br><span class="line">Class&lt;?&gt; iActivityManagerInterface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line">Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iActivityManagerInterface &#125;, <span class="keyword">new</span> IActivityManagerHandler(rawIActivityManager));</span><br><span class="line">mInstanceField.set(gDefault, proxy);</span><br></pre></td></tr></table></figure>
<p>好了，我们hook成功之后启动Activity看看会发生什么：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ <span class="function"><span class="keyword">method</span>:</span>activityResumed called <span class="keyword">with</span> args:[android.os.BinderProxy@<span class="number">9</span>bc71b2]</span><br><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ <span class="function"><span class="keyword">method</span>:</span>activityIdle called <span class="keyword">with</span> args:[android.os.BinderProxy@<span class="number">9</span>bc71b2, null, <span class="keyword">false</span>]</span><br><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ <span class="function"><span class="keyword">method</span>:</span>startActivity called <span class="keyword">with</span> args:[android.app.ActivityThread$ApplicationThread@<span class="number">17</span>e750c, com.weishu.upf.ams_pms_hook.app, Intent <span class="comment">&#123; act=android.intent.action.VIEW dat=http://wwww.baidu.com/... &#125;</span>, null, android.os.BinderProxy@<span class="number">9</span>bc71b2, null, -<span class="number">1</span>, <span class="number">0</span>, null, null]</span><br><span class="line">D/HookHelper﹕ hey, baby; you are hook!!</span><br><span class="line">D/HookHelper﹕ <span class="function"><span class="keyword">method</span>:</span>activityPaused called <span class="keyword">with</span> args:[android.os.BinderProxy@<span class="number">9</span>bc71b2]</span><br></pre></td></tr></table></figure>
<p>可以看到，简单的几行代码，<code>AMS</code>已经被我们完全劫持了!! 至于劫持了能干什么，自己发挥想象吧~ </p>
<p>DroidPlugin关于<code>AMS</code>的Hook，可以查看<code>IActivityManagerHook</code>这个类，它处理了我上述所说的兼容性问题，其他原理相同。另外，也许有童鞋有疑问了，你用<code>startActivity</code>为例怎么能确保Hook掉这个静态变量之后就能保证所有使用<code>AMS</code>的入口都被Hook了呢？</p>
<p>答曰：无他，唯手熟尔。</p>
<p>Android Framewrok层对于四大组件的处理，调用<code>AMS</code>服务的时候，全部都是通过使用这种方式；若有疑问可以自行查看源码。你可以从<code>Context</code>类的startActivity, startService,bindService, registerBroadcastReceiver, getContentResolver 等等入口进行跟踪，最终都会发现它们都会使用ActivityManagerNative的这个<code>AMS</code>代理对象来完成对远程AMS的访问。</p>
<h2 id="PMS获取过程">PMS获取过程</h2><p><code>PMS</code>的获取也是通过Context完成的，具体就是<code>getPackageManager</code>这个方法；我们姑且当作已经知道了Context的实现在ContextImpl类里面，直奔<code>ContextImpl</code>类的<code>getPackageManager</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    <span class="keyword">if</span> (pm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Doesn't matter if we make more than one instance.</span></span><br><span class="line">        <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> ApplicationPackageManager(<span class="keyword">this</span>, pm));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里干了两件事：</p>
<ol>
<li>真正的<code>PMS</code>的代理对象在<code>ActivityThread</code>类里面</li>
<li><code>ContextImpl</code>通过<code>ApplicationPackageManager</code>对它还进行了一层包装</li>
</ol>
<p>我们继续查看<code>ActivityThread</code>类的<code>getPackageManager</code>方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder b = ServiceManager.getService(<span class="string">"package"</span>);</span><br><span class="line">    sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">    <span class="keyword">return</span> sPackageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，和<code>AMS</code>一样，<code>PMS</code>的Binder代理对象也是一个全局变量存放在一个静态字段中；我们可以如法炮制，Hook掉PMS。</p>
<p>现在我们的目的很明切，如果需要Hook <code>PMS</code>有两个地方需要Hook掉：</p>
<ol>
<li><code>ActivityThread</code>的静态字段<code>sPackageManager</code></li>
<li>通过Context类的<code>getPackageManager</code>方法获取到的<code>ApplicationPackageManager</code>对象里面的<code>mPM</code>字段。</li>
</ol>
<h2 id="Hook_PMS">Hook PMS</h2><p>现在使用代理Hook应该是轻车熟路了吧，通过上面的分析，我们Hook两个地方；代码信手拈来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取全局的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取ActivityThread里面原始的 sPackageManager</span></span><br><span class="line">Field sPackageManagerField = activityThreadClass.getDeclaredField(<span class="string">"sPackageManager"</span>);</span><br><span class="line">sPackageManagerField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备好代理对象, 用来替换原始的对象</span></span><br><span class="line">Class&lt;?&gt; iPackageManagerInterface = Class.forName(<span class="string">"android.content.pm.IPackageManager"</span>);</span><br><span class="line">Object proxy = Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; iPackageManagerInterface &#125;,</span><br><span class="line">        <span class="keyword">new</span> HookHandler(sPackageManager));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 替换掉ActivityThread里面的 sPackageManager 字段</span></span><br><span class="line">sPackageManagerField.set(currentActivityThread, proxy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 替换 ApplicationPackageManager里面的 mPM对象</span></span><br><span class="line">PackageManager pm = context.getPackageManager();</span><br><span class="line">Field mPmField = pm.getClass().getDeclaredField(<span class="string">"mPM"</span>);</span><br><span class="line">mPmField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">mPmField.set(pm, proxy);</span><br></pre></td></tr></table></figure>
<p>好了，Hook完毕我们验证以下结论；调用一下<code>PMS</code>的<code>getInstalledApplications</code>方法，打印日志如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">03</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">27.187</span>    <span class="number">8306</span>-<span class="number">8306</span>/com.weishu.upf.ams_pms_hook.app D/IActivityManagerHandler﹕ hey, baby; you are hook!!</span><br><span class="line"><span class="number">03</span>-<span class="number">07</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">27.187</span>    <span class="number">8306</span>-<span class="number">8306</span>/com.weishu.upf.ams_pms_hook.app D/IActivityManagerHandler﹕ method:getInstalledApplications called with args:[<span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>OK，我们又成功劫持了<code>PackageManager</code>！！DroidPlugin 处理PMS的代码可以在<code>IPackageManagerHook</code>查看。</p>
<p>在结束讲解PackageManager的Hook之前，我们需要说明一点；那就是<code>Context</code>的实现类里面没有使用静态全局变量来保存<code>PMS</code>的代理对象，而是每拥有一个<code>Context</code>的实例就持有了一个<code>PMS</code>代理对象的引用；所以这里有个很蛋疼的事情，那就是我们如果想要完全Hook住<code>PMS</code>，需要精确控制整个进程内部创建的<code>Context</code>对象；所幸，插件框架中，插件的Activity，Service，ContentProvider，Broadcast等所有使用到Context的地方，都是由框架控制创建的；因此我们要小心翼翼地替换掉所有这些对象持有的<code>PMS</code>代理对象。</p>
<p>我前面也提到过，<strong>静态变量和单例</strong>都是良好的Hook点，这里很好地反证了这句话：想要Hook掉一个实例变量该是多么麻烦!</p>
<h2 id="小结">小结</h2><p>写到这里，关于DroidPlugin的Hook技术的讲解已经完结了；我相信读者或多或少地认识到，其实Hook并不是一项神秘的技术；一个干净，透明的框架少不了AOP，而AOP也少不了Hook。</p>
<p>我所讲解的Hook仅仅使用反射和动态代理技术，更加强大的Hook机制可以进行<strong>字节码编织</strong>，比如J2EE广泛使用了cglib和asm进行AOP编程；而Android上现有的插件框架还是加载编译时代码，采用动态生成类的技术理论上也是可行的；之前有一篇文章<a href="https://segmentfault.com/a/1190000004077469" target="_blank" rel="external">Android动态加载黑科技 动态创建Activity模式</a>，就讲述了这种方式；现在全球的互联网公司不排除有用这种技术实现插件框架的可能 ；我相信不远的未来，这种技术也会在Android上大放异彩。</p>
<p>了解完Hook技术之后，接下来的系列文章会讲述DroidPlugin对Android四大组件在插件系统上的处理，插件框架对于这一部分的实现是DroidPlugin的精髓，Hook只不过是工具而已。学习这部分内容需要对于Activity，Service，Broadcast以及ContentProvider的工作机制有一定的了解，因此我也会在必要的时候穿插讲解一些Android Framework的知识；我相信这一定会对读者大有裨益。</p>
<p>喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>和我的 <a href="http://weishu.me">博客</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在前面的文章中我们介绍了DroidPlugin的Hook机制，也就是<strong>代理方式</strong>和<strong>Binder Hook</strong>；插件框架通过AOP实现了插件使用和开发的透明性。在讲述DroidPlugin如何实现四大组件的插件化之前，有必要说明一下它对ActivityManagerServiche以及PackageManagerService的Hook方式（以下简称AMS，PMS）。</p>
<p>ActivityManagerService对于FrameWork层的重要性不言而喻，Android的四大组件无一不与它打交道：</p>
<ol>
<li><code>startActivity</code>最终调用了AMS的<code>startActivity</code>系列方法，实现了Activity的启动；Activity的生命周期回调，也在AMS中完成；</li>
<li><code>startService,bindService</code>最终调用到AMS的startService和bindService方法；</li>
<li>动态广播的注册和接收在<code>AMS</code>中完成（静态广播在<code>PMS</code>中完成）</li>
<li><code>getContentResolver</code>最终从<code>AMS</code>的<code>getContentProvider</code>获取到ContentProvider</li>
</ol>
<p>而<code>PMS</code>则完成了诸如权限校捡(<code>checkPermission,checkUidPermission</code>)，Apk meta信息获取(<code>getApplicationInfo</code>等)，四大组件信息获取(<code>query</code>系列方法)等重要功能。</p>
<p>在上文<a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Android插件化原理解析——Hook机制之Binder Hook</a>中讲述了DroidPlugin的Binder Hook机制；我们知道<code>AMS</code>和<code>PMS</code>就是以Binder方式提供给应用程序使用的系统服务，理论上我们也可以采用这种方式Hook掉它们。但是由于这两者使用得如此频繁，Framework给他们了一些“特别优待”，这也给了我们相对于Binder Hook更加稳定可靠的hook方式。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android插件化原理解析——Hook机制之Binder Hook]]></title>
    <link href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/"/>
    <id>http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/</id>
    <published>2016-02-16T11:22:45.000Z</published>
    <updated>2016-02-18T03:24:50.000Z</updated>
    <content type="html"><![CDATA[<p>Android系统通过Binder机制给应用程序提供了一系列的系统服务，诸如<code>ActivityManagerService</code>，<code>ClipboardManager</code>， <code>AudioManager</code>等；这些广泛存在系统服务给应用程序提供了诸如任务管理，音频，视频等异常强大的功能。</p>
<p>插件框架作为各个插件的管理者，为了使得插件能够<strong>无缝地</strong>使用这些系统服务，自然会对这些系统服务做出一定的改造(Hook)，使得插件的开发和使用更加方便，从而大大降低插件的开发和维护成本。比如，Hook住<code>ActivityManagerService</code>可以让插件无缝地使用<code>startActivity</code>方法而不是使用特定的方式(比如that语法)来启动插件或者主程序的任意界面。</p>
<p>我们把这种Hook系统服务的机制称之为Binder Hook，因为本质上这些服务提供者都是存在于系统各个进程的Binder对象。因此，要理解接下来的内容必须了解Android的Binder机制，可以参考我之前的文章<a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a></p>
<a id="more"></a>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的<code>binder-hook</code> 模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<h2 id="系统服务的获取过程">系统服务的获取过程</h2><p>我们知道系统的各个远程service对象都是以Binder的形式存在的，而这些Binder有一个管理者，那就是<code>ServiceManager</code>；我们要Hook掉这些service，自然要从这个<code>ServiceManager</code>下手，不然星罗棋布的Binder广泛存在于系统的各个角落，要一个个找出来还真是大海捞针。</p>
<p>回想一下我们使用系统服务的时候是怎么干的，想必这个大家一定再熟悉不过了：通过<code>Context</code>对象的<code>getSystemService</code>方法；比如要使用<code>ActivityManager</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br></pre></td></tr></table></figure>
<p>可是这个貌似跟<code>ServiceManager</code>没有什么关系啊？我们再查看<code>getSystemService</code>方法；(Context的实现在<code>ContextImpl</code>里面)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name);</span><br><span class="line">    <span class="keyword">return</span> fetcher == <span class="keyword">null</span> ? <span class="keyword">null</span> : fetcher.getService(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，所有的service对象都保存在一张<code>map</code>里面，我们再看这个map是怎么初始化的：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registerService<span class="list">(<span class="keyword">ACCOUNT_SERVICE</span>, new ServiceFetcher<span class="list">()</span> &#123;</span><br><span class="line">                public Object createService<span class="list">(<span class="keyword">ContextImpl</span> ctx)</span> &#123;</span><br><span class="line">                    IBinder b = ServiceManager.getService<span class="list">(<span class="keyword">ACCOUNT_SERVICE</span>)</span><span class="comment">;</span></span><br><span class="line">                    IAccountManager service = IAccountManager.Stub.asInterface<span class="list">(<span class="keyword">b</span>)</span><span class="comment">;</span></span><br><span class="line">                    return new AccountManager<span class="list">(<span class="keyword">ctx</span>, service)</span><span class="comment">;</span></span><br><span class="line">                &#125;&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在<code>ContextImpl</code>的静态初始化块里面，有的Service是像上面这样初始化的；可以看到，确实使用了<code>ServiceManager</code>；当然还有一些service并没有直接使用<code>ServiceManager</code>，而是做了一层包装并返回了这个包装对象，比如我们的<code>ActivityManager</code>，它返回的是<code>ActivityManager</code>这个包装对象：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">registerService<span class="list">(<span class="keyword">ACTIVITY_SERVICE</span>, new ServiceFetcher<span class="list">()</span> &#123;</span><br><span class="line">                public Object createService<span class="list">(<span class="keyword">ContextImpl</span> ctx)</span> &#123;</span><br><span class="line">                    return new ActivityManager<span class="list">(<span class="keyword">ctx</span>.getOuterContext<span class="list">()</span>, ctx.mMainThread.getHandler<span class="list">()</span>)</span><span class="comment">;</span></span><br><span class="line">                &#125;&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>但是在<code>ActivityManager</code>这个类内部，也使用了<code>ServiceManager</code>；具体来说，因为ActivityManager里面所有的核心操作都是使用<code>ActivityManagerNative.getDefault()</code>完成的。那么这个语句干了什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line">            IActivityManager am = asInterface(b);</span><br><span class="line">            <span class="keyword">return</span> am;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>因此，通过分析我们得知，系统Service的使用其实就分为两步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IBinder b = ServiceManager.getService(<span class="string">"service_name"</span>); <span class="comment">// 获取原始的IBinder对象</span></span><br><span class="line">IXXInterface in = IXXInterface.Stub.asInterface(b); <span class="comment">// 转换为Service接口</span></span><br></pre></td></tr></table></figure>
<h2 id="寻找Hook点">寻找Hook点</h2><p>在<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">插件框架原理解析——Hook机制之动态代理</a>里面我们说过，Hook分为三步，最关键的一步就是寻找Hook点。我们现在已经搞清楚了系统服务的使用过程，那么就需要找出在这个过程中，在哪个环节是最合适hook的。</p>
<p>由于系统服务的使用者都是对第二步获取到的<code>IXXInterface</code>进行操作，因此如果我们要hook掉某个系统服务，<strong>只需要把第二步的<code>asInterface</code>方法返回的对象修改为为我们Hook过的对象就可以了。</strong></p>
<h3 id="asInterface过程">asInterface过程</h3><p>接下来我们分析<code>asInterface</code>方法，然后想办法把这个方法的返回值修改为我们Hook过的系统服务对象。这里我们以系统剪切版服务为例，源码位置为<code>android.content.IClipboard</code>,<code>IClipboard.Stub.asInterface</code>方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.content.<span class="function">IClipboard <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); <span class="comment">// Hook点</span></span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> android.content.IClipboard))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.content.IClipboard) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android.content.IClipboard.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的意思就是：先查看本进程是否存在这个Binder对象，如果有那么直接就是本进程调用了；如果不存在那么创建一个代理对象，让代理对象委托驱动完成跨进程调用。</p>
<p>观察这个方法，前面的那个if语句判空返回肯定动不了手脚；最后一句调用构造函数然后直接返回我们也是无从下手，要修改<code>asInterface</code>方法的返回值，我们唯一能做的就是从这一句下手：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); <span class="comment">// Hook点</span></span><br></pre></td></tr></table></figure>
<p>我们可以尝试修改这个<code>obj</code>对象的<code>queryLocalInterface</code>方法的返回值，并保证这个返回值符合接下来的<code>if</code>条件检测，那么就达到了修改<code>asInterface</code>方法返回值的目的。</p>
<p>而这个<code>obj</code>对象刚好是我们第一步返回的<code>IBinder</code>对象，接下来我们尝试对这个<code>IBinder</code>对象的<code>queryLocalInterface</code>方法进行hook。</p>
<h3 id="getService过程">getService过程</h3><p>上文分析得知，我们想要修改<code>IBinder</code>对象的<code>queryLocalInterface</code>方法；获取<code>IBinder</code>对象的过程如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">IBinder</span> <span class="keyword">b </span>= ServiceManager.getService(<span class="string">"service_name"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>因此，我们希望能修改这个<code>getService</code>方法的返回值，让这个方法返回一个我们伪造过的<code>IBinder</code>对象；这样，我们可以在自己伪造的<code>IBinder</code>对象的<code>queryLocalInterface</code>方法作处理，进而使得<code>asInterface</code>方法返回在<code>queryLocalInterface</code>方法里面处理过的值，最终实现hook系统服务的目的。</p>
<p>在跟踪这个<code>getService</code>方法之前我们思考一下，由于系统服务是一系列的远程Service，它们的本体，也就是Binder本地对象一般都存在于某个单独的进程，在这个进程之外的其他进程存在的都是这些Binder本地对象的代理。因此在我们的进程里面，存在的也只是这个Binder代理对象，我们也只能对这些Binder代理对象下手。(如果这一段看不懂，建议不要往下看了，先看<a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a>)</p>
<p>然后，这个<code>getService</code>是一个静态方法，如果此方法什么都不做，拿到Binder代理对象之后直接返回；那么我们就无能为力了：我们没有办法拦截一个静态方法，也没有办法获取到这个静态方法里面的局部变量(即我们希望修改的那个Binder代理对象)。</p>
<p>接下来就可以看这个<code>getService</code>的代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title">getService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder service = sCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getIServiceManager().getService(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"error in getService"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>天无绝人之路！<code>ServiceManager</code>为了避免每次都进行跨进程通信，把这些Binder代理对象缓存在一张<code>map</code>里面。</p>
<p>我们可以替换这个map里面的内容为Hook过的<code>IBinder</code>对象，由于系统在<code>getService</code>的时候每次都会优先查找缓存，因此返回给使用者的都是被我们修改过的对象，从而达到瞒天过海的目的。</p>
<p>总结一下，要达到修改系统服务的目的，我们需要如下两步：</p>
<ol>
<li>首先肯定需要<strong>伪造一个系统服务对象</strong>，接下来就要想办法让<code>asInterface</code>能够返回我们的这个伪造对象而不是原始的系统服务对象。</li>
<li>通过上文分析我们知道，只要让<code>getService</code>返回<code>IBinder</code>对象的<code>queryLocalInterface</code>方法直接返回我们伪造过的系统服务对象就能达到目的。所以，我们需要<strong>伪造一个IBinder对象</strong>，主要是修改它的<code>queryLocalInterface</code>方法，让它返回我们伪造的系统服务对象；然后把这个伪造对象放置在<code>ServiceManager</code>的缓存<code>map</code>里面即可。</li>
</ol>
<p>我们通过Binder机制的<em>优先查找本地Binder对象</em>的这个特性达到了Hook掉系统服务对象的目的。因此<code>queryLocalInterface</code>也失去了它原本的意义(只查找本地Binder对象，没有本地对象返回null)，这个方法只是一个傀儡，是我们实现hook系统对象的桥梁：我们通过这个“漏洞”让<code>asInterface</code>永远都返回我们伪造过的对象。由于我们接管了<code>asInterface</code>这个方法的全部，我们伪造过的这个系统服务对象不能是只拥有本地Binder对象(原始<code>queryLocalInterface</code>方法返回的对象)的能力，还要有Binder代理对象操纵驱动的能力。</p>
<p>接下来我们就以Hook系统的剪切版服务为例，用实际代码来说明，如何Hook掉系统服务。</p>
<h2 id="Hook系统剪切版服务">Hook系统剪切版服务</h2><h3 id="伪造剪切版服务对象">伪造剪切版服务对象</h3><p>首先我们用代理的方式伪造一个剪切版服务对象，关于如何使用代理的方式进行hook以及其中的原理，可以查看<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">插件框架原理解析——Hook机制之动态代理</a>。</p>
<p>具体代码如下，我们用动态代理的方式Hook掉了<code>hasPrimaryClip()</code>，<code>getPrimaryClip()</code>这两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderHookHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BinderHookHandler"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始的Service对象 (IInterface)</span></span><br><span class="line">    Object base;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinderHookHandler</span><span class="params">(IBinder base, Class&lt;?&gt; stubClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method asInterfaceMethod = stubClass.getDeclaredMethod(<span class="string">"asInterface"</span>, IBinder.class);</span><br><span class="line">            <span class="comment">// IClipboard.Stub.asInterface(base);</span></span><br><span class="line">            <span class="keyword">this</span>.base = asInterfaceMethod.invoke(<span class="keyword">null</span>, base);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"hooked failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@TargetApi</span>(Build.VERSION_CODES.HONEYCOMB)</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把剪切版的内容替换为 "you are hooked"</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"getPrimaryClip"</span>.equals(method.getName())) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"hook getPrimaryClip"</span>);</span><br><span class="line">            <span class="keyword">return</span> ClipData.newPlainText(<span class="keyword">null</span>, <span class="string">"you are hooked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 欺骗系统,使之认为剪切版上一直有内容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"hasPrimaryClip"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method.invoke(base, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，我们拿到原始的<code>IBinder</code>对象之后，如果我们希望使用被Hook之前的系统服务，并不能直接使用这个<code>IBinder</code>对象，而是需要使用<code>asInterface</code>方法将它转换为<code>IClipboard</code>接口；因为<code>getService</code>方法返回的<code>IBinder</code>实际上是一个<strong>裸Binder代理对象</strong>，它只有与驱动打交道的能力，但是它并不能独立工作，需要人指挥它；<code>asInterface</code>方法返回的<code>IClipboard.Stub.Proxy</code>类的对象通过操纵这个裸<code>BinderProxy</code>对象从而实现了具体的<code>IClipboard</code>接口定义的操作。</p>
<h3 id="伪造IBinder_对象">伪造<code>IBinder</code> 对象</h3><p>在上一步中，我们已经伪造好了系统服务对象，现在要做的就是想办法让<code>asInterface</code>方法返回我们伪造的对象了；我们伪造一个<code>IBinder</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxyHookHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BinderProxyHookHandler"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绝大部分情况下,这是一个BinderProxy对象</span></span><br><span class="line">    <span class="comment">// 只有当Service和我们在同一个进程的时候才是Binder本地对象</span></span><br><span class="line">    <span class="comment">// 这个基本不可能</span></span><br><span class="line">    IBinder base;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; stub;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; iinterface;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinderProxyHookHandler</span><span class="params">(IBinder base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.base = base;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.stub = Class.forName(<span class="string">"android.content.IClipboard$Stub"</span>);</span><br><span class="line">            <span class="keyword">this</span>.iinterface = Class.forName(<span class="string">"android.content.IClipboard"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"queryLocalInterface"</span>.equals(method.getName())) &#123;</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, <span class="string">"hook queryLocalInterface"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里直接返回真正被Hook掉的Service接口</span></span><br><span class="line">            <span class="comment">// 这里的 queryLocalInterface 就不是原本的意思了</span></span><br><span class="line">            <span class="comment">// 我们肯定不会真的返回一个本地接口, 因为我们接管了 asInterface方法的作用</span></span><br><span class="line">            <span class="comment">// 因此必须是一个完整的 asInterface 过的 IInterface对象, 既要处理本地对象,也要处理代理对象</span></span><br><span class="line">            <span class="comment">// 这只是一个Hook点而已, 它原始的含义已经被我们重定义了; 因为我们会永远确保这个方法不返回null</span></span><br><span class="line">            <span class="comment">// 让 IClipboard.Stub.asInterface 永远走到if语句的else分支里面</span></span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(proxy.getClass().getClassLoader(),</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// asInterface 的时候会检测是否是特定类型的接口然后进行强制转换</span></span><br><span class="line">                    <span class="comment">// 因此这里的动态代理生成的类型信息的类型必须是正确的</span></span><br><span class="line">                    <span class="keyword">new</span> Class[] &#123; IBinder.class, IInterface.class, <span class="keyword">this</span>.iinterface &#125;,</span><br><span class="line">                    <span class="keyword">new</span> BinderHookHandler(base, stub));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, <span class="string">"method:"</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> method.invoke(base, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用动态代理的方式伪造了一个跟原始<code>IBinder</code>一模一样的对象，然后在这个伪造的<code>IBinder</code>对象的<code>queryLocalInterface</code>方法里面返回了我们第一步创建的<strong>伪造过的系统服务对象</strong>；注意看注释，详细解释可以看<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">代码</a></p>
<h3 id="替换ServiceManager的IBinder对象">替换ServiceManager的<code>IBinder</code>对象</h3><p>现在就是万事具备，只欠东风了；我们使用反射的方式修改<code>ServiceManager</code>类里面缓存的Binder对象，使得<code>getService</code>方法返回我们伪造的<code>IBinder</code>对象，进而<code>asInterface</code>方法使用伪造<code>IBinder</code>对象的<code>queryLocalInterface</code>方法返回了我们伪造的系统服务对象。代码较简单，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String CLIPBOARD_SERVICE = <span class="string">"clipboard"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这一段的意思实际就是: ServiceManager.getService("clipboard");</span></span><br><span class="line"><span class="comment">// 只不过 ServiceManager这个类是@hide的</span></span><br><span class="line">Class&lt;?&gt; serviceManager = Class.forName(<span class="string">"android.os.ServiceManager"</span>);</span><br><span class="line">Method getService = serviceManager.getDeclaredMethod(<span class="string">"getService"</span>, String.class);</span><br><span class="line"><span class="comment">// ServiceManager里面管理的原始的Clipboard Binder对象</span></span><br><span class="line"><span class="comment">// 一般来说这是一个Binder代理对象</span></span><br><span class="line">IBinder rawBinder = (IBinder) getService.invoke(<span class="keyword">null</span>, CLIPBOARD_SERVICE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook 掉这个Binder代理对象的 queryLocalInterface 方法</span></span><br><span class="line"><span class="comment">// 然后在 queryLocalInterface 返回一个IInterface对象, hook掉我们感兴趣的方法即可.</span></span><br><span class="line">IBinder hookedBinder = (IBinder) Proxy.newProxyInstance(serviceManager.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; IBinder.class &#125;,</span><br><span class="line">        <span class="keyword">new</span> BinderProxyHookHandler(rawBinder));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把这个hook过的Binder代理对象放进ServiceManager的cache里面</span></span><br><span class="line"><span class="comment">// 以后查询的时候 会优先查询缓存里面的Binder, 这样就会使用被我们修改过的Binder了</span></span><br><span class="line">Field cacheField = serviceManager.getDeclaredField(<span class="string">"sCache"</span>);</span><br><span class="line">cacheField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Map&lt;String, IBinder&gt; cache = (Map) cacheField.get(<span class="keyword">null</span>);</span><br><span class="line">cache.put(CLIPBOARD_SERVICE, hookedBinder);</span><br></pre></td></tr></table></figure>
<p>接下来，在app里面使用剪切版，比如长按进行粘贴之后，剪切版的内容永远都是<code>you are hooked</code>了；这样，我们Hook系统服务的目的宣告完成！详细的代码参见 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">github</a>。</p>
<p>也许你会问，插件框架会这么hook吗？如果不是那么插件框架hook这些干什么？插件框架当然不会做替换文本这么无聊的事情，DroidPlugin插件框架管理插件使得插件就像是主程序一样，因此插件需要使用主程序的剪切版，插件之间也会共用剪切版；其他的一些系统服务也类似，这样就可以达到插件和宿主程序之间的天衣服缝，水乳交融！另外，<code>ActivityManager</code>以及<code>PackageManager</code>这两个系统服务虽然也可以通过这种方式hook，但是由于它们的重要性和特殊性，DroidPlugin使用了另外一种方式，我们会单独讲解。</p>
<p>喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a> 和我的 <a href="http://weishu.me/">博客</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android系统通过Binder机制给应用程序提供了一系列的系统服务，诸如<code>ActivityManagerService</code>，<code>ClipboardManager</code>， <code>AudioManager</code>等；这些广泛存在系统服务给应用程序提供了诸如任务管理，音频，视频等异常强大的功能。</p>
<p>插件框架作为各个插件的管理者，为了使得插件能够<strong>无缝地</strong>使用这些系统服务，自然会对这些系统服务做出一定的改造(Hook)，使得插件的开发和使用更加方便，从而大大降低插件的开发和维护成本。比如，Hook住<code>ActivityManagerService</code>可以让插件无缝地使用<code>startActivity</code>方法而不是使用特定的方式(比如that语法)来启动插件或者主程序的任意界面。</p>
<p>我们把这种Hook系统服务的机制称之为Binder Hook，因为本质上这些服务提供者都是存在于系统各个进程的Binder对象。因此，要理解接下来的内容必须了解Android的Binder机制，可以参考我之前的文章<a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a></p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="binder" scheme="http://weishu.me/tags/binder/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[提升markdown的中文输入效率]]></title>
    <link href="http://weishu.me/2016/02/01/avoid-switching-keyboard-in-markdown/"/>
    <id>http://weishu.me/2016/02/01/avoid-switching-keyboard-in-markdown/</id>
    <published>2016-02-01T08:15:56.000Z</published>
    <updated>2016-02-16T11:37:47.000Z</updated>
    <content type="html"><![CDATA[<p>Markdown这种格式的出现大大提升了写作的效率，但是它对于非英文的用户其实并不友好：每当我们需要使用<code>#[-</code>等标志符的时候，需要不断地切换输入法。</p>
<p>首先，切换输入法(就算是按<code>shift</code>键)让我们的思维不连贯；其次，一旦中间有一次切换出错，那么又有撤销的成本；我相信每一个非英文markdown的使用者都有这种困惑；实际想要达到的效果如下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201602markdown_keymap_remapping.gif" alt="效果图"></p>
<a id="more"></a>
<p>避免输入法切换最简单的办法就是把markdown使用的那些特定字符<code>!-[]#*()</code>，直接使用半角符号代替全角符号；完成这个功能最好的角色是输入法；但目前除了可以定制的鼠须管等能完成，其他的国产输入以及系统输入法都不支持；在第三方输入法支持这个功能之前，我这里给出一个简单的方案。</p>
<h3 id="如果你使用鼠须管">如果你使用鼠须管</h3><p>鼠须管/小狼嚎 输入法是可以定制的，如果你是这种输入法的用户，那么恭喜你，实现方式非常简单；修改一下配置即可，具体做法见<a href="http://irising.me/2013/07/17627/" target="_blank" rel="external">调整「鼠须管」实现高效的Markdown输入</a></p>
<h3 id="如果你使用Mac">如果你使用Mac</h3><p>如果你使用第三方输入法或者mac的系统输入法，那么我们可以通过修改键盘映射来解决这个问题：把全角的markdown映射为半角符号。具体做法如下：</p>
<h5 id="安装Karabiner软件">安装Karabiner软件</h5><p>下载地址点<a href="https://pqrs.org/osx/karabiner/" target="_blank" rel="external">这里</a>；按照步骤安装，注意开启之后需要在系统设置里面给它使用辅助功能权限</p>
<h5 id="设置键盘映射">设置键盘映射</h5><p>首先，打开Karabiner软件，选择<code>Misc&amp;Uninstall</code>选项卡，如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1454310098796.png" width="740"></p>
<p>然后，点击上图标识的<code>open private.xml</code>那个按钮，用文本编辑器打开这个文件：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1454310263101.png" width="574"></p>
<p>接着去 <a href="https://gist.github.com/tiann/9068fd34f44337e8dcfb" target="_blank" rel="external">gist</a>上把<code>markdown_keyboard_remapping.xml</code>里面的代码copy到这个文件里面，全部替换即可(代码有点长，我就不贴了，自行<a href="https://gist.github.com/tiann/9068fd34f44337e8dcfb" target="_blank" rel="external">下载</a>)：</p>
<p>最后，打开Karabiner软件的第一个选项卡，重新加载配置就完成了，如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201601/1454310388700.png" width="771"></p>
<h3 id="如果你使用Windows">如果你使用Windows</h3><p>Windows下面有神器<code>AutoHotKey</code>，解决这个完全不在话下；与Mac下面简单粗暴地直接把全角符号替换为半角符号不同，AHK可以保留原来的方案，用<code>alt ＋ 符号</code>来输入需要的半角符号；这样两种可以共存。</p>
<ol>
<li>首先，安装AHK软件，下载点<a href="https://gist.github.com/tiann/9068fd34f44337e8dcfb" target="_blank" rel="external">这里</a></li>
<li>然后下载文件<a href="https://gist.github.com/tiann/9068fd34f44337e8dcfb" target="_blank" rel="external">markdown_keyboard_remapping.ahk</a></li>
</ol>
<p>接着双击这个文件，整个过程就完成了；最好把这个文件加入开机启动，这样每次开机就能用了。</p>
<p>Windows下面的使用方法是<code>alt ＋ 数字键/符号键</code>；比如想输入<code>[</code>，可以在任何输入法下直接使用<code>alt ＋ [</code>；如果想输入<code>#</code>，可以直接使用<code>alt ＋ 3</code>。</p>
<p>通过这种设置，我们使用markdown写作的时候就流畅多了!避免了繁琐的各种切换，真正享受到markdown格式的好处，Have Fun!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Markdown这种格式的出现大大提升了写作的效率，但是它对于非英文的用户其实并不友好：每当我们需要使用<code>#[-</code>等标志符的时候，需要不断地切换输入法。</p>
<p>首先，切换输入法(就算是按<code>shift</code>键)让我们的思维不连贯；其次，一旦中间有一次切换出错，那么又有撤销的成本；我相信每一个非英文markdown的使用者都有这种困惑；实际想要达到的效果如下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201602markdown_keymap_remapping.gif" alt="效果图"></p>]]>
    
    </summary>
    
      <category term="markdown" scheme="http://weishu.me/tags/markdown/"/>
    
      <category term="实用技巧" scheme="http://weishu.me/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android插件化原理解析——Hook机制之动态代理]]></title>
    <link href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/"/>
    <id>http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/</id>
    <published>2016-01-28T12:27:13.000Z</published>
    <updated>2016-04-20T09:09:43.000Z</updated>
    <content type="html"><![CDATA[<p>使用代理机制进行API Hook进而达到方法增强是框架的常用手段，比如J2EE框架Spring通过动态代理优雅地实现了AOP编程，极大地提升了Web开发效率；同样，插件框架也广泛使用了代理机制来增强系统API从而达到插件化的目的。本文将带你了解基于动态代理的Hook机制。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>，参考此项目的<code>dynamic-proxy-hook</code>模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<h2 id="代理是什么">代理是什么</h2><p>为什么需要代理呢？其实这个代理与日常生活中的“代理”，“中介”差不多；比如你想海淘买东西，总不可能亲自飞到国外去购物吧，这时候我们使用第三方海淘服务比如惠惠购物助手等；同样拿购物为例，有时候第三方购物会有折扣比如当初的米折网，这时候我们可以少花点钱；当然有时候这个“代理”比较坑，坑我们的钱，坑我们的货。</p>
<p>从这个例子可以看出来，代理可以实现<strong>方法增强</strong>，比如常用的<em>日志</em>,<em>缓存</em>等；也可以实现方法拦截，通过代理方法修改原方法的参数和返回值，从而实现某种不可告人的目的～接下来我们用代码解释一下。<br><a id="more"></a></p>
<h2 id="静态代理">静态代理</h2><p>静态代理，是最原始的代理方式；假设我们有一个购物的接口，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    Object[] doShopping(<span class="keyword">long</span> money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它有一个原始的实现，我们可以理解为亲自，直接去商店购物：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingImpl</span> <span class="keyword">implements</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] doShopping(<span class="keyword">long</span> money) &#123;</span><br><span class="line">        System.out.println(<span class="string">"逛淘宝 ,逛商场,买买买!!"</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"花了%s块钱"</span>, money));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object[] &#123; <span class="string">"鞋子"</span>, <span class="string">"衣服"</span>, <span class="string">"零食"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，现在我们自己没时间但是需要买东西，于是我们就找了个代理帮我们买：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyShopping</span> <span class="keyword">implements</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Shopping base;</span><br><span class="line"></span><br><span class="line">    ProxyShopping(Shopping base) &#123;</span><br><span class="line">        <span class="keyword">this</span>.base = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] doShopping(<span class="keyword">long</span> money) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先黑点钱(修改输入参数)</span></span><br><span class="line">        <span class="keyword">long</span> readCost = (<span class="keyword">long</span>) (money * <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="string">"花了%s块钱"</span>, readCost));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帮忙买东西</span></span><br><span class="line">        Object[] things = base.doShopping(readCost);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偷梁换柱(修改返回值)</span></span><br><span class="line">        <span class="keyword">if</span> (things != <span class="keyword">null</span> &amp;&amp; things.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            things[<span class="number">0</span>] = <span class="string">"被掉包的东西!!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> things;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很不幸，我们找的这个代理有点坑，坑了我们的钱还坑了我们的货；先忍忍。</p>
<h2 id="动态代理">动态代理</h2><p>传统的静态代理模式需要为每一个需要代理的类写一个代理类，如果需要代理的类有几百个那不是要累死？为了更优雅地实现代理模式，JDK提供了动态代理方式，可以简单理解为JVM可以在运行时帮我们动态生成一系列的代理类，这样我们就不需要手写每一个静态的代理类了。依然以购物为例，用动态代理实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Shopping women = <span class="keyword">new</span> ShoppingImpl();</span><br><span class="line">    <span class="comment">// 正常购物</span></span><br><span class="line">    System.out.println(Arrays.toString(women.doShopping(<span class="number">100</span>)));</span><br><span class="line">    <span class="comment">// 招代理</span></span><br><span class="line">    women = (Shopping) Proxy.newProxyInstance(Shopping.class.getClassLoader(),</span><br><span class="line">            women.getClass().getInterfaces(), <span class="keyword">new</span> ShoppingHandler(women));</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(women.doShopping(<span class="number">100</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态代理主要处理<code>InvocationHandler</code>和<code>Proxy</code>类；完整代码可以见<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">github</a></p>
<h2 id="代理Hook">代理Hook</h2><p>我们知道代理有比原始对象更强大的能力，比如飞到国外买东西，比如坑钱坑货；那么很自然，如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，那么就可以在这个代理对象为所欲为了；修改参数，替换返回值，我们称之为Hook。</p>
<p>下面我们Hook掉<code>startActivity</code>这个方法，使得每次调用这个方法之前输出一条日志；（当然，这个输入日志有点点弱，只是为了展示原理；只要你想，你想可以替换参数，拦截这个<code>startActivity</code>过程，使得调用它导致启动某个别的Activity，指鹿为马！）</p>
<p>首先我们得找到被Hook的对象，我称之为Hook点；什么样的对象比较好Hook呢？自然是<strong>容易找到的对象</strong>。什么样的对象容易找到？<strong>静态变量和单例</strong>；在一个进程之内，静态变量和单例变量是相对不容易发生变化的，因此非常容易定位，而普通的对象则要么无法标志，要么容易改变。我们根据这个原则找到所谓的Hook点。</p>
<p>然后我们分析一下<code>startActivity</code>的调用链，找出合适的Hook点。我们知道对于<code>Context.startActivity</code>（Activity.startActivity的调用链与之不同），由于<code>Context</code>的实现实际上是<code>ContextImpl</code>;我们看<code>ConetxtImpl</code>类的<code>startActivity</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                <span class="string">"Calling startActivity() from outside of an Activity "</span></span><br><span class="line">                + <span class="string">" context requires the FLAG_ACTIVITY_NEW_TASK flag."</span></span><br><span class="line">                + <span class="string">" Is this really what you want?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">        getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">        (Activity)<span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，实际上使用了<code>ActivityThread</code>类的<code>mInstrumentation</code>成员的<code>execStartActivity</code>方法；注意到，<code>ActivityThread</code> 实际上是主线程，而主线程一个进程只有一个，因此这里是一个良好的Hook点。</p>
<p>接下来就是想要Hook掉我们的主线程对象，也就是把这个主线程对象里面的<code>mInstrumentation</code>给替换成我们修改过的代理对象；要替换主线程对象里面的字段，首先我们得拿到主线程对象的引用，如何获取呢？<code>ActivityThread</code>类里面有一个静态方法<code>currentActivityThread</code>可以帮助我们拿到这个对象类；但是<code>ActivityThread</code>是一个隐藏类，我们需要用反射去获取，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>拿到这个<code>currentActivityThread</code>之后，我们需要修改它的<code>mInstrumentation</code>这个字段为我们的代理对象，我们先实现这个代理对象，由于JDK动态代理只支持接口，而这个<code>Instrumentation</code>是一个类，没办法，我们只有手动写静态代理类，覆盖掉原始的方法即可。（<code>cglib</code>可以做到基于类的动态代理，这里先不介绍）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilInstrumentation</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"EvilInstrumentation"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ActivityThread中原始的对象, 保存起来</span></span><br><span class="line">    Instrumentation mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilInstrumentation</span><span class="params">(Instrumentation base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook之前, <span class="label">XXX到此一游!</span></span></span><br><span class="line">        Log.d(TAG, <span class="string">"\n执行了startActivity, 参数如下: \n"</span> + <span class="string">"who = ["</span> + who + <span class="string">"], "</span> +</span><br><span class="line">                <span class="string">"\ncontextThread = ["</span> + contextThread + <span class="string">"], \ntoken = ["</span> + token + <span class="string">"], "</span> +</span><br><span class="line">                <span class="string">"\ntarget = ["</span> + target + <span class="string">"], \nintent = ["</span> + intent +</span><br><span class="line">                <span class="string">"], \nrequestCode = ["</span> + requestCode + <span class="string">"], \noptions = ["</span> + options + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始调用原始的方法, 调不调用随你,但是不调用的话, 所有的startActivity都失效了.</span></span><br><span class="line">        <span class="comment">// 由于这个方法是隐藏的,因此需要使用反射调用;首先找到这个方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method execStartActivity = Instrumentation.class.getDeclaredMethod(</span><br><span class="line">                    <span class="string">"execStartActivity"</span>,</span><br><span class="line">                    Context.class, IBinder.class, IBinder.class, Activity.class, </span><br><span class="line">                    Intent.class, <span class="keyword">int</span>.class, Bundle.class);</span><br><span class="line">            execStartActivity.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (ActivityResult) execStartActivity.invoke(mBase, who, </span><br><span class="line">                    contextThread, token, target, intent, requestCode, options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 某该死的rom修改了  需要手动适配</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"do not support!!! pls adapt it"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ok，有了代理对象，我们要做的就是偷梁换柱！代码比较简单，采用反射直接修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attachContext</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 先获取到当前的ActivityThread对象</span></span><br><span class="line">    Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">    currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到原始的 mInstrumentation字段</span></span><br><span class="line">    Field mInstrumentationField = activityThreadClass.getDeclaredField(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">    mInstrumentationField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(currentActivityThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    Instrumentation evilInstrumentation = <span class="keyword">new</span> EvilInstrumentation(mInstrumentation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偷梁换柱</span></span><br><span class="line">    mInstrumentationField.set(currentActivityThread, evilInstrumentation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，我们启动一个Activity测试一下，结果如下：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1453981415720.png" width="866"></p>
<p>可见，Hook确实成功了！这就是使用代理进行Hook的原理——偷梁换柱。整个Hook过程简要总结如下：</p>
<ol>
<li>寻找Hook点，原则是静态变量或者单例对象，尽量Hook pulic的对象和方法，非public不保证每个版本都一样，需要适配。</li>
<li>选择合适的代理方式，如果是接口可以用动态代理；如果是类可以手动写代理也可以使用cglib。</li>
<li>偷梁换柱——用代理对象替换原始对象</li>
</ol>
<p>完整代码参照：<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>；里面留有一个作业：我们目前仅Hook了<code>Context</code>类的<code>startActivity</code>方法，但是<code>Activity</code>类却使用了自己的<code>mInstrumentation</code>；你可以尝试Hook掉Activity类的<code>startActivity</code>方法。</p>
<p>喜欢就点个赞吧～持续更新，请关注github项目 <a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>和我的 <a href="http://weishu.me">博客</a>!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用代理机制进行API Hook进而达到方法增强是框架的常用手段，比如J2EE框架Spring通过动态代理优雅地实现了AOP编程，极大地提升了Web开发效率；同样，插件框架也广泛使用了代理机制来增强系统API从而达到插件化的目的。本文将带你了解基于动态代理的Hook机制。</p>
<p>阅读本文之前，可以先clone一份 <a href="https://github.com/tiann/understand-plugin-framework">understand-plugin-framework</a>，参考此项目的<code>dynamic-proxy-hook</code>模块。另外，插件框架原理解析系列文章见<a href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/">索引</a>。</p>
<h2 id="代理是什么">代理是什么</h2><p>为什么需要代理呢？其实这个代理与日常生活中的“代理”，“中介”差不多；比如你想海淘买东西，总不可能亲自飞到国外去购物吧，这时候我们使用第三方海淘服务比如惠惠购物助手等；同样拿购物为例，有时候第三方购物会有折扣比如当初的米折网，这时候我们可以少花点钱；当然有时候这个“代理”比较坑，坑我们的钱，坑我们的货。</p>
<p>从这个例子可以看出来，代理可以实现<strong>方法增强</strong>，比如常用的<em>日志</em>,<em>缓存</em>等；也可以实现方法拦截，通过代理方法修改原方法的参数和返回值，从而实现某种不可告人的目的～接下来我们用代码解释一下。<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android插件化原理解析——概要]]></title>
    <link href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/"/>
    <id>http://weishu.me/2016/01/28/understand-plugin-framework-overview/</id>
    <published>2016-01-28T03:07:36.000Z</published>
    <updated>2016-07-12T11:30:32.000Z</updated>
    <content type="html"><![CDATA[<p>2015年是Android插件化技术突飞猛进的一年，随着业务的发展各大厂商都碰到了Android Native平台的瓶颈：</p>
<ol>
<li>从技术上讲，业务逻辑的复杂导致代码量急剧膨胀，各大厂商陆续出到65535方法数的天花板；同时，运营为王的时代对于模块热更新提出了更高的要求。</li>
<li>在业务层面上，功能模块的解耦以及维护团队的分离也是大势所趋；各个团队维护着同一个App的不同模块，如果每个模块升级新功能都需要对整个app进行升级，那么发布流程不仅复杂而且效率低下；在讲究小步快跑和持续迭代的移动互联网必将遭到淘汰。</li>
</ol>
<p>H5和Hybird可以解决这些问题，但是始终比不上native的用户体验；于是，国外的FaceBook推出了<code>react-native</code>；而国内各大厂商几乎都选择纯native的插件化技术。可以说，Android的未来必将是<code>react-native</code>和插件化的天下。</p>
<a id="more"></a>
<p><code>react-native</code>资料很多，但是讲述插件化的却凤毛菱角；插件化技术听起来高深莫测，实际上要解决的就是两个问题：</p>
<ol>
<li>代码加载</li>
<li>资源加载</li>
</ol>
<h2 id="代码加载">代码加载</h2><p>类的加载可以使用Java的<code>ClassLoader</code>机制，但是对于Android来说，并不是说类加载进来就可以用了，很多组件都是有“生命”的；因此对于这些有血有肉的类，必须给它们注入活力，也就是所谓的<strong>组件生命周期管理</strong>；</p>
<p>另外，如何管理加载进来的类也是一个问题。假设多个插件依赖了相同的类，是抽取公共依赖进行管理还是插件单独依赖？这就是<strong>ClassLoader的管理问题</strong>；</p>
<h2 id="资源加载">资源加载</h2><p>资源加载方案大家使用的原理都差不多，都是用<code>AssetManager</code>的隐藏方法<code>addAssetPath</code>；但是，不同插件的资源如何管理？是公用一套资源还是插件独立资源？共用资源如何避免资源冲突？对于资源加载，有的方案共用一套资源并采用资源分段机制解决冲突（要么修改<code>aapt</code>要么添加编译插件）；有的方案选择独立资源，不同插件管理自己的资源。</p>
<p>目前国内开源的较成熟的插件方案有<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">DL</a>和<a href="https://github.com/Qihoo360/DroidPlugin" target="_blank" rel="external">DroidPlugin</a>；但是DL方案仅仅对Frameworl的表层做了处理，严重依赖<code>that</code>语法，编写插件代码和主程序代码需单独区分；而DroidPlugin通过Hook增强了Framework层的很多系统服务，开发插件就跟开发独立app差不多；就拿Activity生命周期的管理来说，DL的代理方式就像是牵线木偶，插件只不过是操纵傀儡而已；而DroidPlugin则是借尸还魂，插件是有血有肉的系统管理的真正组件；DroidPlugin Hook了系统几乎所有的Sevice，欺骗了大部分的系统API；掌握这个Hook过程需要掌握很多系统原理，因此学习DroidPlugin对于整个Android FrameWork层大有裨益。</p>
<p>接下来的一系列文章将以DroidPlugin为例讲解插件框架的原理，揭开插件化的神秘面纱；同时还能帮助深入理解Android Framewrok；主要内容如下：</p>
<ul>
<li><a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Hook机制之动态代理</a></li>
<li><a href="http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/">Hook机制之Binder Hook</a></li>
<li><a href="http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Hook机制之AMS&amp;PMS</a></li>
<li><a href="http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/">Activity生命周期管理</a></li>
<li><a href="http://weishu.me/2016/04/05/understand-plugin-framework-classloader/">插件加载机制</a></li>
<li><a href="http://weishu.me/2016/04/12/understand-plugin-framework-receiver/">广播的管理方式</a></li>
<li><a href="http://weishu.me/2016/05/11/understand-plugin-framework-service/">Service的插件化</a></li>
<li><a href="http://weishu.me/2016/07/12/understand-plugin-framework-content-provider/">ContentProvider的插件化</a></li>
<li>DroidPlugin插件通信机制</li>
<li>插件机制之资源管理</li>
<li>不同插件框架方案对比</li>
<li>插件化的未来</li>
</ul>
<p>另外，对于每一章内容都会有详细的demo，具体见<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>；喜欢就点个关注吧～定期更新，敬请期待！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015年是Android插件化技术突飞猛进的一年，随着业务的发展各大厂商都碰到了Android Native平台的瓶颈：</p>
<ol>
<li>从技术上讲，业务逻辑的复杂导致代码量急剧膨胀，各大厂商陆续出到65535方法数的天花板；同时，运营为王的时代对于模块热更新提出了更高的要求。</li>
<li>在业务层面上，功能模块的解耦以及维护团队的分离也是大势所趋；各个团队维护着同一个App的不同模块，如果每个模块升级新功能都需要对整个app进行升级，那么发布流程不仅复杂而且效率低下；在讲究小步快跑和持续迭代的移动互联网必将遭到淘汰。</li>
</ol>
<p>H5和Hybird可以解决这些问题，但是始终比不上native的用户体验；于是，国外的FaceBook推出了<code>react-native</code>；而国内各大厂商几乎都选择纯native的插件化技术。可以说，Android的未来必将是<code>react-native</code>和插件化的天下。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你真的了解AsyncTask？]]></title>
    <link href="http://weishu.me/2016/01/18/dive-into-asynctask/"/>
    <id>http://weishu.me/2016/01/18/dive-into-asynctask/</id>
    <published>2016-01-18T07:41:08.000Z</published>
    <updated>2016-01-18T07:47:21.000Z</updated>
    <content type="html"><![CDATA[<p>虽说现在做网络请求有了Volley全家桶和OkHttp这样好用的库，但是在处理其他后台任务以及与UI交互上，还是需要用到AsyncTask。但是你真的了解AsyncTask吗？</p>
<p>AsyncTask的实现几经修改，因此在不同版本的Android系统上表现各异；我相信，任何一个用户量上千万的产品绝对不会在代码里面使用系统原生的AsynTask，因为它蛋疼的兼容性以及极高的崩溃率实在让人不敢恭维。本文将带你了解AsyncTask背后的原理，并给出一个久经考验的AsyncTask修改版。</p>
<a id="more"></a>
<h2 id="AsyncTask是什么？">AsyncTask是什么？</h2><p>AsyncTask到底是什么呢？很简单，<strong>它不过是对线程池和Handler的封装</strong>；用线程池来处理后台任务，用Handler来处理与UI的交互。线程池使用的是<code>Executor</code>接口，我们先了解一下线程池的特性。</p>
<h2 id="线程池ThreadPoolExecutor">线程池ThreadPoolExecutor</h2><p>JDK5带来的一大改进就是Java的并发能力，它提供了三种并发武器：并发框架Executor，并发集合类型如ConcurrentHashMap，并发控制类如CountDownLatch等；圣经《Effective Java》也说，尽量使用Exector而不是直接用Thread类进行并发编程。</p>
<p>AsyncTask内部也使用了线程池处理并发；线程池通过<code>ThreadPoolExector</code>类构造，这个构造函数参数比较多，它允许开发者对线程池进行定制，我们先看看这每个参数是什么意思，然后看看Android是以何种方式定制的。</p>
<p>ThreadPoolExecutor的其他构造函数最终都会调用如下的构造函数完成对象创建工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                          <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                          <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize: 核心线程数目，即使线程池没有任务，核心线程也不会终止（除非设置了allowCoreThreadTimeOut参数）可以理解为“常驻线程”</li>
<li>maximumPoolSize: 线程池中允许的最大线程数目；一般来说，线程越多，线程调度开销越大；因此一般都有这个限制。</li>
<li>keepAliveTime: 当线程池中的线程数目比核心线程多的时候，如果超过这个keepAliveTime的时间，多余的线程会被回收；这些与核心线程相对的线程通常被称为<em>缓存线程</em></li>
<li>unit: keepAliveTime的时间单位</li>
<li>workQueue: 任务执行前保存任务的队列；这个队列仅保存由execute提交的Runnable任务</li>
<li>threadFactory: 用来构造线程池的工厂；一般都是使用默认的；</li>
<li>handler: 当线程池由于线程数目和队列限制而导致后续任务阻塞的时候，线程池的处理方式。</li>
</ul>
<p>那么，当一个新的任务到达的时候，线程池中的线程是如何调度的呢？（别慌，讲这么一大段线程池的知识，是为了理解AsyncTask；Be Patient）</p>
<ol>
<li>如果线程池中线程的数目少于corePoolSize，就算线程池中有其他的没事做的核心线程，线程池还是会重新创建一个核心线程；直到核心线程数目到达corePoolSize（常驻线程就位）</li>
<li>如果线程池中线程的数目大于或者等于corePoolSize，但是工作队列workQueue没有满，那么新的任务会放在队列workQueue中，按照FIFO的原则依次等待执行；（当有核心线程处理完任务空闲出来后，会检查这个工作队列然后取出任务默默执行去）</li>
<li>如果线程池中线程数目大于等于corePoolSize，并且工作队列workQueue满了，但是总线程数目小于maximumPoolSize，那么直接创建一个线程处理被添加的任务。</li>
<li>如果工作队列满了，并且线程池中线程的数目到达了最大数目maximumPoolSize，那么就会用最后一个构造参数<code>handler</code>处理；**默认的处理方式是直接丢掉任务，然后抛出一个异常。</li>
</ol>
<p>总结起来，也即是说，当有新的任务要处理时，<strong>先看线程池中的线程数量是否大于 corePoolSize，再看缓冲队列 workQueue 是否满，最后看线程池中的线程数量是否大于 maximumPoolSize</strong>。另外，当线程池中的线程数量大于 corePoolSize 时，如果里面有线程的空闲时间超过了 keepAliveTime，就将其移除线程池，这样，可以动态地调整线程池中线程的数量。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/20161-18.jpg" alt="风景"></p>
<p>我们以API 22为例，看一看AsyncTask里面的线程池是以什么参数构造的；AsyncTask里面有“两个”线程池；一个<code>THREAD_POOL_EXECUTOR</code>一个<code>SERIAL_EXECUTOR</code>；之所以打引号，是因为其实<code>SERIAL_EXECUTOR</code>也使用<code>THREAD_POOL_EXECUTOR</code>实现的，只不过加了一个队列弄成了串行而已，那么这个<code>THREAD_POOL_EXECUTOR</code>是如何构造的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</span><br><span class="line">            = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</span><br><span class="line">                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</span><br></pre></td></tr></table></figure>
<p>可以看到，AsyncTask里面线程池是一个核心线程数为<code>CPU + 1</code>，最大线程数为<code>CPU * 2 + 1</code>，工作队列长度为<strong>128</strong>的线程池；并且没有传递<code>handler</code>参数，那么使用的就是默认的Handler（拒绝执行).</p>
<p>那么问题来了：</p>
<ol>
<li><p>如果任务过多，那么超过了工作队列以及线程数目的限制导致这个线程池发生阻塞，那么悲剧发生，默认的处理方式会直接抛出一个异常导致进程挂掉。假设你自己写一个异步图片加载的框架，然后用AsyncTask实现的话，当你快速滑动ListView的时候很容易发生这种异常；这也是为什么各大ImageLoader都是自己写线程池和Handlder的原因。</p>
</li>
<li><p>这个线程池是一个静态变量；那么在同一个进程之内，所有地方使用到的AsyncTask默认构造函数构造出来的AsyncTask都使用的是同一个线程池，如果App模块比较多并且不加控制的话，很容易满足第一条的崩溃条件；如果你不幸在不同的AsyncTask的doInBackgroud里面访问了共享资源，那么就会发生各种并发编程问题。</p>
</li>
<li><p>在AsyncTask全部执行完毕之后，进程中还是会常驻corePoolSize个线程；在Android 4.4 （API 19）以下，这个corePoolSize是hardcode的，数值是5；API 19改成了<code>cpu + 1</code>；也就是说，在Android 4.4以前；如果你执行了超过五个AsyncTask；然后啥也不干了，进程中还是会有5个AsyncTask线程；不信，你看：</p>
</li>
</ol>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1453101991064.png" width="277"></p>
<h3 id="Handler">Handler</h3><p>AsyncTask里面的handler很简单，如下（API 22代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalHandler sHandler = <span class="keyword">new</span> InternalHandler();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Looper.getMainLooper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里直接用的主线程的Looper；如果去看API 22以下的代码，会发现它没有这个构造函数，而是使用默认的；默认情况下，Handler会使用当前线程的Looper，如果你的AsyncTask是在子线程创建的，那么很不幸，你的<code>onPreExecute</code>和<code>onPostExecute</code>并非在UI线程执行，而是被Handler post到创建它的那个线程执行；如果你在这两个线程更新了UI，那么直接导致崩溃。这也是大家口口相传的<strong>AsyncTask必须在主线程创建</strong>的原因。</p>
<p>另外，AsyncTask里面的这个Handler是一个静态变量，也就是说它是在类加载的时候创建的；如果在你的APP进程里面，以前从来没有使用过AsyncTask，然后在子线程使用AsyncTask的相关变量，那么导致静态Handler初始化，如果在API 16以下，那么会出现上面同样的问题；这就是<strong>AsyncTask必须在主线程初始化</strong> 的原因。</p>
<p>事实上，在Android 4.1(API 16)以后，在APP主线程ActivityThread的main函数里面，直接调用了<code>AscynTask.init</code>函数确保这个类是在主线程初始化的；另外，init这个函数里面获取了<code>InternalHandler</code>的Looper，由于是在主线程执行的，因此，AsyncTask的Handler用的也是主线程的Looper。这个问题从而得到彻底的解决。</p>
<h2 id="AsyncTask是并行执行的吗？">AsyncTask是并行执行的吗？</h2><p>现在知道AsyncTask内部有一个线程池，那么派发给AsyncTask的任务是并行执行的吗？</p>
<p>答案是不确定。在Android 1.5刚引入的时候，AsyncTask的<code>execute</code>是串行执行的；到了Android 1.6直到Android 2.3.2，又被修改为并行执行了，这个执行任务的线程池就是<code>THREAD_POOL_EXECUTOR</code>，因此在一个进程内，所有的AsyncTask都是并行执行的；但是在Android 3.0以后，如果你使用<code>execute</code>函数直接执行AsyncTask，那么<strong>这些任务是串行执行的</strong>；（你说蛋疼不）源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>sDefaultExecutor</code>就是用来执行任务的线程池，那么它的值是什么呢？继续看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br></pre></td></tr></table></figure>
<p>因此结论就来了：<strong>Android 3.0以上，AsyncTask默认并不是并行执行的</strong>；</p>
<h3 id="为什么默认不并行执行？">为什么默认不并行执行？</h3><p>也许你不理解，为什么AsyncTask默认把它设计为串行执行的呢？</p>
<p>由于一个进程内所有的AsyncTask都是使用的同一个线程池执行任务；如果同时有几个AsyncTask一起并行执行的话，恰好AysncTask的使用者在<code>doInbackgroud</code>里面访问了相同的资源，但是自己没有处理同步问题；那么就有可能导致灾难性的后果！</p>
<p>由于开发者通常不会意识到需要对他们创建的所有的AsyncTask对象里面的<code>doInbackgroud</code>做同步处理，因此，API的设计者为了避免这种无意中访问并发资源的问题，干脆把这个API设置为默认所有串行执行的了。如果你明确知道自己需要并行处理任务，那么你需要使用<code>executeOnExecutor(Executor exec,Params... params)</code>这个函数来指定你用来执行任务的线程池，同时为自己的行为负责。（处理同步问题）</p>
<p>实际上《Effective Java》里面有一条原则说的就是这种情况：不要在同步块里面调用不可信的外来函数。这里明显违背了这个原则：AsyncTask这个类并不知道使用者会在<code>doInBackgroud</code>这个函数里面做什么，但是对它的行为做了某种假设。</p>
<h3 id="如何让AsyncTask并行执行？">如何让AsyncTask并行执行？</h3><p>正如上面所说，如果你确定自己做好了同步处理，或者你没有在不同的AsyncTask里面访问共享资源，需要AsyncTask能够并行处理任务的话，你可以用带有两个参数的<code>executeOnExecutor</code>执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AsyncTask&lt;Void, Void, Vo</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</span><br></pre></td></tr></table></figure>
<h2 id="更好的AsyncTask">更好的AsyncTask</h2><p>从上面的分析得知，AsyncTask有如下问题：</p>
<ol>
<li>默认的AsyncTask如果处理的任务过多，会导致程序直接崩溃；</li>
<li>AsyncTask类必须在主线程初始化，必须在主线程创建，不然在API 16以下很大概率崩溃。</li>
<li>如果你曾经使用过AsyncTask，以后不用了；在Android 4.4以下，进程内也默认有5个AsyncTask线程；在Android 4.4以上，默认有<code>CPU + 1</code>个线程。</li>
<li>Android 3.0以上的AsyncTask默认是串行执行任务的；如果要并行执行需要调用低版本没有的API，处理麻烦。</li>
</ol>
<p>因此我们对系统的AsyncTask做了一些修改，在不同Android版本提供一致的行为，并且提高了使用此类的安全性，主要改动如下：</p>
<ol>
<li>添加对于任务过多导致崩溃的异常保护；在这里进行必要的数据统计上报工作；如果出现这个问题，说明AsyncTask不适合这种场景了，需要考虑重构；</li>
<li>移植API 22对于Handler的处理；这样就算在线程创建异步任务，也不会有任何问题；</li>
<li>提供串行执行和并行执行的<code>execute</code>方法；默认串行执行，如果明确知道自己在干什么，可以使用<code>executeParallel</code>并行执行。</li>
<li>在<code>doInbackgroud</code>里面频繁崩溃的地方加上<code>try..catch</code>；自己处理数据上报工作。</li>
</ol>
<p>完整代码见gist，<a href="https://gist.github.com/tiann/8860bcc514f067ab4291" target="_blank" rel="external">BetterAsyncTask</a></p>
<p>原文地址：<a href="http://weishu.me/2016/01/18/dive-into-asynctask/">http://weishu.me/2016/01/18/dive-into-asynctask/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽说现在做网络请求有了Volley全家桶和OkHttp这样好用的库，但是在处理其他后台任务以及与UI交互上，还是需要用到AsyncTask。但是你真的了解AsyncTask吗？</p>
<p>AsyncTask的实现几经修改，因此在不同版本的Android系统上表现各异；我相信，任何一个用户量上千万的产品绝对不会在代码里面使用系统原生的AsynTask，因为它蛋疼的兼容性以及极高的崩溃率实在让人不敢恭维。本文将带你了解AsyncTask背后的原理，并给出一个久经考验的AsyncTask修改版。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binder学习指南]]></title>
    <link href="http://weishu.me/2016/01/12/binder-index-for-newer/"/>
    <id>http://weishu.me/2016/01/12/binder-index-for-newer/</id>
    <published>2016-01-12T13:26:09.000Z</published>
    <updated>2016-03-08T01:57:45.000Z</updated>
    <content type="html"><![CDATA[<p>毫不夸张地说，Binder是Android系统中最重要的特性之一；正如其名“粘合剂”所喻，它是系统间各个组件的桥梁，Android系统的开放式设计也很大程度上得益于这种及其方便的跨进程通信机制。</p>
<p>理解Binder对于理解整个Android系统有着非常重要的作用，Android系统的四大组件，AMS，PMS等系统服务无一不与Binder挂钩；如果对Binder不甚了解，那么就很难了解这些系统机制，从而仅仅浮游与表面，不懂Binder你都不好意思说自己会Android开发；要深入Android，Binder是必须迈出的一步。</p>
<p>现在网上有不少资料介绍Binder，个人觉得最好的两篇如下：</p>
<ol>
<li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Binder设计与实现</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external"> Android进程间通信（IPC）机制Binder简要介绍和学习计划</a>系列</li>
</ol>
<p>其中, 《Binder设计与实现》以一种宏观的角度解释了Android系统中的Binder机制，文章如行云流水；如果对于Binder有一定的了解再来看着篇文章，有一种打通任督二脉的感觉；每看一次理解就深一层。老罗的系列文章则从系统源码角度深入分析了Binder的实现细节；具有很大的参考意义；每当对于Binder细节有疑惑，看一看他的书就迎刃而解。</p>
<p>但是遗憾的是，Binder机制终究不是三言两语就能解释清楚的，一上来就扒出源码很可能深陷细节无法自拔，老罗的文章那不是一般的长，如果看不懂强行看很容易睡着；勉强看完还是云里雾里；相反如果直接大谈特谈Binder的设计，那么完全就是不知所云；因此上述两篇文章对于初学者并不友好，本文不会深入源码细节，也不会对于Binder的设计高谈阔论；重点如下：<br><a id="more"></a></p>
<ol>
<li>一些Linux的预备知识</li>
<li>Binder到底是什么？</li>
<li>Binder机制是如何跨进程的？</li>
<li>一次Binder通信的基本流程是什么样？</li>
<li>深入理解Java层的Binder</li>
</ol>
<p>读完本文，你应该对于Java层的AIDL了如指掌，对于Binder也会有一个大体上的认识；再深入学习就得靠自己了，本人推荐的Binder学习路径如下：</p>
<ol>
<li>先学会熟练使用AIDL进行跨进程通信（简单来说就是远程Service）</li>
<li>看完本文</li>
<li>看Android文档，<code>Parcel, IBinder, Binder</code>等涉及到跨进程通信的类</li>
<li>不依赖AIDL工具，手写远程Service完成跨进程通信</li>
<li>看《Binder设计与实现》</li>
<li>看老罗的博客或者书（书结构更清晰）</li>
<li>再看《Binder设计与实现》</li>
<li>学习Linux系统相关知识；自己看源码。</li>
</ol>
<h2 id="背景知识">背景知识</h2><p>为了理解Binder我们先澄清一些概念。为什么需要跨进程通信（IPC），怎么做到跨进程通信？为什么是Binder？</p>
<p>由于Android系统基于Linux内核，因此有必要了解相关知识。</p>
<h3 id="进程隔离">进程隔离</h3><blockquote>
<p>进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。</p>
</blockquote>
<p>以上来自维基百科；操作系统的不同进程之间，数据不共享；对于每个进程来说，它都天真地以为自己独享了整个系统，完全不知道其他进程的存在；(有关虚拟地址，请自行查阅）因此一个进程需要与另外一个进程通信，需要某种系统机制才能完成。</p>
<h3 id="用户空间/内核空间">用户空间/内核空间</h3><p>详细解释可以参考<a href="http://www.linfo.org/kernel_space.html" target="_blank" rel="external">Kernel Space Definition</a>；简单理解如下：</p>
<p>Linux Kernel是操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</p>
<p>对于Kernel这么一个高安全级别的东西，显然是不容许其它的应用程序随便调用或访问的，所以需要对Kernel提供一定的保护机制，这个保护机制用来告诉那些应用程序，你只可以访问某些许可的资源，不许可的资源是拒绝被访问的，于是就把Kernel和上层的应用程序抽像的隔离开，分别称之为Kernel Space和User Space。</p>
<h3 id="系统调用/内核态/用户态">系统调用/内核态/用户态</h3><p>虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？</p>
<blockquote>
<p>Kernel space can be accessed by user processes only through the use of system calls. </p>
</blockquote>
<p>用户空间访问内核空间的唯一方式就是<strong>系统调用</strong>；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。</p>
<h3 id="内核模块/驱动">内核模块/驱动</h3><p>通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的Linux通信机制，比如Socket，管道等都是内核支持的；但是Binder并不是Linux内核的一部分，它是怎么做到访问内核空间的呢？Linux的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。</p>
<p>在Android系统中，这个运行在内核空间的，负责各个用户进程通过Binder通信的内核模块叫做<strong>Binder驱动</strong>; </p>
<blockquote>
<p>驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作；</p>
</blockquote>
<p>驱动就是操作硬件的接口，为了支持Binder通信过程，Binder使用了一种“硬件”，因此这个模块被称之为驱动。</p>
<p>好了，说了这么多枯燥的概念，看张美图缓解一下。</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/20161-8.jpg" alt=""></p>
<h3 id="为什么使用Binder？">为什么使用Binder？</h3><p>Android使用的Linux内核拥有着非常多的跨进程通信机制，比如管道，System V，Socket等；为什么还需要单独搞一个Binder出来呢？主要有两点，性能和安全。在移动设备上，广泛地使用跨进程通信肯定对通信机制本身提出了严格的要求；Binder相对出传统的Socket方式，更加高效；另外，传统的进程通信方式对于通信双方的身份并没有做出严格的验证，只有在上层协议上进行架设；比如Socket通信ip地址是客户端手动填入的，都可以进行伪造；而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。这个也是Android权限模型的基础。</p>
<h2 id="Binder通信模型">Binder通信模型</h2><p>对于跨进程通信的双方，我们姑且叫做Server进程（简称Server），Client进程（简称Client）；由于进程隔离的存在，它们之间没办法通过简单的方式进行通信，那么Binder机制是如何进行的呢？</p>
<p>回想一下日常生活中我们通信的过程：假设A和B要进行通信，通信的媒介是打电话（A是Client，B是Server）；A要给B打电话，必须知道B的号码，这个号码怎么获取呢？<strong>通信录</strong>. </p>
<p>这个通信录就是一张表；内容大致是：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B -&gt; 12345676</span><br><span class="line">C -&gt; 12334354</span><br></pre></td></tr></table></figure>
<p>先查阅通信录，拿到B的号码；才能进行通信；否则，怎么知道应该拨什么号码？回想一下古老的电话机，如果A要给B打电话，必须先连接通话中心，说明给我接通B的电话；这时候通话中心帮他呼叫B；连接建立，就完成了通信。</p>
<p>另外，光有电话和通信录是不可能完成通信的，没有基站支持；信息根本无法传达。</p>
<p>我们看到，一次电话通信的过程除了通信的双方还有两个隐藏角色：通信录和基站。Binder通信机制也是一样：两个运行在用户空间的进程要完成通信，必须借助内核的帮助，这个运行在内核里面的程序叫做<strong>Binder驱动</strong>，它的功能类似于基站；通信录呢，就是一个叫做<strong>ServiceManager</strong>的东西（简称SM）</p>
<p>OK，Binder的通信模型就是这么简单，如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/binder-model.png" alt=""></p>
<p>整个通信步骤如下：</p>
<ol>
<li>SM建立(建立通信录)；首先有一个进程向驱动提出申请为SM；驱动同意之后，SM进程负责管理Service（注意这里是Service而不是Server，因为如果通信过程反过来的话，那么原来的客户端Client也会成为服务端Server）不过这时候通信录还是空的，一个号码都没有。</li>
<li>各个Server向SM注册(完善通信录)；每个Server端进程启动之后，向SM报告，我是zhangsan, 要找我请返回0x1234(这个地址没有实际意义，类比)；其他Server进程依次如此；这样SM就建立了一张表，对应着各个Server的名字和地址；就好比B与A见面了，说存个我的号码吧，以后找我拨打10086；</li>
<li>Client想要与Server通信，首先询问SM；请告诉我如何联系zhangsan，SM收到后给他一个号码0x1234；Client收到之后，开心滴用这个号码拨通了Server的电话，于是就开始通信了。</li>
</ol>
<p>那么Binder驱动干什么去了呢？这里Client与SM的通信，以及Client与Server的通信，都会经过驱动，驱动在背后默默无闻，但是做着最重要的工作。驱动是整个通信过程的核心，因此完成跨进程通信的秘密全部隐藏在驱动里面；这个我们稍后讨论。</p>
<p>OK，上面就是整个Binder通信的基本模型；做了一个简单的类比，当然也有一些不恰当的地方，(比如通信录现实中每个人都有一个，但是SM整个系统只有一个；基站也有很多个，但是驱动只有一个）；但是整体上就是这样的；我们看到其实整个通信模型非常简单。</p>
<h2 id="Binder机制跨进程原理">Binder机制跨进程原理</h2><p>上文给出了Binder的通信模型，指出了通信过程的四个角色: Client, Server, SM, driver; 但是我们仍然不清楚<strong>Client到底是如何与Server完成通信的</strong>。</p>
<p>两个运行在用户空间的进程A和进程B如何完成通信呢？内核可以访问A和B的所有数据；所以，最简单的方式是通过内核做中转；假设进程A要给进程B发送数据，那么就先把A的数据copy到内核空间，然后把内核空间对应的数据copy到B就完成了；用户空间要操作内核空间，需要通过系统调用；刚好，这里就有两个系统调用：<code>copy_from_user</code>, <code>copy_to_user</code>。</p>
<p>但是，Binder机制并不是这么干的。讲这么一段，是说明进程间通信并不是什么神秘的东西。那么，Binder机制是如何实现跨进程通信的呢？</p>
<p>Binder驱动为我们做了一切。</p>
<p>假设Client进程想要调用Server进程的<code>object</code>对象的一个方法<code>add</code>;对于这个跨进程通信过程，我们来看看Binder机制是如何做的。 （通信是一个广泛的概念，只要一个进程能调用另外一个进程里面某对象的方法，那么具体要完成什么通信内容就很容易了。）</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/2016binder-procedure.png" alt="Alt text"></p>
<p>首先，Server进程要向SM注册；告诉自己是谁，自己有什么能力；在这个场景就是Server告诉SM，它叫<code>zhangsan</code>，它有一个<code>object</code>对象，可以执行<code>add</code> 操作；于是SM建立了一张表：<code>zhangsan</code>这个名字对应进程Server; </p>
<p>然后Client向SM查询：我需要联系一个名字叫做<code>zhangsan</code>的进程里面的<code>object</code>对象；这时候关键来了：进程之间通信的数据都会经过运行在内核空间里面的驱动，驱动在数据流过的时候做了一点手脚，它并不会给Client进程返回一个真正的<code>object</code>对象，而是返回一个看起来跟<code>object</code>一模一样的代理对象<code>objectProxy</code>，这个<code>objectProxy</code>也有一个<code>add</code>方法，但是这个<code>add</code>方法没有Server进程里面<code>object</code>对象的<code>add</code>方法那个能力；<code>objectProxy</code>的<code>add</code>只是一个傀儡，它唯一做的事情就是把参数包装然后交给驱动。(这里我们简化了SM的流程，见下文)</p>
<p>但是Client进程并不知道驱动返回给它的对象动过手脚，毕竟伪装的太像了，如假包换。Client开开心心地拿着<code>objectProxy</code>对象然后调用<code>add</code>方法；我们说过，这个<code>add</code>什么也不做，直接把参数做一些包装然后直接转发给Binder驱动。</p>
<p>驱动收到这个消息，发现是这个<code>objectProxy</code>；一查表就明白了：我之前用<code>objectProxy</code>替换了<code>object</code>发送给Client了，它真正应该要访问的是<code>object</code>对象的<code>add</code>方法；于是Binder驱动通知Server进程，<em>调用你的object对象的<code>add</code>方法，然后把结果发给我</em>，Sever进程收到这个消息，照做之后将结果返回驱动，驱动然后把结果返回给<code>Client</code>进程；于是整个过程就完成了。</p>
<p>由于驱动返回的<code>objectProxy</code>与Server进程里面原始的<code>object</code>是如此相似，给人感觉好像是<strong>直接把Server进程里面的对象object传递到了Client进程</strong>；因此，我们可以说<strong>Binder对象是可以进行跨进程传递的对象</strong></p>
<p>但事实上我们知道，Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用Binder驱动最终让真身完成操作。</p>
<p>理解这一点非常重要；务必仔细体会。另外，Android系统实现这种机制使用的是<em>代理模式</em>, 对于Binder的访问，如果是在同一个进程（不需要跨进程），那么直接返回原始的Binder实体；如果在不同进程，那么就给他一个代理对象（影子）；我们在系统源码以及AIDL的生成代码里面可以看到很多这种实现。</p>
<p>另外我们为了简化整个流程，隐藏了SM这一部分驱动进行的操作；实际上，由于SM与Server通常不在一个进程，Server进程向SM注册的过程也是跨进程通信，驱动也会对这个过程进行暗箱操作：SM中存在的Server端的对象实际上也是代理对象，后面Client向SM查询的时候，驱动会给Client返回另外一个代理对象。Sever进程的本地对象仅有一个，其他进程所拥有的全部都是它的代理。</p>
<p>一句话总结就是：<strong>Client进程只不过是持有了Server端的代理；代理对象协助驱动完成了跨进程通信。</strong></p>
<p>OK，该休息一下了。</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/20161-12.jpg" alt=""></p>
<h2 id="Binder到底是什么？">Binder到底是什么？</h2><p>我们经常提到Binder，那么Binder到底是什么呢？</p>
<p>Binder的设计采用了面向对象的思想，在Binder通信模型的四个角色里面；他们的代表都是“Binder”，这样，对于Binder通信的使用者而言，Server里面的Binder和Client里面的Binder没有什么不同，一个Binder对象就代表了所有，它不用关心实现的细节，甚至不用关心驱动以及SM的存在；这就是抽象。</p>
<ul>
<li>通常意义下，Binder指的是一种通信机制；我们说AIDL使用Binder进行通信，指的就是<strong>Binder这种IPC机制</strong>。</li>
<li>对于Server进程来说，Binder指的是<strong>Binder本地对象</strong></li>
<li>对于Client来说，Binder指的是<strong>Binder代理对象</strong>，它只是<strong>Binder本地对象</strong>的一个远程代理；对这个Binder代理对象的操作，会通过驱动最终转发到Binder本地对象上去完成；对于一个拥有Binder对象的使用者而言，它无须关心这是一个Binder代理对象还是Binder本地对象；对于代理对象的操作和对本地对象的操作对它来说没有区别。</li>
<li>对于传输过程而言，Binder是可以进行跨进程传递的对象；Binder驱动会对具有跨进程传递能力的对象做特殊处理：自动完成代理对象和本地对象的转换。</li>
</ul>
<blockquote>
<p>面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体（本地对象）位于一个进程中，而它的引用（代理对象）却遍布于系统的各个进程之中。最诱人的是，这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。</p>
</blockquote>
<h3 id="驱动里面的Binder">驱动里面的Binder</h3><p>我们现在知道，Server进程里面的Binder对象指的是Binder本地对象，Client里面的对象值得是Binder代理对象；在Binder对象进行跨进程传递的时候，Binder驱动会自动完成这两种类型的转换；因此Binder驱动必然保存了每一个跨越进程的Binder对象的相关信息；在驱动中，Binder本地对象的代表是一个叫做<code>binder_node</code>的数据结构，Binder代理对象是用<code>binder_ref</code>代表的；有的地方把Binder本地对象直接称作Binder实体，把Binder代理对象直接称作Binder引用（句柄），其实指的是Binder对象在驱动里面的表现形式；读者明白意思即可。</p>
<p>OK，现在大致了解Binder的通信模型，也了解了Binder这个对象在通信过程中各个组件里面到底表示的是什么。</p>
<h2 id="深入理解Java层的Binder">深入理解Java层的Binder</h2><h3 id="IBinder/IInterface/Binder/BinderProxy/Stub">IBinder/IInterface/Binder/BinderProxy/Stub</h3><p>我们使用AIDL接口的时候，经常会接触到这些类，那么这每个类代表的是什么呢？</p>
<ul>
<li>IBinder是一个接口，它代表了<strong>一种跨进程传输的能力</strong>；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。</li>
<li>IBinder负责数据传输，那么client与server端的调用契约（这里不用接口避免混淆）呢？这里的IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。</li>
<li>Java层的Binder类，代表的其实就是<strong>Binder本地对象</strong>。BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。</li>
<li>在使用AIDL的时候，编译工具会给我们生成一个Stub的静态内部类；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。</li>
</ul>
<h3 id="AIDL过程分析">AIDL过程分析</h3><p>现在我们通过一个AIDL的使用，分析一下整个通信过程中，各个角色到底做了什么，AIDL到底是如何完成通信的。（如果你连AIDL都不熟悉，请先查阅官方文档）</p>
<p>首先定一个一个简单的aidl接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ICompute.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.test.app;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICompute</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用编译工具编译之后，可以得到对应的ICompute.java类，看看系统给我们生成的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICompute</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Local-side IPC implementation stub class.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">test</span>.<span class="title">app</span>.<span class="title">ICompute</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.example.test.app.ICompute"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Construct the stub at attach it to the interface.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Cast an IBinder object into an com.example.test.app.ICompute interface,</span><br><span class="line">         * generating a proxy if needed.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.example.test.app.<span class="function">ICompute <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.test.app.ICompute))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.example.test.app.ICompute) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.example.test.app.ICompute.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">int</span> _arg0;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    <span class="keyword">int</span> _arg1;</span><br><span class="line">                    _arg1 = data.readInt();</span><br><span class="line">                    <span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeInt(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">test</span>.<span class="title">app</span>.<span class="title">ICompute</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Demonstrates some basic types that you can use as parameters</span><br><span class="line">             * and return values in AIDL.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">int</span> _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeInt(a);</span><br><span class="line">                    _data.writeInt(b);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.readInt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统帮我们生成了这个文件之后，我们只需要继承ICompute.Stub这个抽象类，实现它的方法，然后在Service 的onBind方法里面返回就实现了AIDL。这个Stub类非常重要，具体看看它做了什么。</p>
<p>Stub类继承自Binder，意味着这个Stub其实自己是一个Binder本地对象，然后实现了ICompute接口，ICompute本身是一个IInterface，因此他携带某种客户端需要的能力（这里是方法<code>add</code>)。此类有一个内部类Proxy，也就是Binder代理对象；</p>
<p>然后看看<code>asInterface</code>方法，我们在bind一个Service之后，在onServiceConnecttion的回调里面，就是通过这个方法拿到一个远程的service的，这个方法做了什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Cast an IBinder object into an com.example.test.app.ICompute interface,</span><br><span class="line"> * generating a proxy if needed.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.example.test.app.<span class="function">ICompute <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.test.app.ICompute))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.example.test.app.ICompute) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.example.test.app.ICompute.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看函数的参数<code>IBinder</code>类型的obj，这个对象是驱动给我们的，如果是Binder本地对象，那么它就是Binder类型，如果是Binder代理对象，那就是<code>BinderProxy</code>类型；然后，正如上面自动生成的文档所说，它会试着查找Binder本地对象，如果找到，说明Client和Server都在同一个进程，这个参数直接就是本地对象，直接强制类型转换然后返回，如果找不到，说明是远程对象（处于另外一个进程）那么就需要创建一个Binde代理对象，让这个Binder代理实现对于远程对象的访问。一般来说，如果是与一个远程Service对象进行通信，那么这里返回的一定是一个Binder代理对象，这个IBinder参数的实际上是BinderProxy;</p>
<p>再看看我们对于aidl的<code>add</code> 方法的实现；在Stub类里面，<code>add</code>是一个抽象方法，我们需要继承这个类并实现它；如果Client和Server在同一个进程，那么直接就是调用这个方法；那么，如果是远程调用，这中间发生了什么呢？Client是如何调用到Server的方法的？</p>
<p>我们知道，对于远程方法的调用，是通过Binder代理完成的，在这个例子里面就是<code>Proxy</code>类；<code>Proxy</code>对于<code>add</code>方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">int</span> _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeInt(a);</span><br><span class="line">        _data.writeInt(b);</span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.readInt();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它首先用<code>Parcel</code>把数据序列化了，然后调用了<code>transact</code>方法；这个<code>transact</code>到底做了什么呢？这个<code>Proxy</code>类在<code>asInterface</code>方法里面被创建，前面提到过，如果是Binder代理那么说明驱动返回的IBinder实际是<code>BinderProxy</code>, 因此我们的<code>Proxy</code>类里面的<code>mRemote</code>实际类型应该是<code>BinderProxy</code>；我们看看<code>BinderProxy</code>的<code>transact</code>方法：(Binder.java的内部类)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span><br><span class="line">            <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个本地方法；它的实现在native层，具体来说在frameworks/base/core/jni/android_util_Binder.cpp文件，里面进行了一系列的函数调用，调用链实在太长这里就不给出了；要知道的是它最终调用到了<code>talkWithDriver</code>函数；看这个函数的名字就知道，通信过程要交给驱动完成了；这个函数最后通过<code>ioctl</code>系统调用，Client进程陷入内核态，Client调用<code>add</code>方法的线程挂起等待返回；驱动完成一系列的操作之后唤醒Server进程，调用了Server进程本地对象的<code>onTransact</code>函数（实际上由Server端线程池完成）。我们再看Binder本地对象的<code>onTransact</code>方法（这里就是<code>Stub</code>类里面的此方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            reply.writeString(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">int</span> _arg0;</span><br><span class="line">            _arg0 = data.readInt();</span><br><span class="line">            <span class="keyword">int</span> _arg1;</span><br><span class="line">            _arg1 = data.readInt();</span><br><span class="line">            <span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            reply.writeInt(_result);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Server进程里面，<code>onTransact</code>根据调用号（每个AIDL函数都有一个编号，在跨进程的时候，不会传递函数，而是传递编号指明调用哪个函数）调用相关函数；在这个例子里面，调用了Binder本地对象的<code>add</code>方法；这个方法将结果返回给驱动，驱动唤醒挂起的Client进程里面的线程并将结果返回。于是一次跨进程调用就完成了。</p>
<p>至此，你应该对AIDL这种通信方式里面的各个类以及各个角色有了一定的了解；它总是那么一种固定的模式：一个需要跨进程传递的对象一定继承自IBinder，如果是Binder本地对象，那么一定继承Binder实现IInterface，如果是代理对象，那么就实现了IInterface并持有了IBinder引用；</p>
<p>Proxy与Stub不一样，虽然他们都既是Binder又是IInterface，不同的是Stub采用的是继承（is 关系），Proxy采用的是组合（has 关系）。他们均实现了所有的IInterface函数，不同的是，Stub又使用策略模式调用的是虚函数（待子类实现），而Proxy则使用组合模式。为什么Stub采用继承而Proxy采用组合？事实上，Stub本身is一个IBinder（Binder），它本身就是一个能跨越进程边界传输的对象，所以它得继承IBinder实现transact这个函数从而得到跨越进程的能力（这个能力由驱动赋予）。Proxy类使用组合，是因为他不关心自己是什么，它也不需要跨越进程传输，它只需要拥有这个能力即可，要拥有这个能力，只需要保留一个对IBinder的引用。如果把这个过程做一个类比，在封建社会，Stub好比皇帝，可以号令天下，他生而具有这个权利（不要说宣扬封建迷信。。）如果一个人也想号令天下，可以，“挟天子以令诸侯”。为什么不自己去当皇帝，其一，一般情况没必要，当了皇帝其实限制也蛮多的是不是？我现在既能掌管天下，又能不受约束（Java单继承）；其二，名不正言不顺啊，我本来特么就不是（Binder），你非要我是说不过去，搞不好还会造反。最后呢，如果想当皇帝也可以，那就是asBinder了。在Stub类里面，asBinder返回this，在Proxy里面返回的是持有的组合类IBinder的引用。</p>
<p>再去翻阅系统的ActivityManagerServer的源码，就知道哪一个类是什么角色了：IActivityManager是一个IInterface，它代表远程Service具有什么能力，ActivityManagerNative指的是Binder本地对象（类似AIDL工具生成的Stub类），这个类是抽象类，它的实现是<code>ActivityManagerService</code>；因此对于AMS的最终操作都会进入<code>ActivityManagerService</code>这个真正实现；同时如果仔细观察，ActivityManagerNative.java里面有一个非公开类ActivityManagerProxy, 它代表的就是Binder代理对象；是不是跟AIDL模型一模一样呢？那么<code>ActivityManager</code>是什么？他不过是一个管理类而已，可以看到真正的操作都是转发给<code>ActivityManagerNative</code>进而交给他的实现<code>ActivityManagerService</code> 完成的。</p>
<p>OK，本文就讲到这里了，要深入理解Binder，需要自己下功夫；那些native层以及驱动里面的调用过程，用文章写出来根本没有意义，需要自己去跟踪；接下来你可以：</p>
<ol>
<li>看Android文档，<code>Parcel, IBinder, Binder</code>等涉及到跨进程通信的类；</li>
<li>不依赖AIDL工具，手写远程Service完成跨进程通信</li>
<li>看<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">《Binder设计与实现》</a></li>
<li>看老罗的博客或者书（书结构更清晰）</li>
<li>再看<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">《Binder设计与实现》</a></li>
<li>学习Linux系统相关知识；自己看源码。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>毫不夸张地说，Binder是Android系统中最重要的特性之一；正如其名“粘合剂”所喻，它是系统间各个组件的桥梁，Android系统的开放式设计也很大程度上得益于这种及其方便的跨进程通信机制。</p>
<p>理解Binder对于理解整个Android系统有着非常重要的作用，Android系统的四大组件，AMS，PMS等系统服务无一不与Binder挂钩；如果对Binder不甚了解，那么就很难了解这些系统机制，从而仅仅浮游与表面，不懂Binder你都不好意思说自己会Android开发；要深入Android，Binder是必须迈出的一步。</p>
<p>现在网上有不少资料介绍Binder，个人觉得最好的两篇如下：</p>
<ol>
<li><a href="http://blog.csdn.net/universus/article/details/6211589">Binder设计与实现</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6618363"> Android进程间通信（IPC）机制Binder简要介绍和学习计划</a>系列</li>
</ol>
<p>其中, 《Binder设计与实现》以一种宏观的角度解释了Android系统中的Binder机制，文章如行云流水；如果对于Binder有一定的了解再来看着篇文章，有一种打通任督二脉的感觉；每看一次理解就深一层。老罗的系列文章则从系统源码角度深入分析了Binder的实现细节；具有很大的参考意义；每当对于Binder细节有疑惑，看一看他的书就迎刃而解。</p>
<p>但是遗憾的是，Binder机制终究不是三言两语就能解释清楚的，一上来就扒出源码很可能深陷细节无法自拔，老罗的文章那不是一般的长，如果看不懂强行看很容易睡着；勉强看完还是云里雾里；相反如果直接大谈特谈Binder的设计，那么完全就是不知所云；因此上述两篇文章对于初学者并不友好，本文不会深入源码细节，也不会对于Binder的设计高谈阔论；重点如下：<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="binder" scheme="http://weishu.me/tags/binder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ASCII Art：使用纯文本流程图]]></title>
    <link href="http://weishu.me/2016/01/03/use-pure-ascii-present-graph/"/>
    <id>http://weishu.me/2016/01/03/use-pure-ascii-present-graph/</id>
    <published>2016-01-03T15:17:24.000Z</published>
    <updated>2016-01-05T01:54:35.000Z</updated>
    <content type="html"><![CDATA[<p>我们使用纯文本写代码，有了Markdown又可以使用纯文本写文档，那么对于更直观的信息表达方式——图片，能不能使用纯文本描述呢？</p>
<p>另外，你是否见到过这样的注释：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451834573842.png" alt="ASCII art图像" width="463"></p>
<p>没错，这种逼格极高的ASCII图片注释方式就是我们要讨论的话题。</p>
<a id="more"></a>
<p>使用纯ASCII文本表达图像的方式有什么好处呢？大致有下面几点：</p>
<ol>
<li>装B；没啥好解释的。</li>
<li>可以在代码注释里面用图像充分表达信息；没图say个jb？一图胜千言。迄今为止好像没有什么IDE可以支持直接在代码编辑里面放图片的，在另外一些纯文本的场合也是如此。比如RFC的文档都是txt，里面很多图都是纯ASCII表达。</li>
<li>你以为仅仅是一个纯文本图片这么简单？它可以转换为普通的诸如png格式的真正的图片，还支持SVG矢量图！</li>
</ol>
<p>好了，也许有人说markdown的一些拓展格式不也是支持流程图的吗？它使用的<code>flowchart.js</code> 确实可以很好滴完成一些漂亮的流程图，还有 <code>plantuml</code>和图片DSL语言 <code>dot</code>及它的软件包<code>graphviz</code>等；没错，它们可以使用纯文本表达图像，但它们不是真正的图像；无法嵌入文本代码中，只有在经过渲染之后才能直观地看到图。</p>
<p>又有人说，我知道 <code>asciiflow</code> 这个网站，可以绘制这种流程图，完美解决我的需求。但是，你在手动绘制的时候，是不是要考虑图像的各种细节？大小，放置位置，对齐方式？我们关注的应该是图像本身，而不是如何绘制这个图。markdown为什么这么易用？就是因为我们不用关心文档的格式，不用考虑什么字体，几级标题等等繁琐的格式，可以专注于创作本身。</p>
<p>姑且你已经认同了这种使用ASCII表达图像方式的优点，但是…这种图难道要使用手一个个字符地敲出来吗？？如果真的这么做，简直不要太麻烦！光在前面添加一个空格，后面的所有行都需要改；我们需要一个自动化工具。</p>
<h2 id="Graph::Easy">Graph::Easy</h2><p><strong>Graph::Easy</strong> 就是今天要介绍的主角；它是 <code>perl</code>的一个软件包，可以使用<code>perl</code>代码直接描述图像；当然，我们肯定不会为了画个图专门去学习<code>perl</code>;</p>
<p>这个软件包的强大之处在于: 它定义了一套非常简单易用的专门用来描述图像的DSL（领域专用语言）,我们可以像写代码一样表达我们需要描述的图像（放心，这个语法非常简单）；不用关心图像里面如何布局；这种语言经过处理可以得到ASCII图像，直接放在代码注释中；如果需要还可以转换成png或者矢量图等格式。</p>
<p>先举个简单的例子，感受一下:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ Bonn ] --&gt; [ Koblenz ] --&gt; [ Frankfurt ] --&gt; [ Dresden ]</span></span><br><span class="line"></span><br><span class="line">[ Koblenz ] --&gt; [ Trier ] &#123; origin: Koblenz; offset: 2, 2; &#125;</span><br><span class="line"><span class="code">  --&gt; [ Frankfurt ]</span></span><br></pre></td></tr></table></figure>
<p>这种DSL经过渲染之后得到的ASCII图是这样的：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+------+</span>     <span class="code">+---------+</span>                   <span class="code">+-----------+</span>     <span class="code">+---------+</span></span><br><span class="line">| Bonn | --&gt; | Koblenz | ----------------&gt; | Frankfurt | --&gt; | Dresden |</span><br><span class="line"><span class="code">+------+</span>     <span class="code">+---------+</span>                   <span class="code">+-----------+</span>     <span class="code">+---------+</span></span><br><span class="line"><span class="code">               |                             ^</span></span><br><span class="line"><span class="code">               |                             |</span></span><br><span class="line"><span class="code">               |                             |</span></span><br><span class="line"><span class="code">               |             +-------+       |</span></span><br><span class="line"><span class="code">               +-----------&gt; | Trier | ------+</span></span><br><span class="line"><span class="code">                             +-------+</span></span><br></pre></td></tr></table></figure>
<h2 id="安装">安装</h2><ol>
<li>首先需要安装 <code>graphviz</code> 软件包，可以在<a href="http://www.graphviz.org/" target="_blank" rel="external">graphviz官网</a>下载；mac用户可以 <code>brew install graphviz</code>；其他linux发行版参考<a href="http://www.graphviz.org/" target="_blank" rel="external">官网</a>。</li>
<li>安装<code>perl</code>；mac和linux用户可以略过；一般系统自带，没有的话和windows一起去<a href="http://www.perl.org" target="_blank" rel="external">perl官网</a>查询如何安装; 据说windows下有傻瓜包<code>activeperl</code>；请自行搜索。</li>
<li>安装<code>cpan</code>; 这个是<code>perl</code>的软件包管理，类似<code>npm</code>, <code>pip</code>, <code>apt-get</code>; mac下直接在命令行输入 <code>cpan</code> 命令，一路next即可。其他系统参考<a href="http://www.cpan.org/modules/INSTALL.html" target="_blank" rel="external">cpan官网</a></li>
<li>安装<code>Graph::Easy</code> ;这一步就很容易了；在命令行输入<code>cpan</code>进入cpan shell；然后输入 <code>install Graph::Easy</code>即可。</li>
</ol>
<h2 id="使用">使用</h2><p>使用分为两步</p>
<ol>
<li>使用Graph::Easy DSL的语法描述图像，存为文本文件，比如 <code>simple.txt</code></li>
<li>使用 <code>graph-easy</code> 命令处理这个文件： <code>graph-easy simple.txt</code></li>
</ol>
<p>最简单的使用方式就是这样；当然，<code>Graph::Easy</code> 不仅仅支持自己的DSL语法，它还支持诸如<code>dot</code> 这种较为通用的图像描述语言；可以直接读取<code>dot</code> 格式的输入，产生其他的诸如 ascii，png，svg格式的图像。</p>
<h3 id="语法">语法</h3><h4 id="注释">注释</h4><p>注释用 <code>#</code> 表达；注意 <code>#</code> 之后，一定需要加空格；由于历史原因；Graph::Easy的颜色也使用了 <code>#</code> ，不加空格会解析失败。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##############################################################</span><br><span class="line"># 合法的注释</span><br><span class="line"></span><br><span class="line">##############################################################</span><br><span class="line">#有问题的注释</span><br><span class="line"></span><br><span class="line">node &#123; label: \#5; &#125;	  # 注意转义！</span><br><span class="line">edge &#123; color: #aabbcc; &#125;  # 可以使用颜色值</span><br></pre></td></tr></table></figure></p>
<h4 id="空格">空格</h4><p>空格通常没有什么影响，多个空字符会合并成一个，换行的空字符会忽略；下面的表述是等价的。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[A]-&gt;[B][C]-&gt;[D]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ A ] -&gt; [ B ]</span></span><br><span class="line"><span class="attribute">[ C ] -&gt; [ D ]</span></span><br></pre></td></tr></table></figure>
<h4 id="节点(Node)">节点(Node)</h4><p>用中括号括起来的就是节点，我们简单可以理解为一些形状；比如流程图里面的矩形，圆等；</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ Single node ]</span></span><br><span class="line"><span class="attribute">[ Node A ] --&gt; [ Node B ]</span></span><br></pre></td></tr></table></figure>
<p>可以用逗号分割多个节点：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ A ], [ B ], [ C ] --&gt; [ D ]</span></span><br></pre></td></tr></table></figure>
<p>上面的代码图像如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+---+</span>     <span class="code">+---+</span>     <span class="code">+---+</span></span><br><span class="line">| A | --&gt; | D | &lt;-- | C |</span><br><span class="line"><span class="code">+---+</span>     <span class="code">+---+</span>     <span class="code">+---+</span></span><br><span class="line"><span class="code">            ^</span></span><br><span class="line"><span class="code">            |</span></span><br><span class="line"><span class="code">            |</span></span><br><span class="line"><span class="code">          +---+</span></span><br><span class="line"><span class="code">          | B |</span></span><br><span class="line"><span class="code">          +---+</span></span><br></pre></td></tr></table></figure>
<h4 id="边(Edges)">边(Edges)</h4><p>将节点连接起来的就是边；Graph::Easy 的DSL支持这几种风格的边：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt;              实线</span><br><span class="line">=&gt;              双实线</span><br><span class="line">.&gt;              点线</span><br><span class="line">~&gt;              波浪线</span><br><span class="line"><span class="bullet">- </span>&gt;             虚线</span><br><span class="line">.-&gt;             点虚线</span><br><span class="line">..-&gt;            dot-dot-dash</span><br><span class="line"><span class="header">= &gt;             double-dash</span></span><br></pre></td></tr></table></figure></p>
<p>可以给边加标签，如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ client ] - request -&gt; [ server ]</span></span><br><span class="line"><span class="code">```</span> </span><br><span class="line">结果如下：</span><br><span class="line"></span><br><span class="line"><span class="code">```</span>asciidoc</span><br><span class="line"><span class="code">+--------+</span>  request   <span class="code">+--------+</span></span><br><span class="line">| client | ---------&gt; | server |</span><br><span class="line"><span class="code">+--------+</span>            <span class="code">+--------+</span></span><br></pre></td></tr></table></figure>
<h4 id="属性(Attributes)">属性(Attributes)</h4><p>可以给节点和边添加属性；比如标签，方向等；使用大括号 <code>{}</code>表示，里面的内容类似css，<code>attribute: value</code>。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ "Monitor Size" ] --&gt; &#123; label: 21"; &#125; [ Big ] &#123; label: "Huge"; &#125;</span><br></pre></td></tr></table></figure>
<p>上面的DSL输入如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------------+</span>  21"   <span class="code">+------+</span></span><br><span class="line">| "Monitor Size" | -----&gt; | Huge |</span><br><span class="line"><span class="code">+----------------+</span>        <span class="code">+------+</span></span><br></pre></td></tr></table></figure></p>
<p>Graph::Easy提供了非常多的属性; 另外，<code>Graph::Easy</code>的<a href="http://bloodgate.com/perl/graph/manual/index.html" target="_blank" rel="external">文档</a>非常详细，建议通读一遍；了解其中的原理和细节，对于绘图和布局有巨大帮助。目前正在翻译，文档<a href="https://www.gitbook.com/book/weishu/graph-easy-cn/details" target="_blank" rel="external">地址</a>.</p>
<h2 id="实例">实例</h2><p>语法是不是非常简单？有了这些知识，我们就可以建立自己的流程图了；Have a try！来个MVP模式的示意图试试～</p>
<ol>
<li>新建文件，<code>vi mvp.txt</code>; 输入以下代码：</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ View ] &#123;rows:3&#125; - Parse calls to -&gt; [ Presenter ] &#123;flow: south; rows: 3&#125; - Manipulates -&gt; [ Model ]</span></span><br><span class="line"><span class="attribute">[ Presenter ] - Updates -&gt; [ View ]</span></span><br></pre></td></tr></table></figure>
<ol>
<li>保存然后退出；命令行执行 <code>graph-easy mvp.txt</code>, 输入效果如下：</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+------+</span>  Parse calls to   <span class="code">+--------------+</span></span><br><span class="line">|      | ----------------&gt; |              |</span><br><span class="line">| View |                   |  Presenter   |</span><br><span class="line">|      |  Updates          |              |</span><br><span class="line">|      | &lt;---------------- |              |</span><br><span class="line"><span class="code">+------+</span>                   <span class="code">+--------------+</span></span><br><span class="line"><span class="code">                             |</span></span><br><span class="line"><span class="code">                             | Manipulates</span></span><br><span class="line"><span class="code">                             v</span></span><br><span class="line"><span class="code">                           +--------------+</span></span><br><span class="line"><span class="code">                           |    Model     |</span></span><br><span class="line"><span class="code">                           +--------------+</span></span><br></pre></td></tr></table></figure>
<p>两行代码就搞定了！自动对齐，调整位置，箭头，标签等等；我们完全不用管具体图形应该如何绘制，注意力集中在描述图像本身；还在等什么！赶紧试一试吧！！</p>
<p>原文：<a href="http://weishu.me/2016/01/03/use-pure-ascii-present-graph/">http://weishu.me/2016/01/03/use-pure-ascii-present-graph/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们使用纯文本写代码，有了Markdown又可以使用纯文本写文档，那么对于更直观的信息表达方式——图片，能不能使用纯文本描述呢？</p>
<p>另外，你是否见到过这样的注释：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451834573842.png" alt="ASCII art图像" width="463"/></p>
<p>没错，这种逼格极高的ASCII图片注释方式就是我们要讨论的话题。</p>]]>
    
    </summary>
    
  </entry>
  
</feed>
