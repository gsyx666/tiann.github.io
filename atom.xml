<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Weishu's Notes]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://weishu.me/"/>
  <updated>2016-01-28T03:19:20.000Z</updated>
  <id>http://weishu.me/</id>
  
  <author>
    <name><![CDATA[weishu]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[插件框架原理解析——概要]]></title>
    <link href="http://weishu.me/2016/01/28/understand-plugin-framework-overview/"/>
    <id>http://weishu.me/2016/01/28/understand-plugin-framework-overview/</id>
    <published>2016-01-28T03:07:36.000Z</published>
    <updated>2016-01-28T03:19:20.000Z</updated>
    <content type="html"><![CDATA[<p>2015年是Android插件化技术突飞猛进的一年，随着业务的发展各大厂商都碰到了Android Native平台的瓶颈：</p>
<ol>
<li>从技术上讲，业务逻辑的复杂导致代码量急剧膨胀，各大厂商陆续出到65535方法数的天花板；同时，运营为王的时代对于模块热更新提出了更高的要求。</li>
<li>在业务层面上，功能模块的解耦以及维护团队的分离也是大势所趋；各个团队维护着同一个App的不同模块，如果每个模块升级新功能都需要对整个app进行升级，那么发布流程不仅复杂而且效率低下；在讲究小步快跑和持续迭代的移动互联网必将遭到淘汰。</li>
</ol>
<p>H5和Hybird可以解决这些问题，但是始终比不上native的用户体验；于是，国外的FaceBook推出了<code>react-native</code>；而国内各大厂商几乎都选择纯native的插件化技术。可以说，Android的未来必将是<code>react-native</code>和插件化的天下。</p>
<a id="more"></a>
<p><code>react-native</code>资料很多，但是讲述插件化的却凤毛菱角；插件化技术听起来高深莫测，实际上要解决的就是两个问题：</p>
<ol>
<li>代码加载</li>
<li>资源加载</li>
</ol>
<h2 id="代码加载">代码加载</h2><p>类的加载可以使用Java的<code>ClassLoader</code>机制，但是对于Android来说，并不是说类加载进来就可以用了，很多组件都是有“生命”的；因此对于这些有血有肉的类，必须给它们注入活力，也就是所谓的<strong>组件生命周期管理</strong>；</p>
<p>另外，如何管理加载进来的类也是一个问题。假设多个插件依赖了相同的类，是抽取公共依赖进行管理还是插件单独依赖？这就是<strong>ClassLoader的管理问题</strong>；</p>
<h2 id="资源加载">资源加载</h2><p>资源加载方案大家使用的原理都差不多，都是用<code>AssetManager</code>的隐藏方法<code>addAssetPath</code>；但是，不同插件的资源如何管理？是公用一套资源还是插件独立资源？共用资源如何避免资源冲突？对于资源加载，有的方案共用一套资源并采用资源分段机制解决冲突（要么修改<code>aapt</code>要么添加编译插件）；有的方案选择独立资源，不同插件管理自己的资源。</p>
<p>目前国内开源的较成熟的插件方案有<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">DL</a>和<a href="https://github.com/Qihoo360/DroidPlugin" target="_blank" rel="external">DroidPlugin</a>；但是DL方案仅仅对Frameworl的表层做了处理，严重依赖<code>that</code>语法，编写插件代码和主程序代码需单独区分；而DroidPlugin通过Hook增强了Framework层的很多系统服务，开发插件就跟开发独立app差不多；就拿Activity生命周期的管理来说，DL的代理方式就像是牵线木偶，插件只不过是操纵傀儡而已；而DroidPlugin则是借尸还魂，插件是有血有肉的系统管理的真正组件；DroidPlugin Hook了系统几乎所有的Sevice，欺骗了大部分的系统API；掌握这个Hook过程需要掌握很多系统原理，因此学习DroidPlugin对于整个Android FrameWork层大有裨益。</p>
<p>接下来的一系列文章将以DroidPlugin为例讲解插件框架的原理，揭开插件化的神秘面纱；同时还能帮助深入理解Android Framewrok；主要内容如下：</p>
<ul>
<li>Hook机制之动态代理</li>
<li>Hook机制之Binder Hook</li>
<li>Activity生命周期管理，占坑和Hook</li>
<li>插件的广播机制，静态广播非静态</li>
<li>Service组件的管理，占坑和Hook</li>
<li>ContentProvider的管理</li>
<li>插件加载解析之自定义包管理服务(PackageManager)</li>
<li>插件进程管理机制（ActivityMAnager）</li>
<li>插件机制之资源管理</li>
<li>DroidPlugin插件通信机制</li>
<li>DroidPlugin框架缺陷</li>
<li>不同插件框架方案对比</li>
<li>插件化的未来</li>
</ul>
<p>另外，对于每一章内容都会有详细的demo，具体见<a href="https://github.com/tiann/understand-plugin-framework" target="_blank" rel="external">understand-plugin-framework</a>；喜欢就点个关注吧～定期更新，敬请期待！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015年是Android插件化技术突飞猛进的一年，随着业务的发展各大厂商都碰到了Android Native平台的瓶颈：</p>
<ol>
<li>从技术上讲，业务逻辑的复杂导致代码量急剧膨胀，各大厂商陆续出到65535方法数的天花板；同时，运营为王的时代对于模块热更新提出了更高的要求。</li>
<li>在业务层面上，功能模块的解耦以及维护团队的分离也是大势所趋；各个团队维护着同一个App的不同模块，如果每个模块升级新功能都需要对整个app进行升级，那么发布流程不仅复杂而且效率低下；在讲究小步快跑和持续迭代的移动互联网必将遭到淘汰。</li>
</ol>
<p>H5和Hybird可以解决这些问题，但是始终比不上native的用户体验；于是，国外的FaceBook推出了<code>react-native</code>；而国内各大厂商几乎都选择纯native的插件化技术。可以说，Android的未来必将是<code>react-native</code>和插件化的天下。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="droidplugin" scheme="http://weishu.me/tags/droidplugin/"/>
    
      <category term="plugin framework" scheme="http://weishu.me/tags/plugin-framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你真的了解AsyncTask？]]></title>
    <link href="http://weishu.me/2016/01/18/dive-into-asynctask/"/>
    <id>http://weishu.me/2016/01/18/dive-into-asynctask/</id>
    <published>2016-01-18T07:41:08.000Z</published>
    <updated>2016-01-18T07:47:21.000Z</updated>
    <content type="html"><![CDATA[<p>虽说现在做网络请求有了Volley全家桶和OkHttp这样好用的库，但是在处理其他后台任务以及与UI交互上，还是需要用到AsyncTask。但是你真的了解AsyncTask吗？</p>
<p>AsyncTask的实现几经修改，因此在不同版本的Android系统上表现各异；我相信，任何一个用户量上千万的产品绝对不会在代码里面使用系统原生的AsynTask，因为它蛋疼的兼容性以及极高的崩溃率实在让人不敢恭维。本文将带你了解AsyncTask背后的原理，并给出一个久经考验的AsyncTask修改版。</p>
<a id="more"></a>
<h2 id="AsyncTask是什么？">AsyncTask是什么？</h2><p>AsyncTask到底是什么呢？很简单，<strong>它不过是对线程池和Handler的封装</strong>；用线程池来处理后台任务，用Handler来处理与UI的交互。线程池使用的是<code>Executor</code>接口，我们先了解一下线程池的特性。</p>
<h2 id="线程池ThreadPoolExecutor">线程池ThreadPoolExecutor</h2><p>JDK5带来的一大改进就是Java的并发能力，它提供了三种并发武器：并发框架Executor，并发集合类型如ConcurrentHashMap，并发控制类如CountDownLatch等；圣经《Effective Java》也说，尽量使用Exector而不是直接用Thread类进行并发编程。</p>
<p>AsyncTask内部也使用了线程池处理并发；线程池通过<code>ThreadPoolExector</code>类构造，这个构造函数参数比较多，它允许开发者对线程池进行定制，我们先看看这每个参数是什么意思，然后看看Android是以何种方式定制的。</p>
<p>ThreadPoolExecutor的其他构造函数最终都会调用如下的构造函数完成对象创建工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                          <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                          <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize: 核心线程数目，即使线程池没有任务，核心线程也不会终止（除非设置了allowCoreThreadTimeOut参数）可以理解为“常驻线程”</li>
<li>maximumPoolSize: 线程池中允许的最大线程数目；一般来说，线程越多，线程调度开销越大；因此一般都有这个限制。</li>
<li>keepAliveTime: 当线程池中的线程数目比核心线程多的时候，如果超过这个keepAliveTime的时间，多余的线程会被回收；这些与核心线程相对的线程通常被称为<em>缓存线程</em></li>
<li>unit: keepAliveTime的时间单位</li>
<li>workQueue: 任务执行前保存任务的队列；这个队列仅保存由execute提交的Runnable任务</li>
<li>threadFactory: 用来构造线程池的工厂；一般都是使用默认的；</li>
<li>handler: 当线程池由于线程数目和队列限制而导致后续任务阻塞的时候，线程池的处理方式。</li>
</ul>
<p>那么，当一个新的任务到达的时候，线程池中的线程是如何调度的呢？（别慌，讲这么一大段线程池的知识，是为了理解AsyncTask；Be Patient）</p>
<ol>
<li>如果线程池中线程的数目少于corePoolSize，就算线程池中有其他的没事做的核心线程，线程池还是会重新创建一个核心线程；直到核心线程数目到达corePoolSize（常驻线程就位）</li>
<li>如果线程池中线程的数目大于或者等于corePoolSize，但是工作队列workQueue没有满，那么新的任务会放在队列workQueue中，按照FIFO的原则依次等待执行；（当有核心线程处理完任务空闲出来后，会检查这个工作队列然后取出任务默默执行去）</li>
<li>如果线程池中线程数目大于等于corePoolSize，并且工作队列workQueue满了，但是总线程数目小于maximumPoolSize，那么直接创建一个线程处理被添加的任务。</li>
<li>如果工作队列满了，并且线程池中线程的数目到达了最大数目maximumPoolSize，那么就会用最后一个构造参数<code>handler</code>处理；**默认的处理方式是直接丢掉任务，然后抛出一个异常。</li>
</ol>
<p>总结起来，也即是说，当有新的任务要处理时，<strong>先看线程池中的线程数量是否大于 corePoolSize，再看缓冲队列 workQueue 是否满，最后看线程池中的线程数量是否大于 maximumPoolSize</strong>。另外，当线程池中的线程数量大于 corePoolSize 时，如果里面有线程的空闲时间超过了 keepAliveTime，就将其移除线程池，这样，可以动态地调整线程池中线程的数量。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/20161-18.jpg" alt="风景"></p>
<p>我们以API 22为例，看一看AsyncTask里面的线程池是以什么参数构造的；AsyncTask里面有“两个”线程池；一个<code>THREAD_POOL_EXECUTOR</code>一个<code>SERIAL_EXECUTOR</code>；之所以打引号，是因为其实<code>SERIAL_EXECUTOR</code>也使用<code>THREAD_POOL_EXECUTOR</code>实现的，只不过加了一个队列弄成了串行而已，那么这个<code>THREAD_POOL_EXECUTOR</code>是如何构造的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</span><br><span class="line">            = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</span><br><span class="line">                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</span><br></pre></td></tr></table></figure>
<p>可以看到，AsyncTask里面线程池是一个核心线程数为<code>CPU + 1</code>，最大线程数为<code>CPU * 2 + 1</code>，工作队列长度为<strong>128</strong>的线程池；并且没有传递<code>handler</code>参数，那么使用的就是默认的Handler（拒绝执行).</p>
<p>那么问题来了：</p>
<ol>
<li><p>如果任务过多，那么超过了工作队列以及线程数目的限制导致这个线程池发生阻塞，那么悲剧发生，默认的处理方式会直接抛出一个异常导致进程挂掉。假设你自己写一个异步图片加载的框架，然后用AsyncTask实现的话，当你快速滑动ListView的时候很容易发生这种异常；这也是为什么各大ImageLoader都是自己写线程池和Handlder的原因。</p>
</li>
<li><p>这个线程池是一个静态变量；那么在同一个进程之内，所有地方使用到的AsyncTask默认构造函数构造出来的AsyncTask都使用的是同一个线程池，如果App模块比较多并且不加控制的话，很容易满足第一条的崩溃条件；如果你不幸在不同的AsyncTask的doInBackgroud里面访问了共享资源，那么就会发生各种并发编程问题。</p>
</li>
<li><p>在AsyncTask全部执行完毕之后，进程中还是会常驻corePoolSize个线程；在Android 4.4 （API 19）以下，这个corePoolSize是hardcode的，数值是5；API 19改成了<code>cpu + 1</code>；也就是说，在Android 4.4以前；如果你执行了超过五个AsyncTask；然后啥也不干了，进程中还是会有5个AsyncTask线程；不信，你看：</p>
</li>
</ol>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1453101991064.png" width="277"></p>
<h3 id="Handler">Handler</h3><p>AsyncTask里面的handler很简单，如下（API 22代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalHandler sHandler = <span class="keyword">new</span> InternalHandler();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Looper.getMainLooper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里直接用的主线程的Looper；如果去看API 22以下的代码，会发现它没有这个构造函数，而是使用默认的；默认情况下，Handler会使用当前线程的Looper，如果你的AsyncTask是在子线程创建的，那么很不幸，你的<code>onPreExecute</code>和<code>onPostExecute</code>并非在UI线程执行，而是被Handler post到创建它的那个线程执行；如果你在这两个线程更新了UI，那么直接导致崩溃。这也是大家口口相传的<strong>AsyncTask必须在主线程创建</strong>的原因。</p>
<p>另外，AsyncTask里面的这个Handler是一个静态变量，也就是说它是在类加载的时候创建的；如果在你的APP进程里面，以前从来没有使用过AsyncTask，然后在子线程使用AsyncTask的相关变量，那么导致静态Handler初始化，如果在API 16以下，那么会出现上面同样的问题；这就是<strong>AsyncTask必须在主线程初始化</strong> 的原因。</p>
<p>事实上，在Android 4.1(API 16)以后，在APP主线程ActivityThread的main函数里面，直接调用了<code>AscynTask.init</code>函数确保这个类是在主线程初始化的；另外，init这个函数里面获取了<code>InternalHandler</code>的Looper，由于是在主线程执行的，因此，AsyncTask的Handler用的也是主线程的Looper。这个问题从而得到彻底的解决。</p>
<h2 id="AsyncTask是并行执行的吗？">AsyncTask是并行执行的吗？</h2><p>现在知道AsyncTask内部有一个线程池，那么派发给AsyncTask的任务是并行执行的吗？</p>
<p>答案是不确定。在Android 1.5刚引入的时候，AsyncTask的<code>execute</code>是串行执行的；到了Android 1.6直到Android 2.3.2，又被修改为并行执行了，这个执行任务的线程池就是<code>THREAD_POOL_EXECUTOR</code>，因此在一个进程内，所有的AsyncTask都是并行执行的；但是在Android 3.0以后，如果你使用<code>execute</code>函数直接执行AsyncTask，那么<strong>这些任务是串行执行的</strong>；（你说蛋疼不）源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>sDefaultExecutor</code>就是用来执行任务的线程池，那么它的值是什么呢？继续看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br></pre></td></tr></table></figure>
<p>因此结论就来了：<strong>Android 3.0以上，AsyncTask默认并不是并行执行的</strong>；</p>
<h3 id="为什么默认不并行执行？">为什么默认不并行执行？</h3><p>也许你不理解，为什么AsyncTask默认把它设计为串行执行的呢？</p>
<p>由于一个进程内所有的AsyncTask都是使用的同一个线程池执行任务；如果同时有几个AsyncTask一起并行执行的话，恰好AysncTask的使用者在<code>doInbackgroud</code>里面访问了相同的资源，但是自己没有处理同步问题；那么就有可能导致灾难性的后果！</p>
<p>由于开发者通常不会意识到需要对他们创建的所有的AsyncTask对象里面的<code>doInbackgroud</code>做同步处理，因此，API的设计者为了避免这种无意中访问并发资源的问题，干脆把这个API设置为默认所有串行执行的了。如果你明确知道自己需要并行处理任务，那么你需要使用<code>executeOnExecutor(Executor exec,Params... params)</code>这个函数来指定你用来执行任务的线程池，同时为自己的行为负责。（处理同步问题）</p>
<p>实际上《Effective Java》里面有一条原则说的就是这种情况：不要在同步块里面调用不可信的外来函数。这里明显违背了这个原则：AsyncTask这个类并不知道使用者会在<code>doInBackgroud</code>这个函数里面做什么，但是对它的行为做了某种假设。</p>
<h3 id="如何让AsyncTask并行执行？">如何让AsyncTask并行执行？</h3><p>正如上面所说，如果你确定自己做好了同步处理，或者你没有在不同的AsyncTask里面访问共享资源，需要AsyncTask能够并行处理任务的话，你可以用带有两个参数的<code>executeOnExecutor</code>执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AsyncTask&lt;Void, Void, Vo</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</span><br></pre></td></tr></table></figure>
<h2 id="更好的AsyncTask">更好的AsyncTask</h2><p>从上面的分析得知，AsyncTask有如下问题：</p>
<ol>
<li>默认的AsyncTask如果处理的任务过多，会导致程序直接崩溃；</li>
<li>AsyncTask类必须在主线程初始化，必须在主线程创建，不然在API 16以下很大概率崩溃。</li>
<li>如果你曾经使用过AsyncTask，以后不用了；在Android 4.4以下，进程内也默认有5个AsyncTask线程；在Android 4.4以上，默认有<code>CPU + 1</code>个线程。</li>
<li>Android 3.0以上的AsyncTask默认是串行执行任务的；如果要并行执行需要调用低版本没有的API，处理麻烦。</li>
</ol>
<p>因此我们对系统的AsyncTask做了一些修改，在不同Android版本提供一致的行为，并且提高了使用此类的安全性，主要改动如下：</p>
<ol>
<li>添加对于任务过多导致崩溃的异常保护；在这里进行必要的数据统计上报工作；如果出现这个问题，说明AsyncTask不适合这种场景了，需要考虑重构；</li>
<li>移植API 22对于Handler的处理；这样就算在线程创建异步任务，也不会有任何问题；</li>
<li>提供串行执行和并行执行的<code>execute</code>方法；默认串行执行，如果明确知道自己在干什么，可以使用<code>executeParallel</code>并行执行。</li>
<li>在<code>doInbackgroud</code>里面频繁崩溃的地方加上<code>try..catch</code>；自己处理数据上报工作。</li>
</ol>
<p>完整代码见gist，<a href="https://gist.github.com/tiann/8860bcc514f067ab4291" target="_blank" rel="external">BetterAsyncTask</a></p>
<p>原文地址：<a href="http://weishu.me/2016/01/18/dive-into-asynctask/">http://weishu.me/2016/01/18/dive-into-asynctask/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽说现在做网络请求有了Volley全家桶和OkHttp这样好用的库，但是在处理其他后台任务以及与UI交互上，还是需要用到AsyncTask。但是你真的了解AsyncTask吗？</p>
<p>AsyncTask的实现几经修改，因此在不同版本的Android系统上表现各异；我相信，任何一个用户量上千万的产品绝对不会在代码里面使用系统原生的AsynTask，因为它蛋疼的兼容性以及极高的崩溃率实在让人不敢恭维。本文将带你了解AsyncTask背后的原理，并给出一个久经考验的AsyncTask修改版。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binder学习指南]]></title>
    <link href="http://weishu.me/2016/01/12/binder-index-for-newer/"/>
    <id>http://weishu.me/2016/01/12/binder-index-for-newer/</id>
    <published>2016-01-12T13:26:09.000Z</published>
    <updated>2016-01-13T05:50:07.000Z</updated>
    <content type="html"><![CDATA[<p>毫不夸张地说，Binder是Android系统中最重要的特性之一；正如其名“粘合剂”所喻，它是系统间各个组件的桥梁，Android系统的开放式设计也很大程度上得益与这种及其方便的跨进程通信机制。</p>
<p>理解Binder对于理解整个Android系统有着非常重要的作用，Android系统的四大组件，AMS，PMS等系统服务无一不与Binder挂钩；如果对Binder不甚了解，那么就很难了解这些系统机制，从而仅仅浮游与表面，不懂Binder你都不好意思说自己会Android开发；要深入Android，Binder是必须迈出的一步。</p>
<p>现在网上有不少资料介绍Binder，个人觉得最好的两篇如下：</p>
<ol>
<li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Binder设计与实现</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external"> Android进程间通信（IPC）机制Binder简要介绍和学习计划</a>系列</li>
</ol>
<p>其中, 《Binder设计与实现》以一种宏观的角度解释了Android系统中的Binder机制，文章如行云流水；如果对于Binder有一定的了解再来看着篇文章，有一种打通任督二脉的感觉；每看一次理解就深一层。老罗的系列文章则从系统源码角度深入分析了Binder的实现细节；具有很大的参考意义；每当对于Binder细节有疑惑，看一看他的书就迎刃而解。</p>
<p>但是遗憾的是，Binder机制终究不是三言两语就能解释清楚的，一上来就扒出源码很可能深陷细节无法自拔，老罗的文章那不是一般的长，如果看不懂强行看很容易睡着；勉强看完还是云里雾里；相反如果直接大谈特谈Binder的设计，那么完全就是不知所云；因此上述两篇文章对于初学者并不友好，本文不会深入源码细节，也不会对于Binder的设计高谈阔论；重点如下：<br><a id="more"></a></p>
<ol>
<li>一些Linux的预备知识</li>
<li>Binder到底是什么？</li>
<li>Binder机制是如何跨进程的？</li>
<li>一次Binder通信的基本流程是什么样？</li>
<li>深入理解Java层的Binder</li>
</ol>
<p>读完本文，你应该对于Java层的AIDL了如指掌，对于Binder也会有一个大体上的认识；再深入学习就得靠自己了，本人推荐的Binder学习路径如下：</p>
<ol>
<li>先学会熟练使用AIDL进行跨进程通信（简单来说就是远程Service）</li>
<li>看完本文</li>
<li>看Android文档，<code>Parcel, IBinder, Binder</code>等涉及到跨进程通信的类</li>
<li>不依赖AIDL工具，手写远程Service完成跨进程通信</li>
<li>看《Binder设计与实现》</li>
<li>看老罗的博客或者书（书结构更清晰）</li>
<li>再看《Binder设计与实现》</li>
<li>学习Linux系统相关知识；自己看源码。</li>
</ol>
<h2 id="背景知识">背景知识</h2><p>为了理解Binder我们先澄清一些概念。为什么需要跨进程通信（IPC），怎么做到跨进程通信？为什么是Binder？</p>
<p>由于Android系统基于Linux内核，因此有必要了解相关知识。</p>
<h3 id="进程隔离">进程隔离</h3><blockquote>
<p>进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。</p>
</blockquote>
<p>以上来自维基百科；操作系统的不同进程之间，数据不共享；对于每个进程来说，它都天真地以为自己独享了整个系统，完全不知道其他进程的存在；(有关虚拟地址，请自行查阅）因此一个进程需要与另外一个进程通信，需要某种系统机制才能完成。</p>
<h3 id="用户空间/内核空间">用户空间/内核空间</h3><p>详细解释可以参考<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Kernel Space Definition</a>；简单理解如下：</p>
<p>Linux Kernel是操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</p>
<p>对于Kernel这么一个高安全级别的东西，显然是不容许其它的应用程序随便调用或访问的，所以需要对Kernel提供一定的保护机制，这个保护机制用来告诉那些应用程序，你只可以访问某些许可的资源，不许可的资源是拒绝被访问的，于是就把Kernel和上层的应用程序抽像的隔离开，分别称之为Kernel Space和User Space。</p>
<h3 id="系统调用/内核态/用户态">系统调用/内核态/用户态</h3><p>虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？</p>
<blockquote>
<p>Kernel space can be accessed by user processes only through the use of system calls. </p>
</blockquote>
<p>用户空间访问内核空间的唯一方式就是<strong>系统调用</strong>；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。</p>
<h3 id="内核模块/驱动">内核模块/驱动</h3><p>通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的Linux通信机制，比如Socket，管道等都是内核支持的；但是Binder并不是Linux内核的一部分，它是怎么做到访问内核空间的呢？Linux的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。</p>
<p>在Android系统中，这个运行在内核空间的，负责各个用户进程通过Binder通信的内核模块叫做<strong>Binder驱动</strong>; </p>
<blockquote>
<p>驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作；</p>
</blockquote>
<p>驱动就是操作硬件的接口，为了支持Binder通信过程，Binder使用了一种“硬件”，因此这个模块被称之为驱动。</p>
<p>好了，说了这么多枯燥的概念，看张美图缓解一下。</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/20161-8.jpg" alt=""></p>
<h3 id="为什么使用Binder？">为什么使用Binder？</h3><p>Android使用的Linux内核拥有着非常多的跨进程通信机制，比如管道，System V，Socket等；为什么还需要单独搞一个Binder出来呢？主要有两点，性能和安全。在移动设备上，广泛地使用跨进程通信肯定对通信机制本身提出了严格的要求；Binder相对出传统的Socket方式，更加高效；另外，传统的进程通信方式对于通信双方的身份并没有做出严格的验证，只有在上层协议上进行架设；比如Socket通信ip地址是客户端手动填入的，都可以进行伪造；而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。这个也是Android权限模型的基础。</p>
<h2 id="Binder通信模型">Binder通信模型</h2><p>对于跨进程通信的双方，我们姑且叫做Server进程（简称Server），Client进程（简称Client）；由于进程隔离的存在，它们之间没办法通过简单的方式进行通信，那么Binder机制是如何进行的呢？</p>
<p>回想一下日常生活中我们通信的过程：假设A和B要进行通信，通信的媒介是打电话（A是Client，B是Server）；A要给B打电话，必须知道B的号码，这个号码怎么获取呢？<strong>通信录</strong>. </p>
<p>这个通信录就是一张表；内容大致是：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B -&gt; 12345676</span><br><span class="line">C -&gt; 12334354</span><br></pre></td></tr></table></figure>
<p>先查阅通信录，拿到B的号码；才能进行通信；否则，怎么知道应该拨什么号码？回想一下古老的电话机，如果A要给B打电话，必须先连接通话中心，说明给我接通B的电话；这时候通话中心帮他呼叫B；连接建立，就完成了通信。</p>
<p>另外，光有电话和通信录是不可能完成通信的，没有基站支持；信息根本无法传达。</p>
<p>我们看到，一次电话通信的过程除了通信的双方还有两个隐藏角色：通信录和基站。Binder通信机制也是一样：两个运行在用户空间的进程要完成通信，必须借助内核的帮助，这个运行在内核里面的程序叫做<strong>Binder驱动</strong>，它的功能类似于基站；通信录呢，就是一个叫做<strong>ServiceManager</strong>的东西（简称SM）</p>
<p>OK，Binder的通信模型就是这么简单，如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/binder-model.png" alt=""></p>
<p>整个通信步骤如下：</p>
<ol>
<li>SM建立(建立通信录)；首先有一个进程向驱动提出申请为SM；驱动同意之后，SM进程负责管理Service（注意这里是Service而不是Server，因为如果通信过程反过来的话，那么原来的客户端Client也会成为服务端Server）不过这时候通信录还是空的，一个号码都没有。</li>
<li>各个Server向SM注册(完善通信录)；每个Server端进程启动之后，向SM报告，我是zhangsan, 要找我请返回0x1234(这个地址没有实际意义，类比)；其他Server进程依次如此；这样SM就建立了一张表，对应着各个Server的名字和地址；就好比B与A见面了，说存个我的号码吧，以后找我拨打10086；</li>
<li>Client想要与Server通信，首先询问SM；请告诉我如何联系zhangsan，SM收到后给他一个号码0x1234；Client收到之后，开心滴用这个号码拨通了Server的电话，于是就开始通信了。</li>
</ol>
<p>那么Binder驱动干什么去了呢？这里Client与SM的通信，以及Client与Server的通信，都会经过驱动，驱动在背后默默无闻，但是做着最重要的工作。驱动是整个通信过程的核心，因此完成跨进程通信的秘密全部隐藏在驱动里面；这个我们稍后讨论。</p>
<p>OK，上面就是整个Binder通信的基本模型；做了一个简单的类比，当然也有一些不恰当的地方，(比如通信录现实中每个人都有一个，但是SM整个系统只有一个；基站也有很多个，但是驱动只有一个）；但是整体上就是这样的；我们看到其实整个通信模型非常简单。</p>
<h2 id="Binder机制跨进程原理">Binder机制跨进程原理</h2><p>上文给出了Binder的通信模型，指出了通信过程的四个角色: Client, Server, SM, driver; 但是我们仍然不清楚<strong>Client到底是如何与Server完成通信的</strong>。</p>
<p>两个运行在用户空间的进程A和进程B如何完成通信呢？内核可以访问A和B的所有数据；所以，最简单的方式是通过内核做中转；假设进程A要给进程B发送数据，那么就先把A的数据copy到内核空间，然后把内核空间对应的数据copy到B就完成了；用户空间要操作内核空间，需要通过系统调用；刚好，这里就有两个系统调用：<code>copy_from_user</code>, <code>copy_to_user</code>。</p>
<p>但是，Binder机制并不是这么干的。讲这么一段，是说明进程间通信并不是什么神秘的东西。那么，Binder机制是如何实现跨进程通信的呢？</p>
<p>Binder驱动为我们做了一切。</p>
<p>假设Client进程想要调用Server进程的<code>object</code>对象的一个方法<code>add</code>;对于这个跨进程通信过程，我们来看看Binder机制是如何做的。 （通信是一个广泛的概念，只要一个进程能调用另外一个进程里面某对象的方法，那么具体要完成什么通信内容就很容易了。）</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/2016binder-procedure.png" alt="Alt text"></p>
<p>首先，Server进程要向SM注册；告诉自己是谁，自己有什么能力；在这个场景就是Server告诉SM，它叫<code>zhangsan</code>，它有一个<code>object</code>对象，可以执行<code>add</code> 操作；于是SM建立了一张表：<code>zhangsan</code>这个名字对应进程Server; </p>
<p>然后Client向SM查询：我需要联系一个名字叫做<code>zhangsan</code>的进程里面的<code>object</code>对象；这时候关键来了：进程之间通信的数据都会经过运行在内核空间里面的驱动，驱动在数据流过的时候做了一点手脚，它并不会给Client进程返回一个真正的<code>object</code>对象，而是返回一个看起来跟<code>object</code>一模一样的代理对象<code>objectProxy</code>，这个<code>objectProxy</code>也有一个<code>add</code>方法，但是这个<code>add</code>方法没有Server进程里面<code>object</code>对象的<code>add</code>方法那个能力；<code>objectProxy</code>的<code>add</code>只是一个傀儡，它唯一做的事情就是把参数包装然后交给驱动。(这里我们简化了SM的流程，见下文)</p>
<p>但是Client进程并不知道驱动返回给它的对象动过手脚，毕竟伪装的太像了，如假包换。Client开开心心地拿着<code>objectProxy</code>对象然后调用<code>add</code>方法；我们说过，这个<code>add</code>什么也不做，直接把参数做一些包装然后直接转发给Binder驱动。</p>
<p>驱动收到这个消息，发现是这个<code>objectProxy</code>；一查表就明白了：我之前用<code>objectProxy</code>替换了<code>object</code>发送给Client了，它真正应该要访问的是<code>object</code>对象的<code>add</code>方法；于是Binder驱动通知Server进程，<em>调用你的object对象的<code>add</code>方法，然后把结果发给我</em>，Sever进程收到这个消息，照做之后将结果返回驱动，驱动然后把结果返回给<code>Client</code>进程；于是整个过程就完成了。</p>
<p>由于驱动返回的<code>objectProxy</code>与Server进程里面原始的<code>object</code>是如此相似，给人感觉好像是<strong>直接把Server进程里面的对象object传递到了Client进程</strong>；因此，我们可以说<strong>Binder对象是可以进行跨进程传递的对象</strong></p>
<p>但事实上我们知道，Binder跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是Binder跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client进程的操作其实是对于影子的操作，影子利用Binder驱动最终让真身完成操作。</p>
<p>理解这一点非常重要；务必仔细体会。另外，Android系统实现这种机制使用的是<em>代理模式</em>, 对于Binder的访问，如果是在同一个进程（不需要跨进程），那么直接返回原始的Binder实体；如果在不同进程，那么就给他一个代理对象（影子）；我们在系统源码以及AIDL的生成代码里面可以看到很多这种实现。</p>
<p>另外我们为了简化整个流程，隐藏了SM这一部分驱动进行的操作；实际上，由于SM与Server通常不在一个进程，Server进程向SM注册的过程也是跨进程通信，驱动也会对这个过程进行暗箱操作：SM中存在的Server端的对象实际上也是代理对象，后面Client向SM查询的时候，驱动会给Client返回另外一个代理对象。Sever进程的本地对象仅有一个，其他进程所拥有的全部都是它的代理。</p>
<p>一句话总结就是：<strong>Client进程只不过是持有了Server端的代理；代理对象协助驱动完成了跨进程通信。</strong></p>
<p>OK，该休息一下了。</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/20161-12.jpg" alt=""></p>
<h2 id="Binder到底是什么？">Binder到底是什么？</h2><p>我们经常提到Binder，那么Binder到底是什么呢？</p>
<p>Binder的设计采用了面向对象的思想，在Binder通信模型的四个角色里面；他们的代表都是“Binder”，这样，对于Binder通信的使用者而言，Server里面的Binder和Client里面的Binder没有什么不同，一个Binder对象就代表了所有，它不用关心实现的细节，甚至不用关心驱动以及SM的存在；这就是抽象。</p>
<ul>
<li>通常意义下，Binder指的是一种通信机制；我们说AIDL使用Binder进行通信，指的就是<strong>Binder这种IPC机制</strong>。</li>
<li>对于Server进程来说，Binder指的是<strong>Binder本地对象</strong></li>
<li>对于Client来说，Binder指的是<strong>Binder代理对象</strong>，它只是<strong>Binder本地对象</strong>的一个远程代理；对这个Binder代理对象的操作，会通过驱动最终转发到Binder本地对象上去完成；对于一个拥有Binder对象的使用者而言，它无须关心这是一个Binder代理对象还是Binder本地对象；对于代理对象的操作和对本地对象的操作对它来说没有区别。</li>
<li>对于传输过程而言，Binder是可以进行跨进程传递的对象；Binder驱动会对具有跨进程传递能力的对象做特殊处理：自动完成代理对象和本地对象的转换。</li>
</ul>
<blockquote>
<p>面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体（本地对象）位于一个进程中，而它的引用（代理对象）却遍布于系统的各个进程之中。最诱人的是，这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。</p>
</blockquote>
<h3 id="驱动里面的Binder">驱动里面的Binder</h3><p>我们现在知道，Server进程里面的Binder对象指的是Binder本地对象，Client里面的对象值得是Binder代理对象；在Binder对象进行跨进程传递的时候，Binder驱动会自动完成这两种类型的转换；因此Binder驱动必然保存了每一个跨越进程的Binder对象的相关信息；在驱动中，Binder本地对象的代表是一个叫做<code>binder_node</code>的数据结构，Binder代理对象是用<code>binder_ref</code>代表的；有的地方把Binder本地对象直接称作Binder实体，把Binder代理对象直接称作Binder引用（句柄），其实指的是Binder对象在驱动里面的表现形式；读者明白意思即可。</p>
<p>OK，现在大致了解Binder的通信模型，也了解了Binder这个对象在通信过程中各个组件里面到底表示的是什么。</p>
<h2 id="深入理解Java层的Binder">深入理解Java层的Binder</h2><h3 id="IBinder/IInterface/Binder/BinderProxy/Stub">IBinder/IInterface/Binder/BinderProxy/Stub</h3><p>我们使用AIDL接口的时候，经常会接触到这些类，那么这每个类代表的是什么呢？</p>
<ul>
<li>IBinder是一个接口，它代表了<strong>一种跨进程传输的能力</strong>；只要实现了这个接口，就能将这个对象进行跨进程传递；这是驱动底层支持的；在跨进程数据流经驱动的时候，驱动会识别IBinder类型的数据，从而自动完成不同进程Binder本地对象以及Binder代理对象的转换。</li>
<li>IBinder负责数据传输，那么client与server端的调用契约（这里不用接口避免混淆）呢？这里的IInterface代表的就是远程server对象具有什么能力。具体来说，就是aidl里面的接口。</li>
<li>Java层的Binder类，代表的其实就是<strong>Binder本地对象</strong>。BinderProxy类是Binder类的一个内部类，它代表远程进程的Binder对象的本地代理；这两个类都继承自IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder驱动会自动完成这两个对象的转换。</li>
<li>在使用AIDL的时候，编译工具会给我们生成一个Stub的静态内部类；这个类继承了Binder, 说明它是一个Binder本地对象，它实现了IInterface接口，表明它具有远程Server承诺给Client的能力；Stub是一个抽象类，具体的IInterface的相关实现需要我们手动完成，这里使用了策略模式。</li>
</ul>
<h3 id="AIDL过程分析">AIDL过程分析</h3><p>现在我们通过一个AIDL的使用，分析一下整个通信过程中，各个角色到底做了什么，AIDL到底是如何完成通信的。（如果你连AIDL都不熟悉，请先查阅官方文档）</p>
<p>首先定一个一个简单的aidl接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ICompute.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.test.app;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICompute</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用编译工具编译之后，可以得到对应的ICompute.java类，看看系统给我们生成的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICompute</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Local-side IPC implementation stub class.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">test</span>.<span class="title">app</span>.<span class="title">ICompute</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.example.test.app.ICompute"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Construct the stub at attach it to the interface.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Cast an IBinder object into an com.example.test.app.ICompute interface,</span><br><span class="line">         * generating a proxy if needed.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.example.test.app.<span class="function">ICompute <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.test.app.ICompute))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.example.test.app.ICompute) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.example.test.app.ICompute.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">int</span> _arg0;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    <span class="keyword">int</span> _arg1;</span><br><span class="line">                    _arg1 = data.readInt();</span><br><span class="line">                    <span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeInt(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">test</span>.<span class="title">app</span>.<span class="title">ICompute</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Demonstrates some basic types that you can use as parameters</span><br><span class="line">             * and return values in AIDL.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">int</span> _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeInt(a);</span><br><span class="line">                    _data.writeInt(b);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.readInt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统帮我们生成了这个文件之后，我们只需要继承ICompute.Stub这个抽象类，实现它的方法，然后在Service 的onBind方法里面返回就实现了AIDL。这个Stub类非常重要，具体看看它做了什么。</p>
<p>Stub类继承自Binder，意味着这个Stub其实自己是一个Binder本地对象，然后实现了ICompute接口，ICompute本身是一个IInterface，因此他携带某种客户端需要的能力（这里是方法<code>add</code>)。此类有一个内部类Proxy，也就是Binder代理对象；</p>
<p>然后看看<code>asInterface</code>方法，我们在bind一个Service之后，在onServiceConnecttion的回调里面，就是通过这个方法拿到一个远程的service的，这个方法做了什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Cast an IBinder object into an com.example.test.app.ICompute interface,</span><br><span class="line"> * generating a proxy if needed.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.example.test.app.<span class="function">ICompute <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.test.app.ICompute))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.example.test.app.ICompute) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.example.test.app.ICompute.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看函数的参数<code>IBinder</code>类型的obj，这个对象是驱动给我们的，如果是Binder本地对象，那么它就是Binder类型，如果是Binder代理对象，那就是<code>BinderProxy</code>类型；然后，正如上面自动生成的文档所说，它会试着查找Binder本地对象，如果找到，说明Client和Server都在同一个进程，这个参数直接就是本地对象，直接强制类型转换然后返回，如果找不到，说明是远程对象（处于另外一个进程）那么就需要创建一个Binde代理对象，让这个Binder代理实现对于远程对象的访问。一般来说，如果是与一个远程Service对象进行通信，那么这里返回的一定是一个Binder代理对象，这个IBinder参数的实际上是BinderProxy;</p>
<p>再看看我们对于aidl的<code>add</code> 方法的实现；在Stub类里面，<code>add</code>是一个抽象方法，我们需要继承这个类并实现它；如果Client和Server在同一个进程，那么直接就是调用这个方法；那么，如果是远程调用，这中间发生了什么呢？Client是如何调用到Server的方法的？</p>
<p>我们知道，对于远程方法的调用，是通过Binder代理完成的，在这个例子里面就是<code>Proxy</code>类；<code>Proxy</code>对于<code>add</code>方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">int</span> _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeInt(a);</span><br><span class="line">        _data.writeInt(b);</span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.readInt();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它首先用<code>Parcel</code>把数据序列化了，然后调用了<code>transact</code>方法；这个<code>transact</code>到底做了什么呢？这个<code>Proxy</code>类在<code>asInterface</code>方法里面被创建，前面提到过，如果是Binder代理那么说明驱动返回的IBinder实际是<code>BinderProxy</code>, 因此我们的<code>Proxy</code>类里面的<code>mRemote</code>实际类型应该是<code>BinderProxy</code>；我们看看<code>BinderProxy</code>的<code>transact</code>方法：(Binder.java的内部类)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span><br><span class="line">            <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个本地方法；它的实现在native层，具体来说在frameworks/base/core/jni/android_util_Binder.cpp文件，里面进行了一系列的函数调用，调用链实在太长这里就不给出了；要知道的是它最终调用到了<code>talkWithDriver</code>函数；看这个函数的名字就知道，通信过程要交给驱动完成了；这个函数最后通过<code>ioctl</code>系统调用，Client进程陷入内核态，Client调用<code>add</code>方法的线程挂起等待返回；驱动完成一系列的操作之后唤醒Server进程，调用了Server进程本地对象的<code>onTransact</code>函数（实际上由Server端线程池完成）。我们再看Binder本地对象的<code>onTransact</code>方法（这里就是<code>Stub</code>类里面的此方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            reply.writeString(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_add: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">int</span> _arg0;</span><br><span class="line">            _arg0 = data.readInt();</span><br><span class="line">            <span class="keyword">int</span> _arg1;</span><br><span class="line">            _arg1 = data.readInt();</span><br><span class="line">            <span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            reply.writeInt(_result);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Server进程里面，<code>onTransact</code>根据调用号（每个AIDL函数都有一个编号，在跨进程的时候，不会传递函数，而是传递编号指明调用哪个函数）调用相关函数；在这个例子里面，调用了Binder本地对象的<code>add</code>方法；这个方法将结果返回给驱动，驱动唤醒挂起的Client进程里面的线程并将结果返回。于是一次跨进程调用就完成了。</p>
<p>至此，你应该对AIDL这种通信方式里面的各个类以及各个角色有了一定的了解；它总是那么一种固定的模式：一个需要跨进程传递的对象一定继承自IBinder，如果是Binder本地对象，那么一定继承Binder实现IInterface，如果是代理对象，那么就实现了IInterface并持有了IBinder引用；</p>
<p>Proxy与Stub不一样，虽然他们都既是Binder又是IInterface，不同的是Stub采用的是继承（is 关系），Proxy采用的是组合（has 关系）。他们均实现了所有的IInterface函数，不同的是，Stub又使用策略模式调用的是虚函数（待子类实现），而Proxy则使用组合模式。为什么Stub采用继承而Proxy采用组合？事实上，Stub本身is一个IBinder（Binder），它本身就是一个能跨越进程边界传输的对象，所以它得继承IBinder实现transact这个函数从而得到跨越进程的能力（这个能力由驱动赋予）。Proxy类使用组合，是因为他不关心自己是什么，它也不需要跨越进程传输，它只需要拥有这个能力即可，要拥有这个能力，只需要保留一个对IBinder的引用。如果把这个过程做一个类比，在封建社会，Stub好比皇帝，可以号令天下，他生而具有这个权利（不要说宣扬封建迷信。。）如果一个人也想号令天下，可以，“挟天子以令诸侯”。为什么不自己去当皇帝，其一，一般情况没必要，当了皇帝其实限制也蛮多的是不是？我现在既能掌管天下，又能不受约束（Java单继承）；其二，名不正言不顺啊，我本来特么就不是（Binder），你非要我是说不过去，搞不好还会造反。最后呢，如果想当皇帝也可以，那就是asBinder了。在Stub类里面，asBinder返回this，在Proxy里面返回的是持有的组合类IBinder的引用。</p>
<p>再去翻阅系统的ActivityManagerServer的源码，就知道哪一个类是什么角色了：IActivityManager是一个IInterface，它代表远程Service具有什么能力，ActivityManagerNative指的是Binder本地对象（类似AIDL工具生成的Stub类），这个类是抽象类，它的实现是<code>ActivityManagerService</code>；因此对于AMS的最终操作都会进入<code>ActivityManagerService</code>这个真正实现；同时如果仔细观察，ActivityManagerNative.java里面有一个非公开类ActivityManagerProxy, 它代表的就是Binder代理对象；是不是跟AIDL模型一模一样呢？那么<code>ActivityManager</code>是什么？他不过是一个管理类而已，可以看到真正的操作都是转发给<code>ActivityManagerNative</code>进而交给他的实现<code>ActivityManagerService</code> 完成的。</p>
<p>OK，本文就讲到这里了，要深入理解Binder，需要自己下功夫；那些native层以及驱动里面的调用过程，用文章写出来根本没有意义，需要自己去跟踪；接下来你可以：</p>
<ol>
<li>看Android文档，<code>Parcel, IBinder, Binder</code>等涉及到跨进程通信的类；</li>
<li>不依赖AIDL工具，手写远程Service完成跨进程通信</li>
<li>看<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">《Binder设计与实现》</a></li>
<li>看老罗的博客或者书（书结构更清晰）</li>
<li>再看<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">《Binder设计与实现》</a></li>
<li>学习Linux系统相关知识；自己看源码。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>毫不夸张地说，Binder是Android系统中最重要的特性之一；正如其名“粘合剂”所喻，它是系统间各个组件的桥梁，Android系统的开放式设计也很大程度上得益与这种及其方便的跨进程通信机制。</p>
<p>理解Binder对于理解整个Android系统有着非常重要的作用，Android系统的四大组件，AMS，PMS等系统服务无一不与Binder挂钩；如果对Binder不甚了解，那么就很难了解这些系统机制，从而仅仅浮游与表面，不懂Binder你都不好意思说自己会Android开发；要深入Android，Binder是必须迈出的一步。</p>
<p>现在网上有不少资料介绍Binder，个人觉得最好的两篇如下：</p>
<ol>
<li><a href="http://blog.csdn.net/universus/article/details/6211589">Binder设计与实现</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6618363"> Android进程间通信（IPC）机制Binder简要介绍和学习计划</a>系列</li>
</ol>
<p>其中, 《Binder设计与实现》以一种宏观的角度解释了Android系统中的Binder机制，文章如行云流水；如果对于Binder有一定的了解再来看着篇文章，有一种打通任督二脉的感觉；每看一次理解就深一层。老罗的系列文章则从系统源码角度深入分析了Binder的实现细节；具有很大的参考意义；每当对于Binder细节有疑惑，看一看他的书就迎刃而解。</p>
<p>但是遗憾的是，Binder机制终究不是三言两语就能解释清楚的，一上来就扒出源码很可能深陷细节无法自拔，老罗的文章那不是一般的长，如果看不懂强行看很容易睡着；勉强看完还是云里雾里；相反如果直接大谈特谈Binder的设计，那么完全就是不知所云；因此上述两篇文章对于初学者并不友好，本文不会深入源码细节，也不会对于Binder的设计高谈阔论；重点如下：<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="binder" scheme="http://weishu.me/tags/binder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ASCII Art：使用纯文本流程图]]></title>
    <link href="http://weishu.me/2016/01/03/use-pure-ascii-present-graph/"/>
    <id>http://weishu.me/2016/01/03/use-pure-ascii-present-graph/</id>
    <published>2016-01-03T15:17:24.000Z</published>
    <updated>2016-01-05T01:54:35.000Z</updated>
    <content type="html"><![CDATA[<p>我们使用纯文本写代码，有了Markdown又可以使用纯文本写文档，那么对于更直观的信息表达方式——图片，能不能使用纯文本描述呢？</p>
<p>另外，你是否见到过这样的注释：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451834573842.png" alt="ASCII art图像" width="463"></p>
<p>没错，这种逼格极高的ASCII图片注释方式就是我们要讨论的话题。</p>
<a id="more"></a>
<p>使用纯ASCII文本表达图像的方式有什么好处呢？大致有下面几点：</p>
<ol>
<li>装B；没啥好解释的。</li>
<li>可以在代码注释里面用图像充分表达信息；没图say个jb？一图胜千言。迄今为止好像没有什么IDE可以支持直接在代码编辑里面放图片的，在另外一些纯文本的场合也是如此。比如RFC的文档都是txt，里面很多图都是纯ASCII表达。</li>
<li>你以为仅仅是一个纯文本图片这么简单？它可以转换为普通的诸如png格式的真正的图片，还支持SVG矢量图！</li>
</ol>
<p>好了，也许有人说markdown的一些拓展格式不也是支持流程图的吗？它使用的<code>flowchart.js</code> 确实可以很好滴完成一些漂亮的流程图，还有 <code>plantuml</code>和图片DSL语言 <code>dot</code>及它的软件包<code>graphviz</code>等；没错，它们可以使用纯文本表达图像，但它们不是真正的图像；无法嵌入文本代码中，只有在经过渲染之后才能直观地看到图。</p>
<p>又有人说，我知道 <code>asciiflow</code> 这个网站，可以绘制这种流程图，完美解决我的需求。但是，你在手动绘制的时候，是不是要考虑图像的各种细节？大小，放置位置，对齐方式？我们关注的应该是图像本身，而不是如何绘制这个图。markdown为什么这么易用？就是因为我们不用关心文档的格式，不用考虑什么字体，几级标题等等繁琐的格式，可以专注于创作本身。</p>
<p>姑且你已经认同了这种使用ASCII表达图像方式的优点，但是…这种图难道要使用手一个个字符地敲出来吗？？如果真的这么做，简直不要太麻烦！光在前面添加一个空格，后面的所有行都需要改；我们需要一个自动化工具。</p>
<h2 id="Graph::Easy">Graph::Easy</h2><p><strong>Graph::Easy</strong> 就是今天要介绍的主角；它是 <code>perl</code>的一个软件包，可以使用<code>perl</code>代码直接描述图像；当然，我们肯定不会为了画个图专门去学习<code>perl</code>;</p>
<p>这个软件包的强大之处在于: 它定义了一套非常简单易用的专门用来描述图像的DSL（领域专用语言）,我们可以像写代码一样表达我们需要描述的图像（放心，这个语法非常简单）；不用关心图像里面如何布局；这种语言经过处理可以得到ASCII图像，直接放在代码注释中；如果需要还可以转换成png或者矢量图等格式。</p>
<p>先举个简单的例子，感受一下:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ Bonn ] --&gt; [ Koblenz ] --&gt; [ Frankfurt ] --&gt; [ Dresden ]</span></span><br><span class="line"></span><br><span class="line">[ Koblenz ] --&gt; [ Trier ] &#123; origin: Koblenz; offset: 2, 2; &#125;</span><br><span class="line"><span class="code">  --&gt; [ Frankfurt ]</span></span><br></pre></td></tr></table></figure>
<p>这种DSL经过渲染之后得到的ASCII图是这样的：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+------+</span>     <span class="code">+---------+</span>                   <span class="code">+-----------+</span>     <span class="code">+---------+</span></span><br><span class="line">| Bonn | --&gt; | Koblenz | ----------------&gt; | Frankfurt | --&gt; | Dresden |</span><br><span class="line"><span class="code">+------+</span>     <span class="code">+---------+</span>                   <span class="code">+-----------+</span>     <span class="code">+---------+</span></span><br><span class="line"><span class="code">               |                             ^</span></span><br><span class="line"><span class="code">               |                             |</span></span><br><span class="line"><span class="code">               |                             |</span></span><br><span class="line"><span class="code">               |             +-------+       |</span></span><br><span class="line"><span class="code">               +-----------&gt; | Trier | ------+</span></span><br><span class="line"><span class="code">                             +-------+</span></span><br></pre></td></tr></table></figure>
<h2 id="安装">安装</h2><ol>
<li>首先需要安装 <code>graphviz</code> 软件包，可以在<a href="http://www.graphviz.org/" target="_blank" rel="external">graphviz官网</a>下载；mac用户可以 <code>brew install graphviz</code>；其他linux发行版参考<a href="http://www.graphviz.org/" target="_blank" rel="external">官网</a>。</li>
<li>安装<code>perl</code>；mac和linux用户可以略过；一般系统自带，没有的话和windows一起去<a href="http://www.perl.org" target="_blank" rel="external">perl官网</a>查询如何安装; 据说windows下有傻瓜包<code>activeperl</code>；请自行搜索。</li>
<li>安装<code>cpan</code>; 这个是<code>perl</code>的软件包管理，类似<code>npm</code>, <code>pip</code>, <code>apt-get</code>; mac下直接在命令行输入 <code>cpan</code> 命令，一路next即可。其他系统参考<a href="http://www.cpan.org/modules/INSTALL.html" target="_blank" rel="external">cpan官网</a></li>
<li>安装<code>Graph::Easy</code> ;这一步就很容易了；在命令行输入<code>cpan</code>进入cpan shell；然后输入 <code>install Graph::Easy</code>即可。</li>
</ol>
<h2 id="使用">使用</h2><p>使用分为两步</p>
<ol>
<li>使用Graph::Easy DSL的语法描述图像，存为文本文件，比如 <code>simple.txt</code></li>
<li>使用 <code>graph-easy</code> 命令处理这个文件： <code>graph-easy simple.txt</code></li>
</ol>
<p>最简单的使用方式就是这样；当然，<code>Graph::Easy</code> 不仅仅支持自己的DSL语法，它还支持诸如<code>dot</code> 这种较为通用的图像描述语言；可以直接读取<code>dot</code> 格式的输入，产生其他的诸如 ascii，png，svg格式的图像。</p>
<h3 id="语法">语法</h3><h4 id="注释">注释</h4><p>注释用 <code>#</code> 表达；注意 <code>#</code> 之后，一定需要加空格；由于历史原因；Graph::Easy的颜色也使用了 <code>#</code> ，不加空格会解析失败。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##############################################################</span><br><span class="line"># 合法的注释</span><br><span class="line"></span><br><span class="line">##############################################################</span><br><span class="line">#有问题的注释</span><br><span class="line"></span><br><span class="line">node &#123; label: \#5; &#125;	  # 注意转义！</span><br><span class="line">edge &#123; color: #aabbcc; &#125;  # 可以使用颜色值</span><br></pre></td></tr></table></figure></p>
<h4 id="空格">空格</h4><p>空格通常没有什么影响，多个空字符会合并成一个，换行的空字符会忽略；下面的表述是等价的。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[A]-&gt;[B][C]-&gt;[D]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ A ] -&gt; [ B ]</span></span><br><span class="line"><span class="attribute">[ C ] -&gt; [ D ]</span></span><br></pre></td></tr></table></figure>
<h4 id="节点(Node)">节点(Node)</h4><p>用中括号括起来的就是节点，我们简单可以理解为一些形状；比如流程图里面的矩形，圆等；</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ Single node ]</span></span><br><span class="line"><span class="attribute">[ Node A ] --&gt; [ Node B ]</span></span><br></pre></td></tr></table></figure>
<p>可以用逗号分割多个节点：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ A ], [ B ], [ C ] --&gt; [ D ]</span></span><br></pre></td></tr></table></figure>
<p>上面的代码图像如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+---+</span>     <span class="code">+---+</span>     <span class="code">+---+</span></span><br><span class="line">| A | --&gt; | D | &lt;-- | C |</span><br><span class="line"><span class="code">+---+</span>     <span class="code">+---+</span>     <span class="code">+---+</span></span><br><span class="line"><span class="code">            ^</span></span><br><span class="line"><span class="code">            |</span></span><br><span class="line"><span class="code">            |</span></span><br><span class="line"><span class="code">          +---+</span></span><br><span class="line"><span class="code">          | B |</span></span><br><span class="line"><span class="code">          +---+</span></span><br></pre></td></tr></table></figure>
<h4 id="边(Edges)">边(Edges)</h4><p>将节点连接起来的就是边；Graph::Easy 的DSL支持这几种风格的边：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt;              实线</span><br><span class="line">=&gt;              双实线</span><br><span class="line">.&gt;              点线</span><br><span class="line">~&gt;              波浪线</span><br><span class="line"><span class="bullet">- </span>&gt;             虚线</span><br><span class="line">.-&gt;             点虚线</span><br><span class="line">..-&gt;            dot-dot-dash</span><br><span class="line"><span class="header">= &gt;             double-dash</span></span><br></pre></td></tr></table></figure></p>
<p>可以给边加标签，如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ client ] - request -&gt; [ server ]</span></span><br><span class="line"><span class="code">```</span> </span><br><span class="line">结果如下：</span><br><span class="line"></span><br><span class="line"><span class="code">```</span>asciidoc</span><br><span class="line"><span class="code">+--------+</span>  request   <span class="code">+--------+</span></span><br><span class="line">| client | ---------&gt; | server |</span><br><span class="line"><span class="code">+--------+</span>            <span class="code">+--------+</span></span><br></pre></td></tr></table></figure>
<h4 id="属性(Attributes)">属性(Attributes)</h4><p>可以给节点和边添加属性；比如标签，方向等；使用大括号 <code>{}</code>表示，里面的内容类似css，<code>attribute: value</code>。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ "Monitor Size" ] --&gt; &#123; label: 21"; &#125; [ Big ] &#123; label: "Huge"; &#125;</span><br></pre></td></tr></table></figure>
<p>上面的DSL输入如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------------+</span>  21"   <span class="code">+------+</span></span><br><span class="line">| "Monitor Size" | -----&gt; | Huge |</span><br><span class="line"><span class="code">+----------------+</span>        <span class="code">+------+</span></span><br></pre></td></tr></table></figure></p>
<p>Graph::Easy提供了非常多的属性; 另外，<code>Graph::Easy</code>的<a href="http://bloodgate.com/perl/graph/manual/index.html" target="_blank" rel="external">文档</a>非常详细，建议通读一遍；了解其中的原理和细节，对于绘图和布局有巨大帮助。目前正在翻译，文档<a href="https://www.gitbook.com/book/weishu/graph-easy-cn/details" target="_blank" rel="external">地址</a>.</p>
<h2 id="实例">实例</h2><p>语法是不是非常简单？有了这些知识，我们就可以建立自己的流程图了；Have a try！来个MVP模式的示意图试试～</p>
<ol>
<li>新建文件，<code>vi mvp.txt</code>; 输入以下代码：</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">[ View ] &#123;rows:3&#125; - Parse calls to -&gt; [ Presenter ] &#123;flow: south; rows: 3&#125; - Manipulates -&gt; [ Model ]</span></span><br><span class="line"><span class="attribute">[ Presenter ] - Updates -&gt; [ View ]</span></span><br></pre></td></tr></table></figure>
<ol>
<li>保存然后退出；命令行执行 <code>graph-easy mvp.txt</code>, 输入效果如下：</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+------+</span>  Parse calls to   <span class="code">+--------------+</span></span><br><span class="line">|      | ----------------&gt; |              |</span><br><span class="line">| View |                   |  Presenter   |</span><br><span class="line">|      |  Updates          |              |</span><br><span class="line">|      | &lt;---------------- |              |</span><br><span class="line"><span class="code">+------+</span>                   <span class="code">+--------------+</span></span><br><span class="line"><span class="code">                             |</span></span><br><span class="line"><span class="code">                             | Manipulates</span></span><br><span class="line"><span class="code">                             v</span></span><br><span class="line"><span class="code">                           +--------------+</span></span><br><span class="line"><span class="code">                           |    Model     |</span></span><br><span class="line"><span class="code">                           +--------------+</span></span><br></pre></td></tr></table></figure>
<p>两行代码就搞定了！自动对齐，调整位置，箭头，标签等等；我们完全不用管具体图形应该如何绘制，注意力集中在描述图像本身；还在等什么！赶紧试一试吧！！</p>
<p>原文：<a href="http://weishu.me/2016/01/03/use-pure-ascii-present-graph/">http://weishu.me/2016/01/03/use-pure-ascii-present-graph/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们使用纯文本写代码，有了Markdown又可以使用纯文本写文档，那么对于更直观的信息表达方式——图片，能不能使用纯文本描述呢？</p>
<p>另外，你是否见到过这样的注释：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451834573842.png" alt="ASCII art图像" width="463"/></p>
<p>没错，这种逼格极高的ASCII图片注释方式就是我们要讨论的话题。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[把Sublime添加到Mac右键菜单]]></title>
    <link href="http://weishu.me/2015/12/31/add-sublime-editor-to-finder-context-menu/"/>
    <id>http://weishu.me/2015/12/31/add-sublime-editor-to-finder-context-menu/</id>
    <published>2015-12-31T06:53:20.000Z</published>
    <updated>2015-12-31T07:48:55.000Z</updated>
    <content type="html"><![CDATA[<p>虽然大部分的时候是使用命令行，但是有些时候我们需要在<code>Finder</code>里面编辑某些文件的时候，如果还是拘泥于这样，就必须打开 <code>iTerm</code> （幸好有Profile可以一键打开终端）切换目录，编辑；这时候，类似Windows系统的右键菜单就比较方便了。</p>
<p>如果Mac系统识别出这是一个文本文件，右键菜单的 <strong>打开方式</strong> 可能还有点用，如果识别不出来，那么手动选择应用程序就比较麻烦了：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545353007.png" width="385"></p>
<p>其实Mac系统的 <strong>AutoMator</strong> 是可以完成这个功能的；接下来说一下操作步骤。</p>
<a id="more"></a>
<ul>
<li><p>打开 <code>Automator</code> 这个程序（可以使用Spotlight或者Alfred直接搜索），在弹出的菜单中选择 <strong>服务</strong><br><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545516628.png" width="545"></p>
</li>
<li><p>在左上角的搜索框搜索 <code>Finder</code> 然后在结果里面选择 <code>打开Finder项目</code><br>；然后把它拖到右边：</p>
</li>
</ul>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545618554.png" width="832"></p>
<ul>
<li>拖到右边之后，设置打开方式为「Sublime Text 2」，上面设定为“服务”收到选定的「文件或文件夹」位于「Finder」；</li>
</ul>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545743958.png" width="616"></p>
<ul>
<li>然后保存项目 (Cmd + S), 写上这个操作的名字，比如 <em>Open in Sublime Text</em></li>
</ul>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545891571.png" width="390"></p>
<p>这时候，进入 <code>Finder</code> 选择一个文件或者文件夹，点击右键：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545999524.png" width="228"></p>
<p>OK，大功告成！如果想添加别的编辑器，按照类似的操作即可。</p>
<p>但是，还有几个问题说明一下：</p>
<ul>
<li>右键菜单没有，出现在<strong>服务</strong>二级菜单</li>
</ul>
<p>有的童鞋按照这一步设置完毕之后，发现并没有直接在右键菜单出现，而是出现在服务二级菜单！这样每次都需要多点击一次，很不爽！如下图：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512%2F1451546296324.png" width="443"></p>
<p>这时候，其实是服务菜单里面内容太多了，因此Mac系统自动把菜单收缩到了二级菜单。可以到「系统偏好设置…」-「键盘」-「服务」中去掉不需要的选项。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451546545636.png" width="620"></p>
<ul>
<li>如何删除</li>
</ul>
<p>如果弄错了，想删除掉；直接去 <code>~/Library/Services</code> 删除对应的目录即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然大部分的时候是使用命令行，但是有些时候我们需要在<code>Finder</code>里面编辑某些文件的时候，如果还是拘泥于这样，就必须打开 <code>iTerm</code> （幸好有Profile可以一键打开终端）切换目录，编辑；这时候，类似Windows系统的右键菜单就比较方便了。</p>
<p>如果Mac系统识别出这是一个文本文件，右键菜单的 <strong>打开方式</strong> 可能还有点用，如果识别不出来，那么手动选择应用程序就比较麻烦了：</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512/1451545353007.png" width="385"/></p>
<p>其实Mac系统的 <strong>AutoMator</strong> 是可以完成这个功能的；接下来说一下操作步骤。</p>]]>
    
    </summary>
    
      <category term="mac" scheme="http://weishu.me/tags/mac/"/>
    
      <category term="sublime" scheme="http://weishu.me/tags/sublime/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio你不知道的调试技巧]]></title>
    <link href="http://weishu.me/2015/12/21/android-studio-debug-tips-you-may-not-know/"/>
    <id>http://weishu.me/2015/12/21/android-studio-debug-tips-you-may-not-know/</id>
    <published>2015-12-21T12:39:03.000Z</published>
    <updated>2015-12-23T03:03:55.000Z</updated>
    <content type="html"><![CDATA[<p>写代码不可避免有Bug，通常情况下除了日志最直接的调试手段就是debug；那么你的调试技术停留在哪一阶段呢？仅仅是下个断点单步执行吗？或者你知道 <code>Evaluate Expression</code>, 知道条件断点；可是你听说过日志断点吗，<code>Method Breakpoint</code>, <code>Exception Breakpoint</code> 呢？还有高大上的 <code>Field Watchpoint</code> ?</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450701212799.png" width="338" alt="几种不同的断点"></p>
<p>你有关注过Android Studio旁边断点的区别吗？比如上图三个断点有什么不同？且听我一一道来。<br><a id="more"></a></p>
<h2 id="调试基础">调试基础</h2><p>一般来说我们有两种办法调试一个debuggable的apk；其一是下好断点，然后用debug模式编译安装这个app；其二是 <code>attach process</code>，在Android Studio里面就是这么一个对话框：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450697931900.png" width="273" alt="Attach Process"></p>
<p>第二种方法比较常用，我们可以在启动apk之后，直接下断点，然后attach process到制定进程，条件触发之后就可以直接进入调试模式。</p>
<p>其他的一些单步执行，<code>step into</code>, <code>step out</code>, <code>force step into</code> 等就不提了；基本的跟踪手段。</p>
<p>还是提一下，下断点最简单的办法，是在代码编辑器的左侧，行号右边鼠标点击一下即可。</p>
<h2 id="Evaluate_Expression">Evaluate Expression</h2><p>这个功能非常实用，可以在断点处直接进入一个求值环境，在这里你可以执行任何你感兴趣的表达式；如下图：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450698259155.png" width="524" alt="Evaluate Expression"></p>
<p>比如在断点处有一个对象<code>object</code>，如果你要查看它的某个属性很简单，在Debug窗口就能看到，但是如果你想要执行它的某个方法看看结果是什么呢？借助这个可以实现。当然它的功能远不止这么多，相当于直接进入了一个 <code>REPL</code>环境，非常实用。忘了说了，快捷键 <code>Alt + F8</code> :P</p>
<h2 id="条件断点">条件断点</h2><p>假设你的断点在一个列表的循环里面，可是你只对这个列表的某一个元素感兴趣，只想在遇到这个元素的时候才断下来；你是一直人肉 <code>F9</code> 直到满足条件吗？条件断点就是满足这种需求的，顾名思义，在特定条件下的断点。使用起来也非常简单，在你的断点上鼠标右键会出现一个小窗口，写上条件即可。</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450698641184.png" width="465" alt="条件断点"></p>
<h2 id="日志断点">日志断点</h2><p>很多时候我们调试的时候更多的是打印日志定位异常代码，缩小范围之后再使用断点解决问题；所以经常做的事情就是在代码里面添加日志信息，输出函数参数，返回信息，输出我们感兴趣的变量信息等。</p>
<p>但是这么做一个问题就是，我们添加了日志代码需要重新编译；在没有 <code>Instant Run</code> 之前的黑暗时代这么做是非常痛苦的，每次编译少则几十秒，多则几分钟；这样无意义的等待简直就是折磨；其实，除了热部署工具，我们还可以使用日志断点解决这个问题。</p>
<p>首先我们在想要输出信息的地方下一个断点；然后右键这个断点，在出现的设置框里面把这个断点的 <code>suspend</code> 属性设置为 <code>False</code> ，这样虽然叫做“断点”，但是并不会真正断下来；然后，我们在 <code>log message</code> 里面填上我们想要输出的日志信息。如下图(注意标红位置）：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450699187057.png" width="591" alt="日志断点"></p>
<p>这样，每次代码执行到这个断点的位置，这个可爱的断点并不会使我们的程序停下来，而是输出我们告诉它的日志信息，然后继续执行；非常方便。</p>
<h2 id="方法断点">方法断点</h2><p>传统的调试方式是以行为单位的，所谓单步调试；但是很多时候我们关心的是某个函数的参数，返回值；（回想一下我们使用日志的时候打印的最多的信息难道不是函数的参数和返回值吗？）使用方法断点，我们可以在函数级别进行调试；如果经常跳进跳出函数或者只对某个函数的参数感兴趣，这种类型的断点非常实用。具体使用方法有两种方式；最简单的是在你感兴趣的方法头那一行打上断点，这时候你会发现断点图标有点不一样，这就是方法断点了，如下图：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450699584560.png" width="503" alt="方法断点"></p>
<p>另外一种方式是通过<em>断点设置窗口</em>, 后面介绍。</p>
<h2 id="异常断点">异常断点</h2><p>在有些情况下，我们只对某些特定的异常感兴趣，或者我们只对异常感兴趣；我们希望只要程序发生异常程序就能断下来；这好像保存现场一样，只要发生命案了（异常），第一时间保存现场，这样什么指纹之类的线索就会清晰很多，坏蛋就算想逃也是插翅难飞啊。</p>
<p>Android Studio给了我们这个能力！那就是<strong>异常断点</strong>!可以在特定异常发生的时候，直接让整个程序断下来；如果你对所有异常感兴趣，直接 <code>Throwable</code> 即可。</p>
<p>具体做法是，进入 <code>Run -&gt; View BreakPoints</code> 或者使用快捷键打开断点设置窗口；如下图：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450700136670.png" width="273" alt="断点设置窗口"></p>
<p>点击左上角的 ➕ ，会出现一个选择框；选择<code>Exception Breakpoint</code>；然后会出现一个对话框，选择你感兴趣的异常：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450700226518.png" width="526" alt="异常断点"></p>
<h2 id="Field_WatchPoint">Field WatchPoint</h2><p>在上面我们添加异常断点的时候，点击加号的时候，有四个选项；第一个就是我们前面所说的第二种方法断点的添加方式，第三个是异常断点，那么第二个 <strong>Field WatchPoint</strong> 是干什么的呢？</p>
<p>有没有这样一种场景：你发现某个值莫名其妙滴不知道什么时候被谁给修改了，罪魁祸首是谁？Java虽然是值传递，但是引用也可以是值；对象全部存放在堆上面，而堆是被所有线程共享的，因此在非常复杂的场景下，你根本不知道这些共享变量被谁修改了，这样非常危险；在多线程环境下，不变性是一个很重要的特性，我们看到高并发的语言诸如 <code>Erlang</code>, <code>Scala</code> 对于这种不变性都有着某种程度的支持。</p>
<p>好吧，扯远了；那么我们怎么揪出这个修改我们值的捣蛋鬼呢？那就是这个 <strong>Field WatchPoint</strong>的功能了；使用它我们可以在某个<strong>Field</strong>被访问或者修改的时候让程序断下来；完美解决这个问题。</p>
<p>下断点的方式和方法断点类似，也有两种；第一种是直接在某个字段的声明处下断点，这时候断点图标会改变，如下图：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450700886216.png" width="354" alt="Field WatchPoint"></p>
<p>右键这个断点我们可以进行一些设置，比如默认是被修改的时候断下来，你也可以改为每次访问这个字段就断下来。</p>
<p>另外一种方式是 <code>Run -&gt; View BreakPoint</code> 打开设置，与异常断点类似。</p>
<h2 id="远不止这么多">远不止这么多</h2><p>上面介绍了这么多给力的功能，其实还有很多细节；打开断点设置窗口（Run -&gt; View Breakpoint`):</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450701055366.png" width="873"></p>
<p>我们可以对<strong>感兴趣的类，感兴趣的某个特定对象</strong>下断点，也可以设置断点的次数，还能使断点在特定的线程才断下来；这些细节就不详细介绍了，大家自己去发掘！</p>
<p>Have Fun!!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写代码不可避免有Bug，通常情况下除了日志最直接的调试手段就是debug；那么你的调试技术停留在哪一阶段呢？仅仅是下个断点单步执行吗？或者你知道 <code>Evaluate Expression</code>, 知道条件断点；可是你听说过日志断点吗，<code>Method Breakpoint</code>, <code>Exception Breakpoint</code> 呢？还有高大上的 <code>Field Watchpoint</code> ?</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450701212799.png" width="338" alt="几种不同的断点"/></p>
<p>你有关注过Android Studio旁边断点的区别吗？比如上图三个断点有什么不同？且听我一一道来。<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="实用技巧" scheme="http://weishu.me/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio你不知道的快捷键(三)]]></title>
    <link href="http://weishu.me/2015/12/17/shortcut-of-android-studio-you-may-not-know-3/"/>
    <id>http://weishu.me/2015/12/17/shortcut-of-android-studio-you-may-not-know-3/</id>
    <published>2015-12-17T02:49:19.000Z</published>
    <updated>2015-12-18T06:12:05.000Z</updated>
    <content type="html"><![CDATA[<p>本文将继续介绍一些非常实用的但是你可能不知道的快捷键；没看过前两篇的可以移步：</p>
<ol>
<li><a href="http://www.tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/" target="_blank" rel="external">Android Studio你不知道的快捷键(一)</a></li>
<li><a href="http://www.tianweishu.com/2015/12/12/shortcut-of-android-studio-you-may-not-know-2/" target="_blank" rel="external">Android Studio你不知道的快捷键(二)</a></li>
</ol>
<h1 id="Select_In-">Select In..</h1><p>说实话，想不出一个比较好的翻译 :P 干脆使用英文吧。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-1.gif" alt="Select In.." width="449"></p>
<p>有没有这样的场景：你在Android Studio打开了一个图片文件（或者别的文件），想在资源浏览器里面查看这图片；在Eclipse里面我想大部分的人是<code>Alt + Enter</code>进入文件属性复制地址，然后在系统资源管理器里面打开；或者装一个EasyExplore插件。在Android Studio里面，这是内建支持的！而且还不止如此！比如你想看看某个文件在包的哪个目录，通常是不是点击Project View上面的那个小圆坐标；用这个快捷键鼠标就能搞定。<br><a id="more"></a><br>快捷键: <code>Alt + F1</code></p>
<p>弹出的菜单有一系列的选项；按对应的数字就可以选择；其他的菜单有什么功能可以自己尝试一下。</p>
<h1 id="拓展选择">拓展选择</h1><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-2.gif" alt="拓展选择" width="357"></p>
<p>这个功能应该很多人都知道；但还是说明一下，因为跟下面两个功能跟这个结合起来才有威力。这个功能太强大了，自己去按几遍就能想到很多使用场景了；我相信有了这个功能，你使用鼠标的机会会少很多。</p>
<ul>
<li>Mac: <code>Alt + up/down</code></li>
<li>Win/Linux: <code>ctrl + w / ctrl + shift + w</code></li>
</ul>
<h1 id="Surround_With-">Surround With..</h1><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-3.gif" alt="Surround With" width="299"></p>
<p>如果你想把一段代码使用<code>if</code>语句包起来；又或者使用<code>try</code>包围一段可能有运行时异常的代码，你会怎么干？</p>
<p>首先用光标定位到代码块开头，写上 <code>try {</code>然后，光标代码块末尾加上<code>} catch (XXXRuntimeException e) {// todo}</code>？可以试试这个快捷键。</p>
<ul>
<li>Mac: <code>cmd + alt + t</code></li>
<li>Win/Linux: <code>ctrl + alt + t</code></li>
</ul>
<p>可以使用上面的拓展选择选择你需要的代码块，然后使用这个功能<em>Surround With</em>；如果你什么都不选择的话，那么默认选择的是光标所在行。</p>
<h1 id="Unwrap/Remove">Unwrap/Remove</h1><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-4.gif" alt="Unwrap" width="546"></p>
<p>这个功能跟上面提到的是一对，有了<em>Surround With</em>自然就有<em>Unsurround With</em>;使用情况没有上面那个那么多，但是好歹一对，一起介绍吧。</p>
<h1 id="高亮某东西">高亮某东西</h1><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-5.gif" alt="highlight something" width="198"></p>
<p>有时候看代码的时候，看到某个变量想知道哪里使用了它；你还在用肉眼查找吗？或者你杀鸡用牛刀<code>Find Usgae</code>？其实你的需求就是把这个变量全部给我打个标签，我想直观的知道它在哪。</p>
<ul>
<li>Mac: <code>cmd + shift + F7</code></li>
<li>Win/Linux: <code>ctrl + shift + F7</code></li>
</ul>
<p>这个键功能远不止这个！</p>
<ol>
<li>如果你高亮<code>return</code>或者<code>throw</code>，那么会把这个方法所有的返回点高亮出来！</li>
<li>高亮某个类的<code>extends</code>或者<code>implements</code>会把这个类Override的方法高亮出来</li>
<li>高亮<code>import</code>会把使用的地方显示出来</li>
</ol>
<p>如果不想要高亮了，按下Esc就行。</p>
<h1 id="显示方法调用树">显示方法调用树</h1><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-6.gif" alt="方法调用树" width="451"></p>
<p>在看源码的时候，你还是使用<code>alt + F7</code>和<code>ctrl + B</code>在各个类之间来回穿梭吗？其实好多时候你就是想知道这个调用结构是怎么样的而已；谁是怎么一步一步滴调用谁的；这个快捷键会给你一个调用树。有了这个大菊观，继续探讨就很容易了。</p>
<p>快捷键: <code>ctrl + alt + h</code></p>
<h1 id="万能快捷键">万能快捷键</h1><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-7.gif" alt="万能快捷键" width="500"></p>
<p>记得之前提到过一个<em>万能重构键</em>, 有关重构的一切操作都可通过它完成。那么Android Studio这么快捷键，这么多功能，臣妾怎么可能都记住！要是有万能钥匙就好了！That’s it!</p>
<p>使用这个快捷键，你想到什么功能，打开它搜索就可以了；打个比方，我想看看Java的<code>for each</code>循环和普通的<code>for</code>循环底层是不是同一个实现;那么我就需要看虚拟机字节码了；我记得有这个功能但是不知道快捷键是啥；OK，<code>Cmd + shift + A</code>，输入<code>bytecode</code>:</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1450323104893.png" width="423"></p>
<p>PS:(我用的Intellij IDEA，Android Studio没有集成bytecode功能，可能搜索不到）</p>
<p>好了，其实所有的快捷键的功能都可以用这个搜索到～～实在记不起来也就用万能键吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文将继续介绍一些非常实用的但是你可能不知道的快捷键；没看过前两篇的可以移步：</p>
<ol>
<li><a href="http://www.tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/">Android Studio你不知道的快捷键(一)</a></li>
<li><a href="http://www.tianweishu.com/2015/12/12/shortcut-of-android-studio-you-may-not-know-2/">Android Studio你不知道的快捷键(二)</a></li>
</ol>
<h1 id="Select_In-">Select In..</h1><p>说实话，想不出一个比较好的翻译 :P 干脆使用英文吧。</p>
<p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-17-1.gif" alt="Select In.." width="449"/></p>
<p>有没有这样的场景：你在Android Studio打开了一个图片文件（或者别的文件），想在资源浏览器里面查看这图片；在Eclipse里面我想大部分的人是<code>Alt + Enter</code>进入文件属性复制地址，然后在系统资源管理器里面打开；或者装一个EasyExplore插件。在Android Studio里面，这是内建支持的！而且还不止如此！比如你想看看某个文件在包的哪个目录，通常是不是点击Project View上面的那个小圆坐标；用这个快捷键鼠标就能搞定。<br>]]>
    
    </summary>
    
      <category term="实用技巧" scheme="http://weishu.me/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio你不知道的快捷键(二)]]></title>
    <link href="http://weishu.me/2015/12/12/shortcut-of-android-studio-you-may-not-know-2/"/>
    <id>http://weishu.me/2015/12/12/shortcut-of-android-studio-you-may-not-know-2/</id>
    <published>2015-12-12T01:51:53.000Z</published>
    <updated>2015-12-12T01:55:41.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="http://tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/" target="_blank" rel="external">Android Studio你不知道的快捷键(一)</a>里面，主要讲述了一些窗口操作的快捷键还有补全参数提示等，这一篇会分享一些代码代码编辑的快捷键。(<strong>默认Keymap</strong>如<a href="http://tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/" target="_blank" rel="external">上文</a>)</p>
<h2 id="自动生成变量">自动生成变量</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-1.gif" alt="自动生成变量"></p>
<p>作为一门静态类型语言，Java是有一定的类型推导能力的；那么你是否经常书写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String testStr = <span class="string">"testStr"</span>;</span><br><span class="line">List&lt;String&gt; testStrings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure></p>
<p>其实大可不必写那些恼火的类型声明的，一看就知道<code>testStr, testStrings</code>就知道是什么类型，再这么干不就是废话么！好在IDEA给了我们这个能力。尝试一下这个快捷键吧，会给你惊喜。<br><a id="more"></a></p>
<ul>
<li>Mac: <code>Cmd + Alt + V</code></li>
<li>Win/Linux: <code>Ctrl + Alt + V</code></li>
</ul>
<p>有的童鞋可能会问了：我使用<code>ArrayList, HashMap</code>的时候，习惯类型声明为<code>List,Map</code>等接口，这个自动生成的类型声明还是具体的实现啊，怎么办？这一点IDE已经帮你想到了，试试<code>shift + tab</code>,他会给你一个可以选择的类型列表～</p>
<h2 id="自动提取参数">自动提取参数</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-2.gif" alt="自动提取参数"></p>
<p>有时候你正在写一个方法的时候发现。哎哟，这个变量最好是当作参数传递进来啊；要做成这么一件事，你必须把这个方法内部所有使用这个局部变量的地方替换，把所有调用这个函数的地方添加参数，繁琐至极！好了有了这个你可以随便玩了：</p>
<ul>
<li>Mac: <code>Cmd + Alt + P</code></li>
<li>Win/Linux: <code>Ctrl + Alt + P</code></li>
</ul>
<p>当然，如果你想保留原来的方法，只是搞一个参数不同的方法（重载）出来，可以在弹出的那个对话框里面打勾。</p>
<h2 id="自动提取方法">自动提取方法</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-3.gif" alt="自动提取方法"></p>
<p>写代码的时候是否会发现不知不觉的这个方法已经太长了，适合分解然后提取出一个个子方法；或者是重构的时候看到一个一两千的函数，你是不是头都大了？一般情况下，我们都是把要提取的代码copy出来，然后写一个方法（还要什么该死的方法签名）然后把这段代码复制进来；其实这个过程是机械的，完全可以由IDE完成：</p>
<ul>
<li>Mac: <code>Cmd + Alt + M</code></li>
<li>Win/Linux: <code>Ctrl + Alt + M</code></li>
</ul>
<p>如果想改变方法的签名，在对话框里面选择你需要的就可以了～</p>
<blockquote>
<p>上面提到了三个快捷键其实是比较类似的，如何记忆呢？</p>
<ol>
<li>首先组合键都是<code>Cmd/Ctrl + Alt</code></li>
<li>然后提取变量<strong>V</strong>ariable=<strong>V</strong>，参数<strong>P</strong>arameters=<strong>P</strong>，方法<strong>M</strong>ethod=<strong>M</strong></li>
</ol>
</blockquote>
<h2 id="内联变量/参数/方法">内联变量/参数/方法</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-4.gif" alt="内联"></p>
<p>好了学会了上面那几个快捷键，万一玩high了，比如提取了太多的方法，想“弄回去”，该怎么办呢？这个操作叫他<code>Inline..</code>：</p>
<ul>
<li>Mac: <code>Cmd + Alt + N</code></li>
<li>Win/Linux: <code>Ctrl + Alt + M</code></li>
</ul>
<p>上面那个图只是参考，其实不仅可以作用于变量，还可以是方法/参数，个人觉得方法inline比较有用。</p>
<h2 id="万能重构键">万能重构键</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-5.png" alt="万能重构键"></p>
<p>静态类型语言重构起来相对容易的，但是通常修改一个地方会牵扯到很多别的地方，我们只有一处一处找到这些编译错误然后手动修复。其实有好多工作是可以自动完成的，比如删除某个方法；先确认有没有人调用（Alt ＋ F7），没有的话把方法体删了，有的话去看看调用的地方再决定怎么办。</p>
<p>但是重构的操作实在是太多了！我们没有办法也没有必要一个个记住，知道这个快捷键即可，我叫他<em>万能重构键</em>:</p>
<ul>
<li>Mac : <code>Ctrl + T</code></li>
<li>Win/Linux: <code>Ctrl + Alt + Shift + T</code></li>
</ul>
<p>在Win/Linux上可以考虑把这个快捷键改一下键，一下按四个键臣妾很难做到啊。。</p>
<p>这个重构菜单每一个功能都可以自己去尝试一下，使用之后不好用你来打我。</p>
<h2 id="重命名">重命名</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-6.gif" alt="重命名"></p>
<p>好了介绍了那么多貌似很高端的玩意，来个大部分人都知道的吧。有时候你发现有个变量名字取得有问题，或者没文化的队友/自己单词拼错了咋办？需要把所有用到这个变量的地方重新命名，小case！</p>
<p>快捷键：<code>shift + F6</code></p>
<p>OK, 这一期的分享就到这里。如果没有看过上一篇的可以移步：<br><a href="http://tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/" target="_blank" rel="external">Android Studio你不知道的快捷键(一)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="http://tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/">Android Studio你不知道的快捷键(一)</a>里面，主要讲述了一些窗口操作的快捷键还有补全参数提示等，这一篇会分享一些代码代码编辑的快捷键。(<strong>默认Keymap</strong>如<a href="http://tianweishu.com/2015/12/11/shortcut-of-android-studio-you-may-not-know/">上文</a>)</p>
<h2 id="自动生成变量">自动生成变量</h2><p><img src="http://7xp3xc.com1.z0.glb.clouddn.com/201512-12-1.gif" alt="自动生成变量" /></p>
<p>作为一门静态类型语言，Java是有一定的类型推导能力的；那么你是否经常书写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String testStr = <span class="string">"testStr"</span>;</span><br><span class="line">List&lt;String&gt; testStrings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure></p>
<p>其实大可不必写那些恼火的类型声明的，一看就知道<code>testStr, testStrings</code>就知道是什么类型，再这么干不就是废话么！好在IDEA给了我们这个能力。尝试一下这个快捷键吧，会给你惊喜。<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="实用技巧" scheme="http://weishu.me/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio你不知道的快捷键(一)]]></title>
    <link href="http://weishu.me/2015/12/11/shortcut-of-android-studio-you-may-not-know/"/>
    <id>http://weishu.me/2015/12/11/shortcut-of-android-studio-you-may-not-know/</id>
    <published>2015-12-11T05:42:33.000Z</published>
    <updated>2015-12-11T05:59:38.000Z</updated>
    <content type="html"><![CDATA[<p>一般来说键盘用的越多鼠标用的越少，那么写起代码来效率就越高；常见的快捷键想必大家都已经掌握，接下来我就分享一些你可能不知道的但确非常实用的快捷键。</p>
<blockquote>
<p>下文所有快捷键基于如下keymap<br>Windows: Default<br>Linux: Default<br>OSX: Mac OSX 10.5+</p>
</blockquote>
<h2 id="自动补全的时候是Enter还是Tab？">自动补全的时候是Enter还是Tab？</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-1.gif" alt="自动补全enter和tab区别" width="252"><br>在使用自动补全的时候<code>Enter</code>和<code>Tab</code>的行为还是有一些细微的区别的：<br><a id="more"></a></p>
<ol>
<li>使用<code>Enter</code>会补全你选择的语句</li>
<li>使用<code>Tab</code>的话，会替换掉你之前在这里的内容（删除后面的语句直到遇到点号，逗号，分号）</li>
</ol>
<p>这种情况我们还是会经常遇到的，比如要替换一个资源的ID（R.id.a_xxx_xxx)，想必大多数人都是先选择<code>a.xxx_xxx</code>删除，然后输入新的内容，或者相反；其实这时候，用<code>Tab</code>才是最优雅的方式。</p>
<p>快捷键：（在补全的时候)<strong><code>Enter/Tab</code></strong></p>
<h2 id="返回编辑器窗口">返回编辑器窗口</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-2.gif" alt="返回编辑器窗口" width="550"><br>正在写代码的时候，很多操作会让焦点脱离编辑器；比如<em>Find Usage</em>, <em>Logcat</em>, 切换到项目结构视图，类型继承树等；如果视图切换了如何快速切回编辑器继续写代码呢？简单的鼠标点一下编辑器就可以了，但其实还有两种选择：</p>
<ol>
<li><code>Esc</code>: 让编辑器窗口获取焦点，这时候就可以输入代码了</li>
<li><code>Shift + Esc</code>: 这个会让编辑器获取焦点，并且顺手帮你把刚刚打开的窗口关闭了。</li>
</ol>
<p>个人喜欢第二种；Find Usage完毕了，<code>Shift + Esc</code>, 优雅～</p>
<ol>
<li><code>Esc</code>: 返回编辑器</li>
<li><code>Shift + Esc</code>: 返回编辑器并关闭当前窗口</li>
</ol>
<h2 id="返回上次打开的工具窗口">返回上次打开的工具窗口</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-3.gif" alt="返回最后打开的工具窗口" width="495"><br>接上面那个功能，如果你<code>Shift + Esc</code> 写了一会儿代码，发现又需要打开刚刚的窗口怎么办？这种场景通常发生在<em>Logcat</em>这个Tol Window上，看完了日志，写代码，写完代码看日志；如何快速切换？</p>
<p>快捷键：<code>F12</code></p>
<h2 id="快捷打开窗口">快捷打开窗口</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-4.gif" alt="使用数字快捷打开窗口" width="567"><br>有木有发现有的窗口上面有个数字？这样的窗口（工具窗）我们可以快捷打开！</p>
<ul>
<li>Mac: <code>Cmd + 数字</code></li>
<li>windows/Linux: <code>Alt + 数字</code></li>
</ul>
<h2 id="任意窗口切换">任意窗口切换</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-5.gif" alt="窗口切换" width="532"><br>上面的切换还是无法满足你的要求？记得Mac的<code>Cmd + Tab</code>，Windows的<code>Alt/Win + Tab</code>吗？Android Studio也有这个类似的功能，可以让你切换到任意窗口！</p>
<p>在这个切换窗口打开的时候，你可以直接按数字切换到对应的工具窗口，或者输入字母搜索右边的编辑器窗口，如果你需要关闭某个窗口，在上面按<code>BackSpace</code>即可。</p>
<p>快捷键：<code>Ctrl + Tab</code></p>
<h2 id="隐藏所有窗口">隐藏所有窗口</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-6.gif" alt="隐藏所有窗口" width="566"><br>好了学了那么多打开窗口的技能，如果你想关闭那些乱七八糟的窗口，安安静静写代码应该怎么办？</p>
<ul>
<li>Mac: <code>CMD + Shift + F12</code></li>
<li>windows/Linux: <code>Ctrl + shift + F12</code></li>
</ul>
<p>如果需要恢复所有窗口，再按一次这个快捷键即可。</p>
<h2 id="参数提示">参数提示</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-7.gif" alt="参数提示" width="472"><br>这个功能估计很多人知道了，但是还是提一下。在自动补全以后，如果某个方法参数超级长，你不知道参数是什么怎么办？可以试试这个。</p>
<ul>
<li>Mac: <code>CMD + P</code></li>
<li>win/Linux: <code>Ctrl + P</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>一般来说键盘用的越多鼠标用的越少，那么写起代码来效率就越高；常见的快捷键想必大家都已经掌握，接下来我就分享一些你可能不知道的但确非常实用的快捷键。</p>
<blockquote>
<p>下文所有快捷键基于如下keymap<br>Windows: Default<br>Linux: Default<br>OSX: Mac OSX 10.5+</p>
</blockquote>
<h2 id="自动补全的时候是Enter还是Tab？">自动补全的时候是Enter还是Tab？</h2><p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-11-1.gif" alt="自动补全enter和tab区别" width="252"/><br>在使用自动补全的时候<code>Enter</code>和<code>Tab</code>的行为还是有一些细微的区别的：<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="实用技巧" scheme="http://weishu.me/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]厌倦了NullPointException？Optional拯救你！]]></title>
    <link href="http://weishu.me/2015/12/08/use-optional-avoid-nullpointexception/"/>
    <id>http://weishu.me/2015/12/08/use-optional-avoid-nullpointexception/</id>
    <published>2015-12-08T12:49:40.000Z</published>
    <updated>2015-12-10T06:31:54.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>I call it my billion-dollar mistake. It was the invention of the null reference in 1965. I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement.<br>—Tony Hoare</p>
</blockquote>
<p>有人说，当你处理过了空指针异常才真正成为一个Java开发者。抛开玩笑话不谈，空指针确实是很多bug的根源。Java SE 8引入了一个新的叫做<code>java.util.Optional</code> 的类来缓解这个问题。</p>
<p>我们首先看看空指针有什么危险，<code>Computer</code>是一个嵌套的对象，如图：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-9-1.gif" alt="Comtuper对象"></p>
<p>下面的代码有什么潜在的问题呢？<br><code>String version = computer.getSoundcard().getUSB().getVersion();</code></p>
<p>貌似可行，但是，很多电脑（比如 Raspberry Pi）并没有Soundcard，因此调用<code>getSoundcard</code>会发生什么？毫无疑问，结果自然是在运行时给你抛出一个<code>NullPointException</code>，然后终止程序的执行。</p>
<p>如何避免上面的空指针异常呢？一般的做法就是在调用方法之前进行检测：<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String version = <span class="string">"UNKNOWN"</span>;</span><br><span class="line"><span class="keyword">if</span>(computer != <span class="keyword">null</span>)&#123;</span><br><span class="line">  Soundcard soundcard = computer.getSoundcard();</span><br><span class="line">  <span class="keyword">if</span>(soundcard != <span class="keyword">null</span>)&#123;</span><br><span class="line">    USB usb = soundcard.getUSB();</span><br><span class="line">    <span class="keyword">if</span>(usb != <span class="keyword">null</span>)&#123;</span><br><span class="line">      version = usb.getVersion();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，上面嵌套if检测的代码确实不怎么好看。但是没办法，我们需要很多这样死板的没什么意义的代码来避免碰到<code>NullPointException</code>。更恼火的是，这部分代码成了我们业务逻辑的一部分，还降低了代码的可读性。</p>
<p>万一我们忘记对某个可能为<code>null</code>的对象进行非空检测怎么办？<strong>使用<code>null</code>来说明某个值缺失是一种错误的方式</strong>, 下文将说明这个问题并给出更好的解决办法。</p>
<p>先看看别的编程语言是如何处理这个问题的。</p>
<h2 id="Null的替代物">Null的替代物</h2><p>Grovvy语言有一个<code>?.</code>的操作符，可以安全地处理潜在可能的空引用（C#即将包含这个特性，Java7曾被建议引入这个但是并没有发布。）它是这么用的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String version = computer?.getSoundcard()?.getUSB()?.getVersion();</span><br></pre></td></tr></table></figure>
<p>如果<code>getSoundcard()</code>,<code>getUSB()</code>,<code>getVersion</code>任意一个返回<code>null</code>，变量<code>version</code>就被赋值为<code>null</code>，不需要额外的复杂的嵌套检测。更好的是，Grovvy还有一个<em>Elvis</em>操作符:<code>?:</code>，可以给类似上面的表达式提供默认值。下面的表达式如果<code>?.</code> 返回了<code>null</code>那么变量<code>version</code>会被赋值为<code>&quot;UNKNOW&quot;</code>:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String version = computer?.getSoundcard()?.getUSB()?.getVersion() ?: &#34;UNKNOWN&#34;;</span><br></pre></td></tr></table></figure></p>
<p>其他的一些函数式编程语言，比如Haskell, Scala，使用了一种别的方式。Haskell有一个<code>Maybe</code>型态，这个型态代表了一种有可选值的类型。Maybe形态的值可能包含一个给定类型的值或者是Nothing(译者注：代表没有值)，完全没有空指针的概念。Scala有一种类似的叫做<strong>Option[T]</strong>的东西来代表类型T的某一个值存在或者没有。因此，你必须显式检测这个值是否存在，如果不存在就不能使用任何Option类型的操作符；这样由于Scala的类型系统，你永远也不会忘记对于空指针的检测。</p>
<p>貌似有点扯远了，那么，Java8给我们提供了什么呢？</p>
<h2 id="果壳里的Optional">果壳里的<code>Optional</code></h2><p>受到Haskell和Scala的启发，Java8引入了一个叫做<code>java.util.Optional&lt;T&gt;</code>的类，这一个包含一个可选值的类型，你可以把它当作包含单个值的容器——这个容器要么包含一个值要么什么都没有，如下图：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-9-2.gif" alt="Optional表示"><br>我们在数据模型里面引入<code>Optional</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Optional&lt;Soundcard&gt; soundcard;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Optional&lt;Soundcard&gt; <span class="title">getSoundcard</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soundcard</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Optional&lt;USB&gt; usb;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Optional&lt;USB&gt; <span class="title">getUSB</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getVersion</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用上面的代码，我们一眼就可以看出来一个computer有没有soundcard（他们是optioal，可选的），更进一步，一个声卡也有一个可选的USB端口；新的模型能清晰地反映出一个给定的值是有可能不存在的。这种做法在某些库里面也存在，比如<strong>Guava</strong>(译：Java5之后就可以使用，不过有局限)</p>
<p>我们能用<em>Optional</em>对象干什么？Optional对象包含了一些方法来显式地处理某个值是存在还是缺失，Optional类强制你思考值不存在的情况，这样就能避免潜在的空指针异常。</p>
<p>值得一提的是，设计Optional类的目的并不是完全取代<code>null</code>, 它的目的是设计更易理解的API。通过Optional，可以从方法签名就知道这个函数有可能返回一个缺失的值，这样强制你处理这些缺失值的情况。</p>
<h2 id="Optional的正确打开方式">Optional的正确打开方式</h2><p>废话扯了这么多，来点实际的例子吧！首先来看看如何使用Optional类来实现传统的空指针检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = computer.flatMap(Computer::getSoundcard)</span><br><span class="line">                          .flatMap(Soundcard::getUSB)</span><br><span class="line">                          .map(USB::getVersion)</span><br><span class="line">                          .orElse(<span class="string">"UNKNOWN"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果无法理解这段代码，可以复习Java8的lambda和方法引用,见<a href="http://www.oracle.com/technetwork/articles/java/architect-lambdas-part1-2080972.html" target="_blank" rel="external">Java8 Lambdas</a> 以及stream pipelining概念,见<a href="http://www.oraclejavamagazine-digital.com/javamagazine_open/20140304#pg51" target="_blank" rel="external">Processing Data with Java SE 8 Steams</a></p>
</blockquote>
<h3 id="创建Optional对象">创建Optional对象</h3><p>如何创建Optional对象呢，有下面几种方式：</p>
<ol>
<li>空的Optional</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Soundcard&gt; sc = Optional.empty();</span><br></pre></td></tr></table></figure>
<ol>
<li>包含非空值的Optional</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SoundCard soundcard = <span class="keyword">new</span> Soundcard();</span><br><span class="line">Optional&lt;Soundcard&gt; sc = Optional.of(soundcard);</span><br></pre></td></tr></table></figure>
<p>一旦<code>soundcard</code>是<code>null</code>，这段代码会立即抛出一个<code>NullPointException</code>（而不是等你以后你访问这个空的soundcard对象的时候)</p>
<ol>
<li>可能为空的Optional</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Soundcard&gt; sc = Optional.ofNullable(soundcard);</span><br></pre></td></tr></table></figure>
<p>如果<code>soundcard</code>是<code>null</code>那么这个<code>Optional</code>将会是<code>empty</code>.</p>
<h3 id="值存在的时候进行进一步的操作">值存在的时候进行进一步的操作</h3><p>现在你有了一个Optional对象，你可以显式地处理值存在或者不存在的情况，再也不用想这样如履薄冰地进行空指针检测了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SoundCard soundcard = ...;</span><br><span class="line"><span class="keyword">if</span>(soundcard != <span class="keyword">null</span>)&#123;</span><br><span class="line">  System.out.println(soundcard);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，可以使用<code>ifPresent()</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Soundcard&gt; soundcard = ...;</span><br><span class="line">soundcard.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>
<p>现在，你再也不用显示地进行非空检测了，类型系统帮你干了这件事。如果Optional是empty,上面的代码就不会执行打印了。</p>
<p>你也可以使用<code>isPresent()</code>方法检查某个值是否存在，另外，<code>get</code> 方法可以返回Optional容器里面包含的那个对象，如果没有这个对象，<code>get</code>方法会立即抛出一个<code>NoSuchElementException</code>，这两个方法可以结合起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(soundcard.isPresent())&#123;</span><br><span class="line">  System.out.println(soundcard.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，并不提倡这样使用Optional。（这么做跟<code>null</code>检测有什么区别？），下面有一些惯用手法，我们来看一下。</p>
<h3 id="默认值和默认操作">默认值和默认操作</h3><p>在某个操作返回空的时候给出一个默认值也是一个典型的场景，通畅的做法是使用三目运算符(<code>?</code>):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Soundcard soundcard = maybeSoundcard != <span class="keyword">null</span> ? </span><br><span class="line">            maybeSoundcard : <span class="keyword">new</span> Soundcard(<span class="string">"basic_sound_card"</span>);</span><br></pre></td></tr></table></figure>
<p>可以使用Optional对象的<code>ifElse</code>方法改进这个代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Soundcard soundcard = maybeSoundcard.orElse(<span class="keyword">new</span> Soundcard(<span class="string">"defaut"</span>));</span><br></pre></td></tr></table></figure>
<p>如果你想在空值的时候抛出一个异常，可以使用<code>ifElseThrow</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Soundcard soundcard = </span><br><span class="line">  maybeSoundCard.orElseThrow(IllegalStateException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<h3 id="使用filter过滤特定值">使用<code>filter</code>过滤特定值</h3><p>很多时候你需要调用某个对象的方法并且检查它的一些属性。例如：你可能需要检测一个USB的端口是否是一个特定的版本；如果需要避免空指针异常，通畅的方式是检测非空然后调用<code>getVersion</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USB usb = ...;</span><br><span class="line"><span class="keyword">if</span>(usb != <span class="keyword">null</span> &amp;&amp; <span class="string">"3.0"</span>.equals(usb.getVersion()))&#123;</span><br><span class="line">  System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Optional的<code>filter</code>可以这么干：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;USB&gt; maybeUSB = ...;</span><br><span class="line">maybeUSB.filter(usb -&gt; <span class="string">"3.0"</span>.equals(usb.getVersion())</span><br><span class="line">                    .ifPresent(() -&gt; System.out.println(<span class="string">"ok"</span>));</span><br></pre></td></tr></table></figure>
<p><code>filter</code>方法带有一个<code>Predicate</code>的参数，如果Optional容器里面的对象存在并且满足这个predicate,那么<code>filter</code>返回那个对象，否则就返回<code>empty</code>的Optional。（跟<code>Stream</code>接口的<code>filter</code>类似）</p>
<h3 id="使用map转换值">使用<code>map</code>转换值</h3><p>另外一个比较常见的场景是需要从某个对象里面提取出特定的值。例如：从一个<code>Soundcard</code>对象里面取出一个<code>USB</code>对象然后检测这个usb对象是否是正确的版本。通常可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(soundcard != <span class="keyword">null</span>)&#123;</span><br><span class="line">  USB usb = soundcard.getUSB();</span><br><span class="line">  <span class="keyword">if</span>(usb != <span class="keyword">null</span> &amp;&amp; <span class="string">"3.0"</span>.equals(usb.getVersion())&#123;</span><br><span class="line">    System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Optional的<code>map</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;USB&gt; usb = maybeSoundcard.map(Soundcard::getUSB);</span><br></pre></td></tr></table></figure>
<p>Optional容器里面的值被某个函数（这里是USB的方法引用）作为参数“转换”了，如果Optional是<code>empty</code>那么就什么也不会发生。</p>
<p>结合使用<code>map</code>和<code>filter</code>可以检测某个声卡是否有USB 3.0的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maybeSoundcard.map(Soundcard::getUSB)</span><br><span class="line">      .filter(usb -&gt; <span class="string">"3.0"</span>.equals(usb.getVersion())</span><br><span class="line">      .ifPresent(() -&gt; System.out.println(<span class="string">"ok"</span>));</span><br></pre></td></tr></table></figure>
<p>现在我们的代码看起来比较像是在描述问题了！而且没有任何非空检测，太酷了！</p>
<h3 id="使用flatMap级联Optional">使用<code>flatMap</code>级联Optional</h3><p>我们已经有一些常见的模式可以通过<code>Optional</code>重构了，那么我们如何用一种安全的方式重构下面的代码呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String version = computer.getSoundcard().getUSB().getVersion();</span><br></pre></td></tr></table></figure>
<p>上面的代码都是从一个对象里面取出另外一个对象， 这不正是上文介绍的<code>map</code>吗？我们改写Computer模型对象，让它拥有一个<code>Optional&lt;Soundcard&gt;</code>和一个<code>Optional&lt;USB&gt;</code>，然后就可以把代码改成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String version = computer.map(Computer::getSoundcard)</span><br><span class="line">                  .map(Soundcard::getUSB)</span><br><span class="line">                  .map(USB::getVersion)</span><br><span class="line">                  .orElse(<span class="string">"UNKNOWN"</span>);</span><br></pre></td></tr></table></figure>
<p>但是，这段代码并不能通过编译。为什么？</p>
<p><code>computer</code>变量类型是<code>Optional&lt;Computer&gt;</code>，因此它调用<code>map</code>方法没有任何问题；但是，<code>getSoundcard()</code>方法的返回类型是<code>Optional&lt;Soundcard&gt;</code>这意味着<code>map</code>操作结果的类型是<code>Optional&lt;Optional&lt;Soundcard&gt;&gt;</code>,因此<code>getUsb</code>这个调用是非法的：外面的那个Optional包含的值是另外一个Optional，自然就没有<code>getUsb</code>方法，下图是这个调用的结构：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-9-3.gif" alt="two level Optional"><br>如何解决这个问题呢？Optional类提供了一个<code>flapMap</code>的方法。这个方法可以对一个Optional使用一个函数转换为一个Optional然后把结果（两个Optional)flatten为一个单个Optional，下图给出了<code>map</code>和<code>flatMap</code>的区别：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-9-4.gif" alt="map and flatMap"><br>用<code>flatMap</code>重写我们的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String version = computer.flatMap(Computer::getSoundcard)</span><br><span class="line">                   .flatMap(Soundcard::getUSB)</span><br><span class="line">                   .map(USB::getVersion)</span><br><span class="line">                   .orElse(<span class="string">"UNKNOWN"</span>);</span><br></pre></td></tr></table></figure>
<p>第一个<code>flatMap</code>确保返回一个<code>Optioan&lt;Soundcard&gt;</code>而不是<code>Optional&lt;&lt;Optional&lt;Soundcard&gt;&gt;</code>，第二个<code>flatMap</code>确保返回一个<code>Optional&lt;USB&gt;</code>；接着第三次调用着需要一个<code>map</code>即可，因为<code>getVersion</code>返回一个<code>String</code>而非<code>Optional</code>方法。</p>
<p>Cool！现在我们可以抛弃痛苦的嵌套非空检测了，使用Optional可以写出声明式的，更可读的代码，并且永远不会有空指针异常！</p>
<h2 id="总结">总结</h2><p>本文介绍了如何使用Java SE 8的<code>java.util.Optional&lt;T&gt;</code>。<code>Optional</code>的目的不是替换你代码里面的每个<code>null</code>，它可以帮助你设计出更好的API，使用者通过方法签名就能知道是否有一个可选的值。另外，Optional通过强迫主动处理空指针情况，可以保护代码不出现<code>NullPointException</code>。</p>
<h2 id="译后感">译后感</h2><p>嵌套的非空检测确实是个很头大的问题，虽然有一些静态代码检测工具可以检测到这些异常，但是这样无聊的检测代码很是让人失望。Java 8引入的<code>Optional</code>确实可以部分缓解这部分问题；但是依然存在局限性，比如，如果某个特定的方法调用出了别的运行时异常怎么办？对于?Haskell Maybe Monad只吸收了一部分，不过已经很不错了，期待什么时候能引入Grovvy的<code>?.</code>操作符，在处理空指针问题上，<code>?.</code>更加简洁有力。</p>
<p><code>Optional</code>虽好，但是Java 8目前并不普及，Android 就不用想了。虽然有<a href="https://github.com/orfjackal/retrolambda" target="_blank" rel="external">retrolambda</a>项目支持在Java 6里面使用lambda，但是它更多地是提供了语法糖：</p>
<ol>
<li>lambda的实现使用的是匿名内部类而不是<code>invokedynamic</code>, 见<a href="http://www.infoq.com/cn/articles/Java-8-Lambdas-A-Peek-Under-the-Hood" target="_blank" rel="external">深入探索Java 8 Lambda表达式</a></li>
<li>方法引用是lambda的语法糖，实现相同</li>
<li>接口默认方法实际上给接口生成了一个抽象方法，然后给所有接口的实现者添加了这个默认实现</li>
<li>接口静态方法，实际上把静态方法放在另外一个类里面，然后把所有对接口静态方法的调用更换为对新生成类里面方法的调用</li>
</ol>
<p>鉴于以上种种原因，在生产环境基本上不可能使用<em>retrolambda</em>了，大型系统还是老实一点吧。</p>
<p>虽然Grava项目也有一个<code>Optional</code>类，但是没有函数式接口，我们所能做的不过是把<code>if (obj == null)</code>替换为<code>if (opt.isPresend())</code>罢了；虽说能提高类型安全性，但是还是得写一堆shit一样的嵌套检测。</p>
<p>对于Android开发，想使用这个是没有希望了。但愿<strong>Kotlin</strong>能给我们惊喜。</p>
<h2 id="参考">参考</h2><ol>
<li>Chapter 9, “Optional: a better alternative to null,” <a href="http://www.manning.com/urma/" target="_blank" rel="external">from Java 8 in Action: Lambdas, Streams, and Functional-style Programming</a></li>
<li>“<a href="http://www.slideshare.net/mariofusco/monadic-java" target="_blank" rel="external">Monadic Java</a>“ by Mario Fusco</li>
<li><a href="http://www.oraclejavamagazine-digital.com/javamagazine_open/20140304#pg51" target="_blank" rel="external">Processing Data with Java SE 8 Streams</a></li>
</ol>
<h2 id="致谢">致谢</h2><p>Thanks to Alan Mycroft and Mario Fusco for going through the adventure of writing Java 8 in Action: Lambdas, Streams, and Functional-style Programming with me.</p>
<h2 id="关于作者">关于作者</h2><p>Raoul-Gabriel Urma (@raoulUK) is currently completing a PhD in computer science at the University of Cambridge, where he does research in programming languages. He’s a coauthor of the upcoming book Java 8 in Action: Lambdas, Streams, and Functional-style Programming, published by Manning. He is also a regular speaker at major Java conferences (for example, Devoxx and Fosdem) and an instructor. In addition, he has worked at several well-known companies—including Google’s Python team, Oracle’s Java Platform group, eBay, and Goldman Sachs—as well as for several startup projects.</p>
<p><strong>原文</strong>：<a href="http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html" target="_blank" rel="external">http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>I call it my billion-dollar mistake. It was the invention of the null reference in 1965. I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement.<br>—Tony Hoare</p>
</blockquote>
<p>有人说，当你处理过了空指针异常才真正成为一个Java开发者。抛开玩笑话不谈，空指针确实是很多bug的根源。Java SE 8引入了一个新的叫做<code>java.util.Optional</code> 的类来缓解这个问题。</p>
<p>我们首先看看空指针有什么危险，<code>Computer</code>是一个嵌套的对象，如图：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/blog2015-12-9-1.gif" alt="Comtuper对象"></p>
<p>下面的代码有什么潜在的问题呢？<br><code>String version = computer.getSoundcard().getUSB().getVersion();</code></p>
<p>貌似可行，但是，很多电脑（比如 Raspberry Pi）并没有Soundcard，因此调用<code>getSoundcard</code>会发生什么？毫无疑问，结果自然是在运行时给你抛出一个<code>NullPointException</code>，然后终止程序的执行。</p>
<p>如何避免上面的空指针异常呢？一般的做法就是在调用方法之前进行检测：<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://weishu.me/tags/java/"/>
    
      <category term="optional" scheme="http://weishu.me/tags/optional/"/>
    
      <category term="java" scheme="http://weishu.me/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让Alfred支持拼音搜索]]></title>
    <link href="http://weishu.me/2015/12/07/make-alfred-support-pinyinyin-search/"/>
    <id>http://weishu.me/2015/12/07/make-alfred-support-pinyinyin-search/</id>
    <published>2015-12-06T20:39:49.000Z</published>
    <updated>2015-12-10T06:34:21.000Z</updated>
    <content type="html"><![CDATA[<p>Alfred是个好东西，不过检索程序的时候不支持拼音搜索；我在论坛看到有人给作者反馈过，无奈作者说支持中文，他不知道拼音是什么，于是就不了了之了。举个例子：我想打开<code>网易云音乐</code>,可是当我输入<code>wangyiyunyinyue</code>的时候却是这样的结果:</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1449431593204.png" width="536" alt="不支持拼音的搜索结果"></p>
<p>要么我知道这个App的名字叫做<code>NeteaseMusic</code>，要么我就需要用中文输入<code>网易云音乐</code>打开了；如果恰巧输入法是英文输入状态，那么就会遇到上图的情况；这时候再把已经输入的删除然后切换输入法打开，效率无疑大大折扣。</p>
<a id="more"></a>
<p>就算这里搜索这个App可以使用英文名字解决，可是对于某些系统程序比如邮件可能还知道是<code>Mail</code>，那么备忘录呢？便签呢？还有一些别的中文程序没有英文名的比如马克飞象？如果Alfred能支持拼音搜索，这些问题全部都没了！而且，Alfred可以强制使用英文输入，直接使用字母检索，不用切换输入法了。</p>
<h2 id="原理">原理</h2><p>经过简单的观察之后，发现Alfred检索程序不仅仅是检索名字，还收集了一些额外的信息；在Alfred作者的帮助下，知道它利用了Mac文件系统的一个<strong>拓展信息</strong>的字段；如果你发现某些目录后面有<code>@</code>那么就是有拓展信息了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x+  <span class="number">3</span> root    wheel  <span class="number">102</span>  <span class="number">9</span> <span class="number">10</span>  <span class="number">2014</span> Stickies.app/</span><br><span class="line">drwxr-xr-x@  <span class="number">3</span> weishu  admin  <span class="number">102</span>  <span class="number">3</span> <span class="number">26</span>  <span class="number">2015</span> Sublime Text.app/</span><br></pre></td></tr></table></figure>
<p>可以借助命令行工具<code>xattr</code>进行操作；具体使用可以<code>man xattr</code>.</p>
<p>所以，我们可以通过<strong>把拼音信息添加到文件的拓展信息里面</strong>去，这样Alfred就能借助这些信息帮助拼音检索了。</p>
<h2 id="实现">实现</h2><h3 id="获取程序名">获取程序名</h3><p>程序名不仅仅是一个文件名这么简单，Mac软件有一个叫做<em>localization</em>的概念，大致就是国际化吧；程序结构把国际化的字段存放在不同的文件里面，在程序本地化之后自动load.</p>
<p>我们要使用的那个字段是<code>CFBundleName</code>存放在<code>/&lt;App&gt;/Contents/Resources/&lt;language&gt;/InfoPlist.strings</code>这个文件里面；我们把这个名字读取出来即可。</p>
<p>尝试过使用<code>objc</code>的接口<code>NSBundle.localizedInfoDiction</code>来获取本地化的字段，无奈拿到的永远是英文字段；只好手工解析中文字段了（不会Objc 😭）；使用的命令行工具<code>plutil</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_localized_name</span><span class="params">(abs_path)</span>:</span></span><br><span class="line">    <span class="string">'''get the localized name of given app'''</span></span><br><span class="line">    bundle = NSBundle.new()</span><br><span class="line">    bundle.initWithPath_(abs_path)</span><br><span class="line">    localizations = bundle.localizations()</span><br><span class="line">    chinese = (<span class="string">'zh_CN'</span>, <span class="string">'zh_Hans'</span>)</span><br><span class="line"></span><br><span class="line">    b = any(map(<span class="keyword">lambda</span> x: x <span class="keyword">in</span> localizations, chinese))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> b: <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> chinese:</span><br><span class="line">        path = bundle.pathForResource_ofType_inDirectory_forLanguage_(<span class="string">'InfoPlist'</span>, <span class="string">'strings'</span>, <span class="keyword">None</span>, ch)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path: <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># the path must surround with "", there may be space characters</span></span><br><span class="line">        json_str = subprocess.check_output(<span class="string">u'plutil -convert json -o - "%s"'</span> % path, shell=<span class="keyword">True</span>)</span><br><span class="line">        <span class="comment"># print json_str</span></span><br><span class="line">        json_res = json.loads(json_str, encoding=<span class="string">'utf8'</span>)</span><br><span class="line">        name = json_res.get(<span class="string">'CFBundleName'</span>)</span><br><span class="line">        <span class="keyword">if</span> name: <span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>
<h3 id="转换为拼音">转换为拼音</h3><p>可以直接使用python的拼音转换库<a href="https://github.com/mozillazg/python-pinyin" target="_blank" rel="external">pypinyin</a>,借助这个工具，一行代码搞定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_app_pinyin_name</span><span class="params">(app_name)</span>:</span></span><br><span class="line">    reduce(<span class="keyword">lambda</span> x, y: x + y, lazy_pinyin(app_name, errors=<span class="string">'ignore'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="添加拼音信息">添加拼音信息</h3><p>拼音信息被添加到文件的拓展信息里面，直接使用<code>xattr</code>添加即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add_meta_data</span><span class="params">(app_pinyin_name, app_path)</span>:</span></span><br><span class="line">    <span class="string">''' add meta data(comments) to the app, which can help Alfred or SpotLight find it'''</span></span><br><span class="line">    subprocess.check_call(<span class="string">'xattr -w com.apple.metadata:kMDItemFinderComment %s %s'</span> % (app_pinyin_name, app_path), shell=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>好了，把这些代码整合起来，就能得到最终的结果了，完整的代码在<a href="https://gist.github.com/tiann/35fb758c18036d7f8640" target="_blank" rel="external">这里</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    pattern = re.compile(<span class="string">r'^[\w\s.]+$'</span>)</span><br><span class="line"></span><br><span class="line">    workspace = NSWorkspace.sharedWorkspace()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> app_dir <span class="keyword">in</span> APP_DIRECTORYS:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(app_dir): <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(app_dir, topdown=<span class="keyword">True</span>):</span><br><span class="line">            remove_list = []</span><br><span class="line">            <span class="keyword">for</span> directory <span class="keyword">in</span> dirs:</span><br><span class="line">                <span class="comment"># print type(directory), root, directory</span></span><br><span class="line">                full_path = os.path.join(root, directory)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> _is_application(workspace, full_path): <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                remove_list.append(directory)</span><br><span class="line">                </span><br><span class="line">                localized_name =  _get_localized_name(full_path)</span><br><span class="line">                app_name = localized_name <span class="keyword">if</span> localized_name <span class="keyword">else</span> directory.rsplit(<span class="string">r'.'</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> pattern.match(app_name): </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                _add_meta_data(_get_app_pinyin_name(app_name), full_path)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># if this directory is already a Application</span></span><br><span class="line">            <span class="comment"># do not traverse this; some app may be very large </span></span><br><span class="line">            <span class="comment"># and there won't be any other app inside it</span></span><br><span class="line">            dirs[:] = [d <span class="keyword">for</span> d <span class="keyword">in</span> dirs <span class="keyword">if</span> d <span class="keyword">not</span> <span class="keyword">in</span> remove_list]</span><br></pre></td></tr></table></figure>
<p>最后，我们执行这一段脚本即可<code>sudo python main.py</code>。之所以需要<strong>sudo</strong>是因为某些系统程序（比如家计算器），直接使用是没有权限的。</p>
<p>最后看效果：</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdownalfredpinyin.gif" width="1104" alt="支持拼音搜索效果图"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Alfred是个好东西，不过检索程序的时候不支持拼音搜索；我在论坛看到有人给作者反馈过，无奈作者说支持中文，他不知道拼音是什么，于是就不了了之了。举个例子：我想打开<code>网易云音乐</code>,可是当我输入<code>wangyiyunyinyue</code>的时候却是这样的结果:</p>
<p><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1449431593204.png" width="536" alt="不支持拼音的搜索结果"/></p>
<p>要么我知道这个App的名字叫做<code>NeteaseMusic</code>，要么我就需要用中文输入<code>网易云音乐</code>打开了；如果恰巧输入法是英文输入状态，那么就会遇到上图的情况；这时候再把已经输入的删除然后切换输入法打开，效率无疑大大折扣。</p>]]>
    
    </summary>
    
      <category term="alfred" scheme="http://weishu.me/tags/alfred/"/>
    
      <category term="python" scheme="http://weishu.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mac下自动切换输入法]]></title>
    <link href="http://weishu.me/2015/12/01/autoswitch-keyboard-in-mac/"/>
    <id>http://weishu.me/2015/12/01/autoswitch-keyboard-in-mac/</id>
    <published>2015-12-01T02:17:29.000Z</published>
    <updated>2015-12-02T06:53:30.000Z</updated>
    <content type="html"><![CDATA[<p>长久以来，输入法一直是困扰mac用户的一个问题；不过随着国内厂商的跟进，这种状况得到了极大的改善。不用自己去折腾什么<strong>鼠须管</strong>了，狼厂和企鹅都做的不错。</p>
<p>不过依然有一个问题没有完全解决：不同程序之间输入的自动切换。</p>
<p>相信大家一定有切换到<code>item2</code>输入两个命令发现是中文然后按<code>cmd + space</code>切换的尴尬；另外如果你如果使用vi或者emacs，那么就更蛋疼了。造成这种状况的根本原因在于：<strong>输入法的状态是混乱的</strong>，我无法明白现在自己处于哪一种输入环境，除非我开始打字或者看右上角输入法的图标。我希望<code>item2</code>,<code>Intellij IDEA</code>,<code>Alfred2</code><strong>永远</strong>是英文输入状态，除非手动切换；其他的程序比如chrome浏览器，邮件客户端保持正常。</p>
<p>打个比方，使用<code>sublime</code>写代码，大多数情况下肯定是英文输入状态，写注释的时候可能手动切换到中文；但是这里有个问题，这时候如果我切换到其他程序，然后改变了输入的状态，再次回到<code>sublime</code>，fuck!怎么又成了中文!</p>
<p>目前解决方案有如下方式：</p>
<ol>
<li>mac系统自带的设置-&gt; 键盘 -&gt; 输入源 -&gt; 自动使用文稿的输入源</li>
<li>一些输入法的类似<em>安静模式</em>的功能</li>
</ol>
<a id="more"></a>
<p>第一种方式，意思就是不同的程序保持独立的输入状态，不会出现你在另外一个程序切换了输入法的时候再次回来输入法状态就变了。这个开关很有用，我使用了一段时间，发现还是怪怪的，有时候并不符合预期，但是具体场景也搞不明白，反正是一头雾水，有时候依然会陷入困惑的状态。</p>
<p>第二种方式很有意思，应该可以满足很多非程序员的需求。这个<em>安静模式</em>，打个比方，鼠须管输入法；这种输入法其实有几种输入模式，如果对于<code>sublime</code>开启安静模式，那么在进入<code>sublime</code>程序的时候，会自动切换到英文输入模式；nice！不过问题就是：如果要切换到中文模式，需要按<code>ctrl</code>或者<code>shift</code>。如果使用一些IDE的话，肯定各种快捷键用的飞起，怎么少的了按<code>ctrl</code>和<code>shift</code>，这时候问题就来了，如果我们一不小心在使用某些快捷键的时候触发了这个输入法的模式切换功能，那么就蛋疼了：我们需要不停滴按<code>shift</code>切换确保自己处于正确的状态。更糟糕的是，如果你发现自己处于鼠须管的英文输入模式，想使用中文，然后按了<code>cmd + space</code> 切换，你有可能会切换到系统的英文输入法，打个字发现依然是英文！fuck！你不信邪，以为是没有按到，再猛敲几次<code>cmd + space</code>，最后你自己处于那个状态就晕了。</p>
<h2 id="怎么正确配置输入法">怎么正确配置输入法</h2><p>经过这些折腾之后，可以得到输入法的这么几条最佳实践：</p>
<ol>
<li>最基本的原则是要很方便滴知道自己处于哪一种输入状态。如果任何时候清楚这个，那么就是简单的切换问题了。</li>
<li>最好不要使用一个输入的两种模式，并使用<code>shift</code>或者<code>ctrl</code>切换；如上文，某些情况会陷入极度混乱，最好在输入法之间切换，模式简单。</li>
<li>所有程序输入法状态应该有一个恒定的初始态，每次你重新进入这个程序，就会回到初始状态。</li>
</ol>
<p>为什么需要一个恒定的初始状态呢？为了明确自己处于哪一种输入状态，只需要在每次进入这个程序的时候，不管之前做过什么，它的状态是确定的，姑且叫它初始态；然后基于原则2，每次你希望切换的时候<code>cmd + space</code>一下，需要的时候换回来，如果你去了别的程序再回来，状态重置为初始态。</p>
<p>好了分析了这么多，其实要解决的问题就是3一个，我们写一段小程序。</p>
<h2 id="切换输入法实现">切换输入法实现</h2><p>mac下如果使用objc或者swift切换输入法很简单，Apple提供了很详细的Text Input Service文档（现在这个文档403了，可以使用google的cache访问)；我希望使用python来调用这些接口，很遗憾的是，<code>pyobjc</code>没有封装<code>TIS</code>系列函数，手动使用<code>ctypes</code>模块来wrap一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> ctypes.util</span><br><span class="line"><span class="keyword">import</span> objc</span><br><span class="line"><span class="keyword">import</span> CoreFoundation</span><br><span class="line"></span><br><span class="line">_objc = ctypes.PyDLL(objc._objc.__file__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PyObject *PyObjCObject_New(id objc_object, int flags, int retain)</span></span><br><span class="line">_objc.PyObjCObject_New.restype = ctypes.py_object</span><br><span class="line">_objc.PyObjCObject_New.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_int]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">objc_object</span><span class="params">(id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _objc.PyObjCObject_New(id, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># kTISPropertyLocalizedName</span></span><br><span class="line">kTISPropertyUnicodeKeyLayoutData_p = ctypes.c_void_p.in_dll(carbon, <span class="string">'kTISPropertyInputSourceIsEnabled'</span>)</span><br><span class="line">kTISPropertyInputSourceLanguages_p = ctypes.c_void_p.in_dll(carbon, <span class="string">'kTISPropertyInputSourceLanguages'</span>)</span><br><span class="line">kTISPropertyInputSourceType_p = ctypes.c_void_p.in_dll(carbon, <span class="string">'kTISPropertyInputSourceType'</span>)</span><br><span class="line">kTISPropertyLocalizedName_p = ctypes.c_void_p.in_dll(carbon, <span class="string">'kTISPropertyLocalizedName'</span>)</span><br><span class="line"><span class="comment"># kTISPropertyInputSourceLanguages_p = ctypes.c_void_p.in_dll(carbon, 'kTISPropertyInputSourceLanguages')</span></span><br><span class="line"></span><br><span class="line">kTISPropertyInputSourceCategory = objc_object(ctypes.c_void_p.in_dll(carbon, <span class="string">'kTISPropertyInputSourceCategory'</span>))</span><br><span class="line">kTISCategoryKeyboardInputSource = objc_object(ctypes.c_void_p.in_dll(carbon, <span class="string">'kTISCategoryKeyboardInputSource'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># TISCreateInputSourceList</span></span><br><span class="line">carbon.TISCreateInputSourceList.restype = ctypes.c_void_p</span><br><span class="line">carbon.TISCreateInputSourceList.argtypes = [ctypes.c_void_p, ctypes.c_bool]</span><br><span class="line"></span><br><span class="line">carbon.TISSelectInputSource.restype = ctypes.c_void_p</span><br><span class="line">carbon.TISSelectInputSource.argtypes = [ctypes.c_void_p]</span><br><span class="line"></span><br><span class="line">carbon.TISGetInputSourceProperty.argtypes = [ctypes.c_void_p, ctypes.c_void_p]</span><br><span class="line">carbon.TISGetInputSourceProperty.restype = ctypes.c_void_p</span><br><span class="line"></span><br><span class="line">carbon.TISCopyInputSourceForLanguage.argtypes = [ctypes.c_void_p]</span><br><span class="line">carbon.TISCopyInputSourceForLanguage.restype = ctypes.c_void_p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_avaliable_languages</span><span class="params">()</span>:</span></span><br><span class="line">    single_langs = filter(<span class="keyword">lambda</span> x: x.count() == <span class="number">1</span>, \</span><br><span class="line">        map(<span class="keyword">lambda</span> x: objc_object(carbon.TISGetInputSourceProperty(CoreFoundation.CFArrayGetValueAtIndex(objc_object(s), x).__c_void_p__(), kTISPropertyInputSourceLanguages_p)), \</span><br><span class="line">            range(CoreFoundation.CFArrayGetCount(objc_object(carbon.TISCreateInputSourceList(<span class="keyword">None</span>, <span class="number">0</span>))))))</span><br><span class="line">    res = set()</span><br><span class="line">    map(<span class="keyword">lambda</span> y: res.add(y[<span class="number">0</span>]), single_langs)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_kb</span><span class="params">(lang)</span>:</span></span><br><span class="line">    cur = carbon.TISCopyInputSourceForLanguage(CoreFoundation.CFSTR(lang).__c_void_p__())</span><br><span class="line">    carbon.TISSelectInputSource(cur)</span><br></pre></td></tr></table></figure>
<p>切换输入法主要是<code>TISSelectInputSource</code>方法，简单滴调用这个方法就可以了。使用<code>ctypes</code>包装这个方法有两个地方可以借鉴：</p>
<h3 id="pyobjc_转ctypes兼容类型">pyobjc 转ctypes兼容类型</h3><p>pyobjc提供的对象是不能直接传递给ctypes要包装的函数使用的，需要转换成可以识别的类型。每一个pyobjc提供的对象都有一个<code>__c_void_p__()</code>方法，对它调用这个方法就可以把这个对象转换成一个<code>c_void_p</code>类型</p>
<h3 id="ctypes指针构造出pyobjc对象">ctypes指针构造出pyobjc对象</h3><p>简单包装一下<code>objc</code>runtime里面的new方法，然后可以直接根据指针new一个对象出来。正如以上代码的<code>PyObjCObject_New</code>。（新版的pyobjc模块貌似已经包装了这个方法）</p>
<p>PS：本人第一次包装objc接口，对于objc以及pyobjc均不熟悉，可能有更优雅的方法，请批评指正。</p>
<h2 id="如何自动切换？">如何自动切换？</h2><p>要想实现输入法自动切换，自然是需要在某程序切换到前台的时候，帮它更改一下输入法的状态；如果知道一个程序是不是在前台呢？最笨的办法当然就是轮询，但是不够优雅。幸运的是，新的mac系统提供了这个回调。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span><span class="params">(NSObject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_</span><span class="params">(self, noti)</span>:</span></span><br><span class="line">        info = noti.userInfo().objectForKey_(NSWorkspaceApplicationKey)</span><br><span class="line">        bundleIdentifier = info.bundleIdentifier()</span><br><span class="line">        <span class="keyword">if</span> bundleIdentifier <span class="keyword">in</span> ignore_list:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"found: %s active"</span> % bundleIdentifier</span><br><span class="line">            select_kb(<span class="string">u'en'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    nc = NSWorkspace.sharedWorkspace().notificationCenter()</span><br><span class="line">    observer = Observer.new()</span><br><span class="line">    nc.addObserver_selector_name_object_(</span><br><span class="line">        observer,</span><br><span class="line">        <span class="string">"handle:"</span>,</span><br><span class="line">        NSWorkspaceDidActivateApplicationNotification,</span><br><span class="line">        <span class="keyword">None</span></span><br><span class="line">    )</span><br><span class="line">    AppHelper.runConsoleEventLoop(installInterrupt=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>这一段代码可以拿到最前台运行的application，而且是回调通知。有两个地方需要注意：</p>
<ol>
<li>Observer对象需要先new出来，（我直接在函数参数里面调用，直接就是segement fault，不知道原因）不能使用python的构造对象方式。需要调用new方法。</li>
<li>需要使用AppHelper.runConsoleEventLoop 才能接收到事件，至于为什么见<a href="http://stackoverflow.com/questions/8348627/what-is-the-correct-way-to-identify-the-currently-active-application-in-osx-10" target="_blank" rel="external">参考</a>。</li>
</ol>
<h2 id="成果">成果</h2><p>好了，把上面两段代码整合起来；就能实现每次在打开某些程序的时候，自动切换到某个输入法了！完整的代码见<a href="https://gist.github.com/tiann/f85e89bef4b6e9b83f2a" target="_blank" rel="external">auto_switch_kb.py</a></p>
<p>每次我切换到<code>IDEA</code>敲代码，输入法状态永远都是英文；就算我切换到其他回个邮件，发个消息切换到了中文，再次回来依然是英文；我手动切换到了中文被打断了去做了别的事情，再次回来，依然是英文状态。我永远都知道自己处于什么输入模式，如果不满足条件，<code>cmd + space</code> 切换即可。</p>
<p>最后，你可以使用<code>supervisor</code>之类的东西把它加入开机自动运行，这样，困惑已久的输入法问题终于得到解决。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>长久以来，输入法一直是困扰mac用户的一个问题；不过随着国内厂商的跟进，这种状况得到了极大的改善。不用自己去折腾什么<strong>鼠须管</strong>了，狼厂和企鹅都做的不错。</p>
<p>不过依然有一个问题没有完全解决：不同程序之间输入的自动切换。</p>
<p>相信大家一定有切换到<code>item2</code>输入两个命令发现是中文然后按<code>cmd + space</code>切换的尴尬；另外如果你如果使用vi或者emacs，那么就更蛋疼了。造成这种状况的根本原因在于：<strong>输入法的状态是混乱的</strong>，我无法明白现在自己处于哪一种输入环境，除非我开始打字或者看右上角输入法的图标。我希望<code>item2</code>,<code>Intellij IDEA</code>,<code>Alfred2</code><strong>永远</strong>是英文输入状态，除非手动切换；其他的程序比如chrome浏览器，邮件客户端保持正常。</p>
<p>打个比方，使用<code>sublime</code>写代码，大多数情况下肯定是英文输入状态，写注释的时候可能手动切换到中文；但是这里有个问题，这时候如果我切换到其他程序，然后改变了输入的状态，再次回到<code>sublime</code>，fuck!怎么又成了中文!</p>
<p>目前解决方案有如下方式：</p>
<ol>
<li>mac系统自带的设置-&gt; 键盘 -&gt; 输入源 -&gt; 自动使用文稿的输入源</li>
<li>一些输入法的类似<em>安静模式</em>的功能</li>
</ol>]]>
    
    </summary>
    
      <category term="mac" scheme="http://weishu.me/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[获取迅雷会员工作流]]></title>
    <link href="http://weishu.me/2015/11/18/xunlei-vip-account-workflow/"/>
    <id>http://weishu.me/2015/11/18/xunlei-vip-account-workflow/</id>
    <published>2015-11-18T06:59:44.000Z</published>
    <updated>2015-12-10T06:37:02.000Z</updated>
    <content type="html"><![CDATA[<p>mac下的P2P下载工具目前只有迅雷了，可是大家都知道mac下只有“会员迅雷”才能下载，没会员就是个废物。对于冷门资源离线下载还是是非常非常有用的，高速下载对速度提升也是显而易见。</p>
<p>想必都不会为了临时下载一个资源去开一个会员，肯定有过上网搜迅雷会员的经历；这里教大家如何把这个过程变成一个自动化的工作。<strong>如果长期使用迅雷的话，建议还是开会员去；本教程仅供学习使用，用完请于24小时之内删除</strong></p>
<p>先看看效果：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdownxunleivip.gif" alt="效果图" width="721"></p>
<a id="more"></a>
<h2 id="获取免费迅雷账号的地址">获取免费迅雷账号的地址</h2><p>随便百度一下，就能找到一堆免费迅雷会员分享的地址，具体就不指出了；然后把每天最新的账号分享信息抓取出来。</p>
<p>这里使用python，可以用<code>pyquery</code>来解析网页，然后一个正则匹配就拿到了结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, urllib, re</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">from</span> workflow <span class="keyword">import</span> Workflow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_url = <span class="string">'http://www.xunleihuiyuan.net/'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(wf)</span>:</span></span><br><span class="line">    args = wf.args</span><br><span class="line"></span><br><span class="line">    results = _get_from_web()</span><br><span class="line">    map(<span class="keyword">lambda</span> (x,y):wf.add_item(<span class="string">u'账号:%s'</span> % x, <span class="string">u'密码:%s'</span> % y, arg=<span class="string">u'%s %s'</span> %(x,y), valid=<span class="keyword">True</span>), results)</span><br><span class="line">    wf.send_feedback()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_today_url</span><span class="params">()</span>:</span></span><br><span class="line">    home = urllib.urlopen(_url).read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> pq(home)(<span class="string">'.cate1 .post-title a'</span>)[<span class="number">0</span>].get(<span class="string">'href'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_from_web</span><span class="params">()</span>:</span></span><br><span class="line">    page = urllib.urlopen(_get_today_url()).read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    results = r = pq(page)(<span class="string">'.formattext div'</span>).text()</span><br><span class="line">    <span class="keyword">return</span> re.findall(<span class="string">ur'\u8d26\u53f7(\S+)\u5bc6(\w+)'</span>, results)</span><br></pre></td></tr></table></figure></p>
<h2 id="用Alfred_workflow展示出来">用Alfred workflow展示出来</h2><p>使用python的alfred workflow sdk的话非常简单，文档在<a href="http://alfredworkflow.readthedocs.org/en/develop/index.html" target="_blank" rel="external">这里</a></p>
<p>这里要处理的一个问题是，账号和密码如何简单滴传递出来；一起放在剪切版肯定不太合适。幸好alfred自带剪切版历史的功能，我们分别两次把账号和密码复制到剪切版，要使用的时候，激活<code>cmd + option + c</code>然后从剪切版历史里面选择账号密码即可：效果如下：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/test/1447827801109.png" width="514" alt="alfred历史剪切版功能"><br>然后，按下<code>cmd + 2</code>得到账号，<code>cmd + 3</code>得到密码！具体代码比较简单：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import subprocess,<span class="tag">time</span></span><br><span class="line">query = <span class="string">"&#123;query&#125;"</span></span><br><span class="line">def <span class="function"><span class="title">copy_osx</span><span class="params">(text)</span></span>:</span><br><span class="line">        <span class="tag">p</span> = subprocess.<span class="function"><span class="title">Popen</span><span class="params">([<span class="string">'pbcopy'</span>, <span class="string">'w'</span>], stdin=subprocess.PIPE, close_fds=True)</span></span></span><br><span class="line">        <span class="tag">p</span>.<span class="function"><span class="title">communicate</span><span class="params">(input=text.encode(<span class="string">'utf-8'</span>)</span></span>)</span><br><span class="line">account, pwd = query.<span class="function"><span class="title">split</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">copy_osx</span><span class="params">(account)</span></span></span><br><span class="line"><span class="tag">time</span>.<span class="function"><span class="title">sleep</span><span class="params">(<span class="number">0.3</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">copy_osx</span><span class="params">(pwd)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样，一个简单的迅雷会员获取工作流就完成了！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>mac下的P2P下载工具目前只有迅雷了，可是大家都知道mac下只有“会员迅雷”才能下载，没会员就是个废物。对于冷门资源离线下载还是是非常非常有用的，高速下载对速度提升也是显而易见。</p>
<p>想必都不会为了临时下载一个资源去开一个会员，肯定有过上网搜迅雷会员的经历；这里教大家如何把这个过程变成一个自动化的工作。<strong>如果长期使用迅雷的话，建议还是开会员去；本教程仅供学习使用，用完请于24小时之内删除</strong></p>
<p>先看看效果：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdownxunleivip.gif" alt='效果图' width="721" /></p>]]>
    
    </summary>
    
      <category term="alfred workflow" scheme="http://weishu.me/tags/alfred-workflow/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java高效分割字符串]]></title>
    <link href="http://weishu.me/2015/11/10/fast-split-in-android/"/>
    <id>http://weishu.me/2015/11/10/fast-split-in-android/</id>
    <published>2015-11-10T10:52:34.000Z</published>
    <updated>2015-11-11T02:19:52.000Z</updated>
    <content type="html"><![CDATA[<p>最近优化一段代码的调用时间，发现性能瓶颈居然是io和split！io操作慢情有可原，那么对于split有没有更高效的方法呢？</p>
<h2 id="一般方法">一般方法</h2><p>再java里面，一般的split 字符串解决方案有三种：</p>
<ol>
<li>直接用split函数</li>
<li>使用StingTokenizer类</li>
<li>用<code>indexOf,subString</code>实现；</li>
</ol>
<p>在JDK6的实现中，String类的split直接使用了正则表达式；不得不说，真是杀鸡焉用牛刀。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">        <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Android VM(Android 4.0以上系统源码如此)里面，对这个方法做了一定的优化：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regularExpression, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">       String[] result = java.util.regex.Splitter.fastSplit(regularExpression, <span class="keyword">this</span>, limit);</span><br><span class="line">       <span class="keyword">return</span> result != <span class="keyword">null</span> ? result : Pattern.compile(regularExpression).split(<span class="keyword">this</span>, limit);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用正则的话，效率肯定是有问题的；具体我们看一看就知道了。<code>StringTokenizer</code>是一个流式解析类，虽然JDK已经deprecated很久了，但是还是无法阻止大量的开源库使用这个类，效果自然得到了广泛的认可；另外呢，对于简单的分隔符，比如空格，单个字符等，可以直接使用<code>indexOf</code>得到索引，然后用<code>subString</code>得到字串；在这种情况下，理论上效率比上述两种高出很多；首先<code>indexOf</code>这个查找操作肯定是<code>o(logn)</code>，然后，求字串最多也是线性操作。具体效率如何，测试一下就知道了。</p>
<h2 id="测试">测试</h2><p>我们选择的测试字符串对象，是<code>ps</code>得到的输出，然后，写一个测试类，然后在Android下面运行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSplitter</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String line =</span><br><span class="line">            <span class="string">"root      1     0     572    436   c014bbc4 00011304 S /init"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNS = <span class="number">1000000</span>;<span class="comment">// 000000;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COLUMNS = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] splitBySplit() &#123;</span><br><span class="line">        <span class="keyword">return</span> line.split(<span class="string">"\\s+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">splitByIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; l = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] lp = getPsLinePos(line);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">1</span>; i1 &lt; COLUMNS - <span class="number">1</span>; i1++) &#123;</span><br><span class="line">            l.add(line.substring(lp[i1 - <span class="number">1</span>], lp[i1]));</span><br><span class="line">        &#125;</span><br><span class="line">        l.add(line.substring(lp[COLUMNS - <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] sPos;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">splitByIndex2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; l = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sPos == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sPos = getPsLinePos(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">1</span>; i1 &lt; COLUMNS - <span class="number">1</span>; i1++) &#123;</span><br><span class="line">            l.add(line.substring(sPos[i1 - <span class="number">1</span>], sPos[i1]));</span><br><span class="line">        &#125;</span><br><span class="line">        l.add(line.substring(sPos[COLUMNS - <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPsLinePos(String line) &#123;</span><br><span class="line">        <span class="comment">// 以下是为了得到每一列的pos;不在循环里面判空,节省调用</span></span><br><span class="line">        <span class="keyword">int</span>[] lp = <span class="keyword">new</span> <span class="keyword">int</span>[COLUMNS];</span><br><span class="line">        lp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一个起点是开始</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> lastChar;</span><br><span class="line">        <span class="keyword">char</span> curChar;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = line.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            lastChar = line.charAt(j - <span class="number">1</span>);</span><br><span class="line">            curChar = line.charAt(j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index + <span class="number">1</span> &gt;= COLUMNS) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lastChar == <span class="string">' '</span> &amp;&amp; curChar != <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是从空格突变为非空格,那么就是起始点</span></span><br><span class="line">                lp[++index] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">splitByTokenizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; l = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">16</span>);</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(line);</span><br><span class="line">        <span class="keyword">while</span> (st.hasMoreTokens()) &#123;</span><br><span class="line">            l.add(st.nextToken());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Test test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RUNS; i++) &#123;</span><br><span class="line">            test.run();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s use time: %s(ms)"</span>, test.tag, System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Test split = <span class="keyword">new</span> Test(<span class="string">"Split"</span>) &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                splitBySplit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Test string = <span class="keyword">new</span> Test(<span class="string">"StringTokenizer"</span>) &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                splitByTokenizer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Test index = <span class="keyword">new</span> Test(<span class="string">"indexOf"</span>) &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                splitByIndex();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Test index2 = <span class="keyword">new</span> Test(<span class="string">"indexOf2"</span>) &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                splitByIndex2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        test(split);</span><br><span class="line">        test(string);</span><br><span class="line">        test(index);</span><br><span class="line">        test(index2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String tag;</span><br><span class="line"></span><br><span class="line">        Test(String tag) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tag = tag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="结果">结果</h2><p>代码有点长，能用lambda就简洁了，这时后话；看一看性能表现如何（以下使用的是Htc x920e 4.4.2系统测试的）：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I/System.out﹕ Split <span class="operator"><span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">2267</span>(ms)</span><br><span class="line"><span class="keyword">I</span>/<span class="keyword">System</span>.<span class="keyword">out</span>﹕ StringTokenizer <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">326</span>(ms)</span><br><span class="line"><span class="keyword">I</span>/<span class="keyword">System</span>.<span class="keyword">out</span>﹕ indexOf <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">218</span>(ms)</span><br><span class="line"><span class="keyword">I</span>/<span class="keyword">System</span>.<span class="keyword">out</span>﹕ indexOf2 <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">157</span>(ms)</span></span><br></pre></td></tr></table></figure></p>
<p>这下体会到split有多么慢了吧！<code>StringTokenizer</code>与<code>indexOf</code>时间在一个数量级，优化后的indexOf稍微好点，大致快一倍。</p>
<h2 id="结论">结论</h2><ol>
<li>在split需要被大量调用的场合，在现有的Android VM里面，<code>String</code>类的<code>split</code>方法<strong>肯定是不符合要求的</strong></li>
<li><code>StringTokenizer</code>是最廉价的替换split的方法，简单修改成这个实现之后，花费时间能提升一个数量级；</li>
<li><code>indexOf</code>结合<code>subString</code>经过充分的优化，对于<strong>结构化</strong>特别是<strong>表格类</strong>的数据，效率是最快的，对于特定场合，可以考虑使用这种方法，速度大致提升一倍。</li>
</ol>
<h2 id="题外话">题外话</h2><h3 id="JDK8">JDK8</h3><p>自己的mac上面装的是jdk8，我看了一下String在上面的实现，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">        <span class="comment">/* fastpath if the regex is a</span><br><span class="line">         (1)one-char String and this character is not one of the</span><br><span class="line">            RegEx's meta characters ".$|()[&#123;^?*+\\", or</span><br><span class="line">         (2)two-char String and the first char is the backslash and</span><br><span class="line">            the second is not the ascii digit or ascii letter.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (((regex.value.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">             <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</span><br><span class="line">             (regex.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">              regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</span><br><span class="line">              (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">              ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">              ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">            (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">             ch &gt; Character.MAX_LOW_SURROGATE))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">            boolean limited = limit &gt; <span class="number">0</span>;</span><br><span class="line">            ArrayList&lt;String&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> ((next = indexOf(ch, off)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!limited || <span class="built_in">list</span>.size() &lt; limit - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">list</span>.add(substring(off, next));</span><br><span class="line">                    off = next + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">// last one</span></span><br><span class="line">                    <span class="comment">//assert (list.size() == limit - 1);</span></span><br><span class="line">                    <span class="built_in">list</span>.add(substring(off, value.length));</span><br><span class="line">                    off = value.length;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If no match was found, return this</span></span><br><span class="line">            <span class="keyword">if</span> (off == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add remaining segment</span></span><br><span class="line">            <span class="keyword">if</span> (!limited || <span class="built_in">list</span>.size() &lt; limit)</span><br><span class="line">                <span class="built_in">list</span>.add(substring(off, value.length));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Construct result</span></span><br><span class="line">            <span class="keyword">int</span> resultSize = <span class="built_in">list</span>.size();</span><br><span class="line">            <span class="keyword">if</span> (limit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">list</span>.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    resultSize--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] result = <span class="keyword">new</span> String[resultSize];</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>.subList(<span class="number">0</span>, resultSize).toArray(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的实现可以看到：<strong>对于单个字符或者两个字符（后面限制条件不翻译了）作为分割的时候，JDK对它进行了优化！</strong>，看一看在JDK8上面的结论：（需要把那个正则替换成空格）<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Split <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">43</span>(ms)</span><br><span class="line">StringTokenizer <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">15</span>(ms)</span><br><span class="line">indexOf <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">14</span>(ms)</span><br><span class="line">indexOf2 <span class="keyword">use</span> <span class="keyword">time</span>: <span class="number">7</span>(ms)</span><br></pre></td></tr></table></figure></p>
<p>效果惊人！！硬生生拉到了一个数量级！所以说，<strong>没事升级下JDK还是很有必要的，免费的午餐不过如此</strong>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近优化一段代码的调用时间，发现性能瓶颈居然是io和split！io操作慢情有可原，那么对于split有没有更高效的方法呢？</p>
<h2 id="一般方法">一般方法</h2><p>再java里面，一般的split 字符串解决方案有三种：</p>
<ol>
<li>直接用split函数</li>
<li>使用StingTokenizer类</li>
<li>用<code>indexOf,subString</code>实现；</li>
</ol>
<p>在JDK6的实现中，String类的split直接使用了正则表达式；不得不说，真是杀鸡焉用牛刀。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">        <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Android VM(Android 4.0以上系统源码如此)里面，对这个方法做了一定的优化：<br>]]>
    
    </summary>
    
      <category term="split" scheme="http://weishu.me/tags/split/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何安全地打印日志]]></title>
    <link href="http://weishu.me/2015/10/19/how-to-log-safely-in-android/"/>
    <id>http://weishu.me/2015/10/19/how-to-log-safely-in-android/</id>
    <published>2015-10-19T12:28:02.000Z</published>
    <updated>2015-12-10T06:42:17.000Z</updated>
    <content type="html"><![CDATA[<p>如何打印日志？这不是很简单，直接使用<code>android.util.Log</code>这个类不就行了？然而，日志属于非常敏感的信息；逆向工程师在逆向你的程序的时候，本来需要捕捉你程序的各种输出，然后进行推测，顺藤摸瓜然后得到需要的信息；一旦你的日志泄漏，无异于门户洞开，破解你的程序如入无人之境。<br>安全的概念本来就是相对的，如果破解你程序的代价远远大于破解得到的价值，那么就可以认为程序是“安全的”；这里就分析一下，为了提高程序的安全性，在打印日志的时候应该注意什么。</p>
<a id="more"></a>
<p>首先看看绝大部分公司以及开发者的做法：</p>
<h2 id="日志开关＋日志类">日志开关＋日志类</h2><p>为了在release版本里面没有日志输出，一个最简单的想法是：把所有打印日志的语句放在一个<code>if(DEBUG)</code>的语句里面；在日常开发的时候，<code>DEBUG</code>开关打开，发布正式版本的时候关闭这个开关即可，大致思路如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LogUtil.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;<span class="comment">// 发布的时候修改为false</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(String tag, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) android.util.Log.d(TAG, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他debug方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看一个真实的例子，国外的一个apk，名字叫做powerclean；包名：com.lionmobi.powerclean;我们安装这个包；发现很正常，没有任何日志输出；然后我们逆向这个apk；随便翻看几个类，发现很多地方有类似日志输出：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/1445243591752.png" width="552" alt="日志输出图片"><br>我们打开这个叫做x的类，虽然被混淆过了，但是意思很明白，跟我们上面的思路一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lionmobi.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">x</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        x.a = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(String arg1, String arg2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.a) &#123;</span><br><span class="line">            Log.d(arg1, arg2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">e</span><span class="params">(String arg1, String arg2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.a) &#123;</span><br><span class="line">            Log.e(arg1, arg2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">i</span><span class="params">(String arg1, String arg2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.a) &#123;</span><br><span class="line">            Log.i(arg1, arg2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个真实的例子，而且这个app的用户还不少；接下来我们看看这种方式有什么问题。</p>
<h2 id="静态反编译打开日志开关">静态反编译打开日志开关</h2><p>上面的那种方式有一个问题：虽然在release版本里面，确实没有日志输出；但是<strong>输出日志的代码依然存在，只是没有执行到！(if条件不成立)</strong>所以，有没有办法让这些代码执行到呢？简单来说，就是能不能在release版本里面把这个<code>DEBUG</code>变量弄成<code>true</code>呢？当然可以！而且做法还非常简单。</p>
<p>我们使用<code>apktool</code>反编译得到这个apk的smali代码；然后上面的反编译告诉我们，这个日志类的位置是：<code>com.lionmobi.util.x</code>我们打开这个x.smali文件，内容如下：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.class</span><span class="keyword"> public</span> <span class="class">Lcom/lionmobi/util/x;</span></span><br><span class="line"><span class="keyword">.super</span> <span class="class">Ljava/lang/Object;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># static fields</span></span><br><span class="line"><span class="keyword">.field</span><span class="keyword"> private</span><span class="keyword"> static</span> a:Z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># direct methods</span></span><br><span class="line"><span class="keyword">.method</span><span class="keyword"> static</span><span class="keyword"> constructor</span><span class="function"> &lt;clinit&gt;(</span><span class="function">)</span>V</span><br><span class="line"><span class="keyword">    .locals</span> 1</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const/4 </span><span class="variable">v0</span>, 0x0 <span class="comment"># 修改为0x1 (True)</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> sput-boolean </span><span class="variable">v0</span>, <span class="class">Lcom/lionmobi/util/x;</span>-&gt;a:Z <span class="comment">#初始化位置</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> return-void</span><br><span class="line"></span><span class="keyword">.end method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span><span class="function"> d(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"><span class="keyword">    .locals</span> 1</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> sget-boolean </span><span class="variable">v0</span>, <span class="class">Lcom/lionmobi/util/x;</span>-&gt;a:Z</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> if-eqz </span><span class="variable">v0</span>,<span class="keyword"> :cond_0</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">p0</span>, <span class="variable">p1</span>&#125;, <span class="class">Landroid/util/Log;</span><span class="function">-&gt;d(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>I</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> :cond_0</span></span><br><span class="line">   <span class="instruction"> return-void</span><br><span class="line"></span><span class="keyword">.end method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span><span class="function"> e(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"><span class="keyword">    .locals</span> 1</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> sget-boolean </span><span class="variable">v0</span>, <span class="class">Lcom/lionmobi/util/x;</span>-&gt;a:Z</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> if-eqz </span><span class="variable">v0</span>,<span class="keyword"> :cond_0</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">p0</span>, <span class="variable">p1</span>&#125;, <span class="class">Landroid/util/Log;</span><span class="function">-&gt;e(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>I</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> :cond_0</span></span><br><span class="line">   <span class="instruction"> return-void</span><br><span class="line"></span><span class="keyword">.end method</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span><span class="function"> i(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"><span class="keyword">    .locals</span> 1</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> sget-boolean </span><span class="variable">v0</span>, <span class="class">Lcom/lionmobi/util/x;</span>-&gt;a:Z</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> if-eqz </span><span class="variable">v0</span>,<span class="keyword"> :cond_0</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">p0</span>, <span class="variable">p1</span>&#125;, <span class="class">Landroid/util/Log;</span><span class="function">-&gt;i(</span><span class="class">Ljava/lang/String;</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>I</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> :cond_0</span></span><br><span class="line">   <span class="instruction"> return-void</span><br><span class="line"></span><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure></p>
<p>很明白，那个叫做<code>a</code>的静态变量就是我们的开关， 它的初始化在哪个静态代码块里面；新建了一个局部变量0x0然后赋值给了<code>a</code>；因此，我们<strong>把这个0x0修改为0x1</strong>就打开了这个开关。很简单吧，接下来我们把修改好的smali打包回去，然后签名得到一个新的可以运行的apk；运行一下看看结果。果然，一大堆的日志输出了出来，你的程序每一步在干什么都自己告诉别人了，都不需要去猜；我就随便截个图，感受下：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/1445245047558.png" width="1235" alt="泄漏的日志信息"></p>
<h2 id="让release版本里面不包含日志代码">让release版本里面不包含日志代码</h2><p>从上面的分析我们得到一个结论：<strong>如果需要程序是“日志安全的”，那么release版本里面不应该存在输出日志的代码</strong>。</p>
<p>如何做到这一点呢？我们可以做一个工具，开发的时候，正常打印日志；一旦需要发布版本，把所有打印日志的语句代码，全部删除掉。代码很简单，用一些正则表达式就可以做到。</p>
<p>事实上，我们也可以使用一些别的工具，来实现这个类似的功能；那就是<code>proguard</code>；提到这个工具，很多认只是觉得他是一个代码混淆的工具，实际上，<strong>它还可以帮你剔除无用代码！</strong>什么样的代码是无用代码呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// statement;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似于这样，静态编译的时候被认为“永远不会执行的代码”，就被认为是无用代码，会被这个工具直接优化掉，生成的class文件里面，这个if语句直接就没有了。这个功能，完美符合我们的需求；我们只需要把输出日志的代码用这样的if语句包围起来，然后release的时候肯定会用这个工具混淆；然后，在release版本里面，所有的输出日志的代码全部都没有了！不会像以前一样，留下一个影子，只是不做事。</p>
<h2 id="正确的做法">正确的做法</h2><p>最终，我们所有打印日志的语句应该如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>; <span class="comment">// 必须是static final 也就是常量，这样才能在编译器优化；删除if块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">    android.util.Log.d(TAG, <span class="string">"msg to print"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，使用proguard优化代码即可。<br>看起来简单，好像也与最初的“日志开关”没有什么区别，仔细分析一下：</p>
<h3 id="日志开关必须是静态常量">日志开关必须是静态常量</h3><p>对比一下正确的做法与最开始的日志开关，一个是一个<strong>静态变量</strong>，一个是<strong>静态常量</strong>；如果是<strong>常量</strong>的话，那么就是永远不变的，那么当<code>DEBUG</code>变量为<code>False</code>的时候proguard可以理所当然地认为，这一部分代码时绝对不会被执行的，这样，打印日志的语句就会被优化（删除）掉；如果是一个变量，那么在运行期间就有可能改变它的值（private仅仅是对于程序员的改变，对于编译器以及运行时，没有什么改不了），这样proguard就会置之不理，这样你的日志代码就暴露出来了，一字之差，失之千里。</p>
<h3 id="抛弃日志类">抛弃日志类</h3><p>假设我们使用了静态常量代码块以及proguard优化代码的技术；但是依然采用上面的日志类的技术，会发生什么呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(String tag, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) android.util.Log.d(tag, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我写了一个demo，自己打包然后反编译，得到这个日志类如下（为了方便看，没有混淆）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(String tag, String msg)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到，if代码块已经没有了，确实不会输出任何日志；但是，我们看看调用这个类的地方！<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/1445247504072.png" width="575" alt="掩耳盗铃的日志"></p>
<p>这个<code>LogUtil.d</code>的调用，无异于掩耳盗铃；虽然破解者没办法让<code>android.util.Log</code>这个类输出任何日志，但是你这里的这个调用还是告诉了别人你在干什么；所以，要屏蔽日志的输出，必须使用if代码块直接包含要被剔除的日志。上面的那个日志类，要被优化掉，那就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">    LogUtil.d(TAG, <span class="string">"msg"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，不是多此一举吗，写一个日志类就是想不想重复地写<code>if (DEBUG)</code>，这里为了使这一句隐藏，还是逃不掉；但是很抱歉，逃得了和尚逃不了庙，这种方法没办法做到完全隐藏信息；<strong>必须抛弃日志类包裹日志代码的做法！</strong></p>
<h3 id="解放双手的补充">解放双手的补充</h3><p>也许有人说，为了这个所谓的日志安全，每次输出日志都的写一个if语句，那不麻烦死；简直反人类，我懒！实际上，要少写几行代码，我们可以选择复用（代码级别，比如上面的日志类），也可以选择<strong>生成</strong>（直接生成代码）；在支持元编程的语言里面，生成代码是很常见的事情，比如C＋＋的模版元编程以及ruby吹嘘的<code>DSL</code>能力；这里没有那么高大上，用代码生成代码，我们直接借助编辑器帮助我们少写几行代码万事。</p>
<h4 id="IDEA/Android_Studio">IDEA/Android Studio</h4><p>可以使用live template的功能；比如我的做法是，写一个<code>ifd</code>的template，每次我输入<code>ifd</code>然后自动展开成if语句，光标停在最中间：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown1445258458.gif" width="402" alt="使用live template简化输入"></p>
<h4 id="vim/emacs">vim/emacs</h4><p>可以使用宏录制的功能，实现上面的live template。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如何打印日志？这不是很简单，直接使用<code>android.util.Log</code>这个类不就行了？然而，日志属于非常敏感的信息；逆向工程师在逆向你的程序的时候，本来需要捕捉你程序的各种输出，然后进行推测，顺藤摸瓜然后得到需要的信息；一旦你的日志泄漏，无异于门户洞开，破解你的程序如入无人之境。<br>安全的概念本来就是相对的，如果破解你程序的代价远远大于破解得到的价值，那么就可以认为程序是“安全的”；这里就分析一下，为了提高程序的安全性，在打印日志的时候应该注意什么。</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://weishu.me/tags/android/"/>
    
      <category term="log" scheme="http://weishu.me/tags/log/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简化markdown写作中的贴图流程]]></title>
    <link href="http://weishu.me/2015/10/16/simplify-the-img-upload-in-markdown/"/>
    <id>http://weishu.me/2015/10/16/simplify-the-img-upload-in-markdown/</id>
    <published>2015-10-16T06:15:09.000Z</published>
    <updated>2015-11-11T08:01:16.000Z</updated>
    <content type="html"><![CDATA[<p>markdown写作的时候，图片插入是一件比较麻烦的事情。常见的流程如下：</p>
<ol>
<li>用截图工具截图；</li>
<li>将截图保存到某个地方</li>
<li>修改截图文件名</li>
<li>上传截图到某个图床（如果不用“围脖是个好图床”这样的工具，还得用客户端登陆）</li>
<li>拿到图床上的截图的链接；然后用markdown格式插入图片</li>
</ol>
<p>这么复杂的流程，让人简直没有了插入图片的欲望；但是大量的文字没有图片，必然让人疲惫；</p>
<p>要是能<strong>随便截个图，然后直接粘贴就成了markdown格式</strong>就好了；自然是能够做到！懒就是生产力～<br><a id="more"></a></p>
<h2 id="效果预览">效果预览</h2><p>首先看看最终达到的效果：<br><img alt="效果预览" src="http://7sbqce.com1.z0.glb.clouddn.com/markdownmarkdownimg.gif" width="660"></p>
<p>第一步，截图；第二步，粘贴；done!</p>
<p>详见github介绍：<a href="https://github.com/tiann/markdown-img-upload" target="_blank" rel="external">https://github.com/tiann/markdown-img-upload</a></p>
<h2 id="图片上传">图片上传</h2><h3 id="准备工作">准备工作</h3><p>首先要做的是，简化上传图片到图床这个手工的过程，甚至连拖动图片到浏览器插件都省略；这里就自然少不了使用图床的SDK，用代码来帮助我们完成上传操作；</p>
<p>这里选择七牛的图床，各种语言的SDK都有，还有免费10G空间，每个月10G流量，业界良心！注册点<a href="https://portal.qiniu.com/signup?code=3ldifp9oti442" target="_blank" rel="external">这里</a></p>
<p>然后新建一个空间，比如我的叫做booluimg，然后点击空间设置里面的域名设置，看看域名是什么，那么以后我的图片就会上传到 <a href="http://7sbqce.com1.z0.glb.clouddn.com/" target="_blank" rel="external">http://7sbqce.com1.z0.glb.clouddn.com/</a></p>
<h3 id="用SDK上传图片">用SDK上传图片</h3><p>使用七牛提供的python SDK，下面的代码可以将一个文件上传到七牛的空间：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> qiniu <span class="keyword">import</span> Auth, put_file</span><br><span class="line"></span><br><span class="line">access_key = <span class="string">'你的Access key'</span> <span class="comment"># AK</span></span><br><span class="line">secret_key = <span class="string">'你的Secret Key'</span> <span class="comment"># SK</span></span><br><span class="line"></span><br><span class="line">bucket_name = <span class="string">'booluimg'</span> <span class="comment"># 七牛空间名</span></span><br><span class="line"></span><br><span class="line">q = Auth(access_key, secret_key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_qiniu</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="string">''' upload file to qiniu'''</span></span><br><span class="line">    dirname, filename = os.path.split(path)</span><br><span class="line">    key = <span class="string">'markdown/%s'</span> % filename <span class="comment"># upload to qiniu's markdown dir</span></span><br><span class="line"></span><br><span class="line">    token = q.upload_token(bucket_name, key)</span><br><span class="line">    ret, info = put_file(token, key, path, check_crc=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> ret != <span class="keyword">None</span> <span class="keyword">and</span> ret[<span class="string">'key'</span>] == key</span><br></pre></td></tr></table></figure></p>
<h2 id="访问剪切版">访问剪切版</h2><p>如果我们进行截图或者复制图片，那么图片是存储在系统的剪切版里面的；要将这个图片上传，必需先从剪切版里面弄出来。</p>
<h3 id="mac">mac</h3><p>mac访问剪切版比较简单，如果是文本类型，那么可以直接使用<code>pbcopy, pbpaste</code>这两个命令解决；如果访问其他的多媒体类型，可以使用系统内置的python与objc的访问接口<code>PyObjC</code>;具体关于剪切版的文档可以参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSPasteboard_Class/index.html#//apple_ref/occ/instm/NSPasteboard/dataForType" target="_blank" rel="external">PyObjC文档</a>，<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSData_Class/#//apple_ref/occ/instm/NSData/writeToFile:atomically:" target="_blank" rel="external">Objc剪切版文档</a>(不会objc没关系，能看懂)</p>
<p>如下：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># clipboard.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> AppKit <span class="keyword">import</span> NSPasteboard, NSPasteboardTypePNG, NSPasteboardTypeTIFF</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_paste_img_file</span><span class="params">()</span>:</span></span><br><span class="line">    pb = NSPasteboard.generalPasteboard()</span><br><span class="line">    data_type = pb.types()</span><br><span class="line">    <span class="comment"># if img file</span></span><br><span class="line">    <span class="keyword">print</span> data_type</span><br><span class="line">    now = int(time.time() * <span class="number">1000</span>) <span class="comment"># used for filename</span></span><br><span class="line">    <span class="keyword">if</span> NSPasteboardTypePNG <span class="keyword">in</span> data_type:</span><br><span class="line">        <span class="comment"># png</span></span><br><span class="line">        data = pb.dataForType_(NSPasteboardTypePNG)</span><br><span class="line">        filename = <span class="string">'%s.png'</span> % now</span><br><span class="line">        filepath = <span class="string">'/tmp/%s'</span> % filename</span><br><span class="line">        ret = data.writeToFile_atomically_(filepath, <span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            <span class="keyword">return</span> filepath</span><br><span class="line">    <span class="keyword">elif</span> NSPasteboardTypeTIFF <span class="keyword">in</span> data_type:</span><br><span class="line">        <span class="comment"># tiff</span></span><br><span class="line">        data = pb.dataForType_(NSPasteboardTypeTIFF)</span><br><span class="line">        filename = <span class="string">'%s.tiff'</span> % now</span><br><span class="line">        filepath = <span class="string">'/tmp/%s'</span> % filename</span><br><span class="line">        ret = data.writeToFile_atomically_(filepath, <span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            <span class="keyword">return</span> filepath</span><br><span class="line">    <span class="keyword">elif</span> NSPasteboardTypeString <span class="keyword">in</span> data_type:</span><br><span class="line">        <span class="comment"># string todo, recognise url of png &amp; jpg</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Windows">Windows</h3><p>windows下，可以装个pywin32然后使用win32api直接访问，具体如何操作自己解决。</p>
<h2 id="自动化流程">自动化流程</h2><p>先阐述一下要达到的理想状态：用截图工具截图（图片默认保存在剪切版），然后在编辑器按下某个类似于粘贴的快捷键，得到一个上传好了到七牛的marddown格式的图片；</p>
<p>如何达到这个要求呢？上传图片以及到从剪切版获取图片都已经完成，接下来就是这个按键的自动化操作了；在mac上，可以使用Alfred工作流，Windows上，可以使用Autohotkey。</p>
<h3 id="mac下使用alfred工作流">mac下使用alfred工作流</h3><p>使用Alfred新建一个空白的工作流，然后新建一个trigger，快捷键绑定为“ctrl + cmd + v”;然后新建一个run script，选择python;然后填上如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">query = <span class="string">"&#123;query&#125;"</span></span><br><span class="line"><span class="keyword">from</span> clipboard <span class="keyword">import</span> get_paste_img_file</span><br><span class="line"><span class="keyword">from</span> upload <span class="keyword">import</span> upload_qiniu</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://7sbqce.com1.z0.glb.clouddn.com/markdown"</span></span><br><span class="line"></span><br><span class="line">img_file = get_paste_img_file()</span><br><span class="line"><span class="keyword">if</span> img_file:</span><br><span class="line">    <span class="comment"># has file</span></span><br><span class="line">    ret = upload_qiniu(img_file)</span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        <span class="comment"># upload success</span></span><br><span class="line">        name = os.path.split(img_file)[<span class="number">1</span>]</span><br><span class="line">        markdown_url = <span class="string">"![](%s/%s?imageMogr2/thumbnail/!50p/quality/100!)"</span> % (url, name)</span><br><span class="line">        <span class="comment"># make it to clipboard</span></span><br><span class="line">        os.system(<span class="string">"echo '%s' | pbcopy"</span> % markdown_url)</span><br><span class="line">        os.system(<span class="string">'osascript -e \'tell application "System Events" to keystroke "v" using command down\''</span>)</span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">print</span> <span class="string">"upload_failed"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"get img file failed"</span></span><br></pre></td></tr></table></figure></p>
<p>其中，复制到剪切版以及按下cmd ＋ v复制这个功能，使用的系统命令<code>pbcopy, osascript</code>这体现了python作为胶水语言的强大之处！</p>
<p>这样，这个workflow就完成了，用系统截图工具<code>cmd + option +ctrl + 4</code>截个图，然后在一个编辑器里面按下<code>cmd + ctrl + v</code>看看是什么效果～</p>
<p>另外有个问题是，mac的retina屏幕截图如果直接使用的话，会是原来的两倍大，我用了七牛的API将图片缩小了一半，但是质量却不太好，不知道有什么办法。</p>
<p>更新：使用mac自带的<code>sips</code>工具得到图片的尺寸；然后使用<code>img</code>标签替代markdown格式的图片；然后使用css属性控制这个图片的宽度。<br>更新2: 使用mac通知中心在上传图片失败的时候给出提醒 github地址：<a href="https://github.com/tiann/markdown-img-upload" target="_blank" rel="external">https://github.com/tiann/markdown-img-upload</a></p>
<h3 id="windows下使用autohotkey">windows下使用autohotkey</h3><p>windows下面没有Alfred，但是有强大的AutoHotKey，出发快捷键以及按下ctrl ＋ v完全可以用这个实现；有兴趣的可以自己实现，非常简单。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>markdown写作的时候，图片插入是一件比较麻烦的事情。常见的流程如下：</p>
<ol>
<li>用截图工具截图；</li>
<li>将截图保存到某个地方</li>
<li>修改截图文件名</li>
<li>上传截图到某个图床（如果不用“围脖是个好图床”这样的工具，还得用客户端登陆）</li>
<li>拿到图床上的截图的链接；然后用markdown格式插入图片</li>
</ol>
<p>这么复杂的流程，让人简直没有了插入图片的欲望；但是大量的文字没有图片，必然让人疲惫；</p>
<p>要是能<strong>随便截个图，然后直接粘贴就成了markdown格式</strong>就好了；自然是能够做到！懒就是生产力～<br>]]>
    
    </summary>
    
      <category term="markdown" scheme="http://weishu.me/tags/markdown/"/>
    
      <category term="workflow" scheme="http://weishu.me/tags/workflow/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[react-native环境搭建的正确姿势]]></title>
    <link href="http://weishu.me/2015/10/08/problems-when-config-react-native-env/"/>
    <id>http://weishu.me/2015/10/08/problems-when-config-react-native-env/</id>
    <published>2015-10-08T09:20:14.000Z</published>
    <updated>2015-10-19T02:53:35.000Z</updated>
    <content type="html"><![CDATA[<p>上个月Facebook开源了Android版的react-native，react-native为何物就不多介绍，个人认为虽然取代不了native，但是确实有可能是移动端的未来。</p>
<p>用这个新的工具最开始自然是需要搭建一个开发环境；官网说的可是简单：装好<code>git</code>, <code>nvm</code>等工具，两条命令解决：</p>
<blockquote>
<p><code>npm install -g react-native-cli</code><br><code>react-native init AwesomeProject</code></p>
</blockquote>
<p>但是对于生活在水深火热的天朝的程序员，事情远没有那么简单。接下来给出正确的安装姿势，最后说说我安装过程中遇到的问题。</p>
<a id="more"></a>
<h2 id="正确的安装姿势">正确的安装姿势</h2><h3 id="准备工作">准备工作</h3><p>准备工作包括<code>git, node</code>等工具的安装；安装node的话最好使用一个版本管理工具比如<code>nvm</code>；这个很简单：</p>
<ol>
<li><code>brew install nvm</code> react-native仅支持mac平台，直接brew</li>
<li><code>nvm install node &amp;&amp; nvm alias default node</code></li>
</ol>
<p>如果上面这两步执行失败，那么需要科学上网；去弄一个VPN或者代理吧，没有的话可以联系我给一个shadowsocks账号。</p>
<p>然后清理一下环境：<code>npm cache clean</code></p>
<p>注意，接下来的安装步骤，如果安装过程中断，最好执行上面的命令<strong>清除缓存</strong>；然后如果是初始化工程失败，最好<strong>删除整个工程目录</strong>重新开始。实际的下载安装过程不会超过十分钟；如果超过说明网络有问题，或者下面的步骤没有正确的配置。</p>
<h3 id="手动下载node-gyp需要的源码">手动下载node-gyp需要的源码</h3><p>官方文档并没有提到这个gyp，那么<a href="https://github.com/nodejs/node-gyp" target="_blank" rel="external">node-gyp</a>是什么？</p>
<blockquote>
<p>Node.js native addon build tool</p>
</blockquote>
<p>我们使用npm安装的有些module依赖一些用c/c++编写的模块，这些模块需要本地编译安装；<code>node-gyp</code>就是一个编译工具。<br>为什么要手动安装呢？因为<code>node-gyp</code>编译需要node的源码，第一次使用的时候需要把它下载下来；但是官方的源码源速度非常慢，基本下载不了；这样会导致编译某些模块的时候卡住，我们可以使用国内的镜像手动下载。运行下面的脚本即可：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># js 版本号</span></span><br><span class="line">NODE_VERSION=`node -v | cut <span class="operator">-d</span><span class="string">'v'</span> <span class="operator">-f</span> <span class="number">2</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载源码包(使用镜像)</span></span><br><span class="line">wget http://npm.taobao.org/mirrors/node/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除现有内容不完整的目录</span></span><br><span class="line">rm -rf ~/.node-gyp</span><br><span class="line">mkdir ~/.node-gyp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩并重命名到正确格式</span></span><br><span class="line">tar zxf node-v<span class="variable">$NODE_VERSION</span>.tar.gz -C ~/.node-gyp</span><br><span class="line">mv ~/.node-gyp/node-v<span class="variable">$NODE_VERSION</span> ~/.node-gyp/<span class="variable">$NODE_VERSION</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个标记文件</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"9\n"</span>&gt;~/.node-gyp/<span class="variable">$NODE_VERSION</span>/installVersion</span><br></pre></td></tr></table></figure></p>
<h3 id="替换npm镜像">替换npm镜像</h3><p>npm官方的源不稳定，我们可以使用国内淘宝的源<a href="http://registry.npm.taobao.org/" target="_blank" rel="external">http://registry.npm.taobao.org/</a> ；执行下面的命令即可：<br><code>npm config set registry=http://registry.npm.taobao.org/</code></p>
<h3 id="配置git代理">配置git代理</h3><p>不能科学上网还是不行的；在安装模块的时候，不仅需要下载模块，还需要下载node源代码；有的还是使用git管理的，而这些库，很有可能就访问不了。<br>如果全部使用代理的话，那么访问国内的镜像也使用了代理，这样会导致速度下降；因此我们只对git设置代理：<br><code>git config --global http.proxy=http://&lt;url&gt;:&lt;port&gt;</code></p>
<p>这些配置完成，那么就可以初始化工程了；一句命令完成：<br><code>react-native init AwesomeProject</code><br>安装完毕之后，可以使用<code>npm ls</code>看一下，这个工程依赖的node模块是有多么复杂，差不多就能理解为什么在天朝配置这个环境有多么麻烦了。</p>
<p>接下来纪录一下我安装过程中遇到的一些问题，不感兴趣可以略过。</p>
<h2 id="遇到的问题">遇到的问题</h2><h3 id="代理和VPN">代理和VPN</h3><p>VPN和代理最大的区别是，VPN对于应用程序就相当于VPN躺在了TCP/IP协议栈里面，所有的网络请求都会通过VPN访问；而代理呢，我们需要给每个要用到代理的程序单独设置代理访问；大多数程序会检测诸如<code>HTTP_PROXY</code>的环境变量来自动使用代理，但是<strong>不是所有的程序都这么乖</strong>。</p>
<p>所以，如果你通过某种方式给系统设置了代理，并不意味着你的每一个程序都会通过代理访问；假如你设置了环境变量<code>HTTP_PROXY</code>那么，系统只是告诉程序有代理可用，至于用不用，是程序自己的问题；如果是VPN，那么程序就算什么都没干，它也是通过VPN访问网络的。</p>
<p>代理这么麻烦，还有一些程序不听话，要是像vpn那样就好了。解决方案自然是有，google<code>Proxifier</code>或者<code>proxycap</code>就行了。</p>
<h3 id="mac系统设置是全局代理吗">mac系统设置是全局代理吗</h3><p>之所以提到mac，是因为react-native官方文档第一条：</p>
<blockquote>
<p>OS X - Only OS X is currently supported</p>
</blockquote>
<p>那么，我们打开<strong>系统偏好设置——网络——高级——代理</strong> 这个设置，然后配置好代理信息，对我们的安装有帮助吗？</p>
<p>事实上，<strong>终端以及一些基于命令行的工具，不会理会系统的代理设置</strong>；具体可以看看<a href="https://discussions.apple.com/thread/2204147?tstart=0" target="_blank" rel="external">这里</a>或者<a href="http://superuser.com/questions/598869/mac-terminal-couldnt-access-network" target="_blank" rel="external">这里</a></p>
<p>所以，在系统这里设置代理对我们没有什么作用。</p>
<h3 id="环境变量的问题">环境变量的问题</h3><p>既然命令行工具不认系统代理设置，那么我们可以在终端手动设置环境变量：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HTTP_PROXY=http://&lt;proxy_url&gt;:&lt;port&gt;</span><br><span class="line"><span class="built_in">export</span> http_proxy=http://&lt;proxy_url&gt;:&lt;port&gt;</span><br><span class="line"><span class="built_in">export</span> HTTPS_PROXY=http://&lt;proxy_url&gt;:&lt;port&gt;</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://&lt;proxy_url&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意两点：</p>
<ol>
<li>有的工具（没错，说的就是<code>wget,curl</code>！！）对于这个环境变量，是<strong>大小写敏感的！！</strong>，所以最好大写小写都设置。</li>
<li>https的代理url不带https头。</li>
</ol>
<p>很不幸，即使这么做了，依然会出现有一些包下载不下来。看了官方文档才知道，<code>npm</code>设置代理不是这个样子的。要么在一个配置文件<code>.npmrc</code>里面设置，要么通过命令<code>npm config set XXX</code>设置。具体可以参考<a href="http://wil.boayue.com/blog/2013/06/14/using-npm-behind-a-proxy/" target="_blank" rel="external">这篇文章</a></p>
<p>这是怎么一个奇葩的设计啊。看文章可仔细点，设置代理名字跟环境变量不一样！</p>
<h3 id="gyp的问题">gyp的问题</h3><p>你以为到这里就结束了？！ 实际上，我们使用的很多npm的包，用到了一些c/c++的模块，需要编译安装。这个时候，需要依赖node的源代码。但是，由于这个源本身的问题，有了代理速度还是乌龟一般。没有办法，我们只有使用国内的淘宝镜像，先手动安装<code>gyp</code>。</p>
<h3 id="openssl的问题">openssl的问题</h3><p>拜GFW所赐，使用https协议的话很有可能根本没法认证，所以最好吧官方的那个源换成http的；然后设置一下这个选项：<br><code>npm config set strict-ssl false</code></p>
<h3 id="git协议无法clone的问题">git协议无法clone的问题</h3><p>在公司的网络环境下，很多端口被屏蔽了；git也是一样，因此使用git协议的clone的话很有可能失败，因此我们需要用https协议替代git协议；具体设置可以参考<a href="http://stackoverflow.com/questions/15669091/bower-install-using-only-https" target="_blank" rel="external">这里</a><br>OK，这些问题全部解决的话，应该能顺利安装上react-native。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上个月Facebook开源了Android版的react-native，react-native为何物就不多介绍，个人认为虽然取代不了native，但是确实有可能是移动端的未来。</p>
<p>用这个新的工具最开始自然是需要搭建一个开发环境；官网说的可是简单：装好<code>git</code>, <code>nvm</code>等工具，两条命令解决：</p>
<blockquote>
<p><code>npm install -g react-native-cli</code><br><code>react-native init AwesomeProject</code></p>
</blockquote>
<p>但是对于生活在水深火热的天朝的程序员，事情远没有那么简单。接下来给出正确的安装姿势，最后说说我安装过程中遇到的问题。</p>]]>
    
    </summary>
    
      <category term="react-native" scheme="http://weishu.me/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mac下Android studio快捷键配置]]></title>
    <link href="http://weishu.me/2015/10/02/configuration-of-idea-android-studio-in-mac/"/>
    <id>http://weishu.me/2015/10/02/configuration-of-idea-android-studio-in-mac/</id>
    <published>2015-10-02T06:17:47.000Z</published>
    <updated>2015-10-19T02:53:35.000Z</updated>
    <content type="html"><![CDATA[<p>前两天重装了mac系统；之前的配置都丢了，因此纪录一下配置的过程以防惨案再次发生～</p>
<p>快捷键为什么要配置？直接使用不就好！</p>
<p>这个事实基于我们使用vim模拟，IdeaVim；会有一些快捷键的冲突；然后使用HHKB的话，为了契合这个键盘，需要做一些额外的处理。</p>
<p>基于两个前提：</p>
<ol>
<li>ideavim的某些ctrl开头的快捷键与IDE冲突，需要手动解决</li>
<li>使用hhkb键盘，没有上下左右，没有<code>F1..Fn</code>系列不方便</li>
</ol>
<a id="more"></a>
<h3 id="ideavim兼容">ideavim兼容</h3><ol>
<li><code>ctrl + r</code>这个在vim模式下是重做，相对于<code>u</code>(undo)；对于重度vimer必不可少，虽然ide的重做也可以用；这么配置带来一个问题，那就是<code>ctrl + r</code>在IDE里面意思是<code>Run</code>，必须改键；以前习惯<code>shift + F10</code>因为windows这么配置的，但是在hhkb键盘，这个键位要摁三个键：<code>fn,shift,0</code>;二逼地配置为<code>shift + 0</code>之后，发现怎么也打不出<code>)</code>了；最终改为<strong><code>option + r</code></strong>很方便，也好记（run），不冲突。</li>
<li><code>ctrl + a</code> 这个在Vim里面意思是光标所在的数字加一；IDE里面意思都是移到行首，等同于命令行模式下的<code>^</code>，既然选择Vim就用vim的移动方式；在插入模式下要多按键，为了避免换个IDE就傻缺，用Vim；另外IDE 的<code>cmd + ⬅️</code>也有这个意思。</li>
<li><code>ctrl + b</code> IDE是往左移动光标；VIM是向上翻页；写代码要频繁用翻页，说明你得重构了；选IDE。<code>ctrl + f</code>同理（向下翻页）</li>
<li><code>ctrl + e</code>  在vim里面意思是光标不动，屏幕滚动；在IDE里面是移到行尾，道理同<code>ctrl + a</code>选VIM；<code>cmd + ➡️</code>可以使用；</li>
<li><code>ctrl + o</code> 在VIM里面意思是：在插入模式下执行命令然后回到插入模式；太有用了；比如你在插入模式，在括号里面写完了，想去行尾加个分号结束，咋办？用上下左右光标？No！你可以<code>ctrl + o A</code>多么优雅！不管IDE什么意思，必须选择Vim。IDE的意思是<code>override</code>这个必须用的，没办法改了；改成<code>ctrl + i</code>。</li>
<li><code>ctrl + g</code> 在IDE里面在查找里面可以把下一个单词加入选择列表；用的情况比较少；在VIM里面，意思有两个：命令模式下等同于<code>:f</code>显示当前文件路径以及行数；插入模式下是一个前缀 ；<code>ctrl g k</code>等同于<code>ctrl + o gk</code> 所以还不错；选Vim。</li>
<li><code>ctrl + i</code> IDE是实现方法（实际上改成了ctrl ＋ o的意思，不用担心这个包含前者。），很有用；VIm是光标前插入空格；选IDE；</li>
<li><code>ctrl + p</code>以及<code>ctrl + n</code>这个是vim的自动完成；在IDE前面没啥用；IDE里面意思是光标移动，选IDE</li>
<li><code>ctrl + T</code> 在IDE里面这个功能太好用了；重构用的；必须IDE</li>
<li><code>ctrl + v</code> IDE里面是cvs的操作；好用；在Vim里面是进入可视化选择模式，可很有用，但是放心 还有一个快捷键<code>ctrl + q</code>是一样的功能；这个是为了兼容windows的；因为windows这个是粘贴～</li>
</ol>
<p>好了，vim兼容就这么多。</p>
<p>然后配置一些HHKB不好按的键，比如Fn系列；没有这个键盘的话自行略过（真心推荐）；</p>
<h3 id="HHKB修改">HHKB修改</h3><ol>
<li><code>cmd + shift + F12</code> ：隐藏所有工具栏，在需要安静写代码的时候很有用；我很常用；改成<code>ctrl + option + (加号)</code> 因为这个➕在hhkb里面对应F12；</li>
<li><code>cmd + F12</code> ： 显示文件的目录结构；太长用了，在类里面导航全靠这个；改为：<code>option + (加号)</code> 这个比上面那个常用；因此这样。</li>
<li><code>option + F7</code> : 查找谁用了它；超有用，没有之一；添加额外选项：<code>option + 7</code></li>
<li><code>option + cmd + F7</code>: 类似上面的，但是在一个弹出框显示；个人觉得比上面那个好用；上面那个单独的窗口导致有时候切换有可能需要鼠标；不方便，考虑这两个功能对换键位；暂时加上<code>option + cmd + 7</code></li>
<li><code>option + ⬆️</code>：类似windows下面的<code>ctrl + w</code> IDEA最有用的特性之一。但是在HHKB按方向键要两个键，改一下；另外，通常选择之后是复制，所以，最好要用cmd组合；索性改成<code>cmd + w</code>原来这个意思是关闭标签，没啥用；一般不自动关闭的。</li>
</ol>
<p>另外一些需要用到Fn系列键位的，可以自行配置一下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前两天重装了mac系统；之前的配置都丢了，因此纪录一下配置的过程以防惨案再次发生～</p>
<p>快捷键为什么要配置？直接使用不就好！</p>
<p>这个事实基于我们使用vim模拟，IdeaVim；会有一些快捷键的冲突；然后使用HHKB的话，为了契合这个键盘，需要做一些额外的处理。</p>
<p>基于两个前提：</p>
<ol>
<li>ideavim的某些ctrl开头的快捷键与IDE冲突，需要手动解决</li>
<li>使用hhkb键盘，没有上下左右，没有<code>F1..Fn</code>系列不方便</li>
</ol>]]>
    
    </summary>
    
      <category term="ideavim" scheme="http://weishu.me/tags/ideavim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Xfermode in android]]></title>
    <link href="http://weishu.me/2015/09/23/Xfermode-in-android/"/>
    <id>http://weishu.me/2015/09/23/Xfermode-in-android/</id>
    <published>2015-09-23T05:10:49.000Z</published>
    <updated>2015-09-25T11:14:11.000Z</updated>
    <content type="html"><![CDATA[<p>Xfermode有三个实现类：AvoidXfermode, PixelXorXfermode以及PorterDuffXfermode。<br>前两个类因为不支持硬件加速在API level 16被标记为Deprecated了，用也可以，但是需要关闭硬件加速，简单说下。</p>
<h2 id="AvoidXfermode">AvoidXfermode</h2><blockquote>
<p> AvoidXfermode xfermode will draw the src everywhere except on top of the<br> opColor or, depending on the Mode, draw only on top of the opColor.</p>
</blockquote>
<p>这话翻译成中文太别扭了，自己理解吧。举个栗子，如果你想对原来图像进行处理，把红色换成绿色，可以使用这个；或者，你想把不是红色的换成某个颜色，也行。这里有一个容差值的概念，比如红色是0xff0000 但是在一定范围内也都是红色，如果你设定一个容差值，那么“各种符合要求的红色”都会被处理。</p>
<a id="more"></a>
<h2 id="PixelXorfermode">PixelXorfermode</h2><p>  文档都说这种模式对于操作混合色没有什么用，还不支持硬件加速，pass，说说重头戏。</p>
<h2 id="PoterDuffXfermode">PoterDuffXfermode</h2><h3 id="Porter-Duff的由来">Porter-Duff的由来</h3><p>说来说去，这个到处都是PorterDuff的玩意儿到底是什么意思？</p>
<blockquote>
<p>Porter-Duff 操作是 1 组 12 项用于描述数字图像合成的基本手法，包括<br>Clear、Source Only、Destination Only、Source Over、Source In、Source<br>Out、Source Atop、Destination Over、Destination In、Destination<br>Out、Destination Atop、XOR。通过组合使用 Porter-Duff 操作，可完成任意 2D<br>图像的合成。<br>Thomas Porter 和 Tom Duff 发表于 1984年原始论文的扫描<a href="http://keithp.com/~keithp/porterduff/p253-porter.pdf" target="_blank" rel="external">版本</a></p>
</blockquote>
<p>看到没！可以完成任意2D图像的合成，理论支撑，所以说是核武器～</p>
<p>###对文档的解释<br>如果去查阅文档这个模式怎么用，相信你一定会fuck：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public enum Mode &#123;</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span> [0, 0] <span class="keyword">*</span>/</span><br><span class="line">    CLEAR       (0),</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span> [Sa, Sc] <span class="keyword">*</span>/</span><br><span class="line">    SRC         (1),</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span> [Da, Dc] <span class="keyword">*</span>/</span><br><span class="line">    DST         (2),</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span> [Sa + (1 - Sa)<span class="keyword">*</span>Da, Rc = Sc + (1 - Sa)<span class="keyword">*</span>Dc] <span class="keyword">*</span>/</span><br><span class="line">    SRC_OVER    (3),</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span> [Sa + (1 - Sa)<span class="keyword">*</span>Da, Rc = Dc + (1 - Da)<span class="keyword">*</span>Sc] <span class="keyword">*</span>/</span><br><span class="line">    DST_OVER    (4),</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span> [Sa <span class="keyword">*</span> Da, Sc <span class="keyword">*</span> Da] <span class="keyword">*</span>/</span><br><span class="line">    SRC_IN      (5),</span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span> [Sa <span class="keyword">*</span> Da, Sa <span class="keyword">*</span> Dc] <span class="keyword">*</span>/</span><br><span class="line">    DST_IN      (6),</span><br><span class="line">    // ...以下省略</span><br></pre></td></tr></table></figure></p>
<p>这尼玛是什么意思。。好了，别慌。如果懂些图形学，大致就知道：<br>Sa = Source alpha<br>Da = Dest alpha<br>Sc = Source color<br>Dc = Dst color<br>如果用叠加的形式看，Dst是下面的图，也就是先画的图；Source是上面的图，也就是后面要画的图。</p>
<p>要说明的是，使用porterduffxfermode绘制的时候，由于窗口时透明的，如果出现<strong>黑色结果</strong>，那么就是这个原因，stackoberflow上有很多这样的<a href="http://stackoverflow.com/questions/18387814/drawing-on-canvas-porterduff-mode-clear-draws-black-why" target="_blank" rel="external">问题</a>答案说需要之前画一个bitmap，原因是对的，但是不应该这么处理，使用layer保存图层即可。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int count = <span class="tag">canvas</span><span class="class">.saveLayer</span></span><br><span class="line">paint.<span class="function"><span class="title">setXfermode</span><span class="params">()</span></span></span><br><span class="line"><span class="tag">canvas</span><span class="class">.drawXXX</span></span><br><span class="line"><span class="tag">canvas</span>.<span class="function"><span class="title">restoreLayer</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="实际效果测试以及mode含义">实际效果测试以及mode含义</h3><p>往上很多对于Xfermode的解释，使用API demo望文生义，并没有考虑到alpha通道的情况，实际上是错误的。典型的解释类似这种：</p>
<blockquote>
<p>4.PorterDuff.Mode.SRC_OVER<br> 正常绘制显示，上下层绘制叠盖。<br>5.PorterDuff.Mode.DST_OVER<br>上下层都显示。下层居上显示。<br>6.PorterDuff.Mode.SRC_IN<br>  取两层绘制交集。显示上层。<br>7.PorterDuff.Mode.DST_IN<br> 取两层绘制交集。显示下层。</p>
</blockquote>
<p>只能说太肤浅了，我们根据上面的图像学的解释，alpha通道的存在意味着事情没那么简单，我们用实际的例子验证一下。<br>验证的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        <span class="comment">// draw background</span></span><br><span class="line">        canvas.drawColor(Color.WHITE);</span><br><span class="line">        <span class="keyword">int</span> count = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, width, height, p, Canvas.ALL_SAVE_FLAG);</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.scale(<span class="number">0.5f</span>, <span class="number">0.5f</span>, width / <span class="number">2</span>, height / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        canvas.drawBitmap(mDst, <span class="number">0</span>, <span class="number">0</span>, p);</span><br><span class="line">        p.setXfermode(xfermode);</span><br><span class="line">        canvas.drawBitmap(mSrc, <span class="number">0</span>, <span class="number">0</span>, p);</span><br><span class="line">        p.setXfermode(null);</span><br><span class="line">        canvas.restore();</span><br><span class="line"></span><br><span class="line">        canvas.restoreToCount(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的mSrc以及mDst分别对应我们绘制的SRC bitmap以及DST bitmap；理论已经解释过了，DST代表先画的，下层图像；SRC是后画的上层图像。测试的图像用代码画出来的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function">Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">        super.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">        width = w;</span><br><span class="line">        height = h;</span><br><span class="line">        <span class="keyword">float</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DST Rect</span></span><br><span class="line">        Paint p = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        mSrc = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</span><br><span class="line">        mDst = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</span><br><span class="line"></span><br><span class="line">        Canvas canvas = <span class="keyword">new</span> Canvas(mDst);</span><br><span class="line">        p.setColor(Color.RED);</span><br><span class="line">        canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, halfWidth, height, p);</span><br><span class="line">        p.setAlpha(<span class="number">1</span> &lt;&lt; <span class="number">7</span>);</span><br><span class="line">        canvas.drawRect(halfWidth, <span class="number">0</span>, width, height, p);</span><br><span class="line"></span><br><span class="line">        canvas = <span class="keyword">new</span> Canvas(mSrc);</span><br><span class="line">        <span class="comment">// SRC circle</span></span><br><span class="line">        p.setColor(Color.BLUE);</span><br><span class="line">        p.setAlpha((<span class="number">1</span> &lt;&lt; <span class="number">8</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> radius = Math.min(height, width) / <span class="number">2</span>;</span><br><span class="line">        mSrcRect.<span class="built_in">set</span>(width / <span class="number">2</span> - radius, height / <span class="number">2</span> - radius, width / <span class="number">2</span> + radius, height / <span class="number">2</span> + radius);</span><br><span class="line">        canvas.drawArc(mSrcRect, <span class="number">0</span>, <span class="number">180</span>, <span class="literal">true</span>, p);</span><br><span class="line">        p.setAlpha(<span class="number">1</span> &lt;&lt; <span class="number">7</span>);</span><br><span class="line">        canvas.drawArc(mSrcRect, <span class="number">180</span>, <span class="number">180</span>, <span class="literal">true</span>, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到，每一个图都有半透明和全透明的两周状态，画出来，肉眼看到效果如下：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/bdea3ba636d6818d213404e2b8715141.png?imageMogr2/thumbnail/!50p" alt="Src"><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/b1b7ff836a928e412a92425cfbac872d.png?imageMogr2/thumbnail/!50p" alt="DST"></p>
<h4 id="SRC和DST">SRC和DST</h4><p>这个就不是解释了，SRC - [Sa, Sc]只有源图像的alpha和颜色，因此只保留源图像；DST也是一样。</p>
<p>####SRC_OVER<br> [ Sa +(1-Sa) <em> Da , Rc = Sc +( 1- Sa ) </em> Dc ]。从名字上看，从DST上面绘制SRC图像（透明度的叠加）：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/44464b24373b955088f469bc0123348e.png?imageMogr2/thumbnail/!50p" alt="SRC_OVER"></p>
<p>####DST_OVER<br>[Sa + ( 1 - Sa ) <em> Da ,Rc = Dc + ( 1 - Da ) </em> Sc ]。与上面情况差不多，看看效果：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/d48a3385baf33b1e1eda1e68d65a6be5.png?imageMogr2/thumbnail/!50p" alt="DST_OVER"></p>
<h4 id="SRC_IN">SRC_IN</h4><p>[ Sa <em> Da , Sc </em> Da ]。注意，alpha通道是SRC和DSTalpha的乘法叠加；颜色是SRC颜色与DSTalpha通道的叠加；考虑一下，我们的图像应该是个什么样子；首先确定图像范围。什么时候才会有图像呢，rgb应该有分量，alpha不能为0；所以rgb分量里面只有SRC，说明图像里面区域里面只有源图像；alpha通道只有DST，当DSTalpha为0的地方没有图像（这句话有两个意思，在DST完全透明的地方不存在源图像）简而言之，就是在相交的地方绘制源图像；但是绘制的alpha通道受DST影响：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/ae37f07bc86754f334dc4f509cf6acc6.png?imageMogr2/thumbnail/!50p" alt="SRC_IN"></p>
<h4 id="DST_IN">DST_IN</h4><p>[ Sa <em> Da , Sa </em> Dc ]。按照上面的理解。在相交的地方绘制DST，但是alpha受SRC影响：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/323dbf2cb54e951a4a9d307ee4d53eb4.png?imageMogr2/thumbnail/!50p" alt="DST_IN"></p>
<h4 id="SRC_OUT">SRC_OUT</h4><p>很多地方解释说：</p>
<blockquote>
<p>取上层绘制非交集部分。<br>在不相交的地方绘制 源图像。</p>
</blockquote>
<p>我们看看是不是这样：<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/a98043e9bdb9c64ce845dffc27bea020.png?imageMogr2/thumbnail/!50p" alt="SRC_OUT"><br>说好的在不相交的地方绘制源图像呢？如果是这个意思，因为DST包含SRC，那么应该整个应该是什么都没有（待商榷，下面说）。为什么相交的地方还是有源图像？</p>
<p>看看这个porterduff公式：[ Sa <em> ( 1 - Da ) , Sc </em> ( 1 - Da ) ]<br>这里对应的rgb是<code>Sc * (1 - Da)</code>,</p>
<ol>
<li>在不相交的地方Da肯定是0，那么不相交的地方就是Sc也就是完全是SRC图像；</li>
<li>在相交的地方是<code>Sc * (1 - Da)</code>也就是虽然是SRC的颜色，但是受到DST的alpha通道的影响。</li>
<li>在相交地方的特殊情况，如果DST完全不透明，那么Da ＝ 1；这时候这个表达式值就是0；也就是通常的解释“绘制非交集部分（交集部分没有图像）”</li>
</ol>
<p>总结一下，这种模式应该是：<strong>在不相交的地方绘制源图像，在相交处根据DST的alpha进行过滤；</strong>特殊情况下相交处DST不透明，那么相交处没有颜色，如果完全透明（相当于没有DST图像）</p>
<h4 id="DST_OUT">DST_OUT</h4><p> [ Da <em> ( 1 - Sa ) , Dc </em> ( 1 - Sa ) ] 与上面解释类似，不赘述。<br> <img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/ce26aec4b49f6acfe068b34b01624816.png?imageMogr2/thumbnail/!50p" alt="DST_OUT"></p>
<h4 id="SRC_ATOP">SRC_ATOP</h4><p> [ Da , Sc <em> Da + ( 1 - Sa ) </em> Dc ]。与上面两种模式解释差不多，有一点不同。<br> <strong>源图像和目标图像相交处绘制源图像，不相交的地方绘制目标图像，并且相交处的效果会受到源图像和目标图像alpha的影响；</strong><br> <img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/615a9819236eff103e67f66a5eeec253.png?imageMogr2/thumbnail/!50p" alt="SRC_ATOP"></p>
<h4 id="DST_ATOP">DST_ATOP</h4><p>[ Sa , Sa <em> Dc + Sc </em> ( 1 - Da ) ]，直接上解释。<br><strong>源图像和目标图像相交处绘制目标图像，不相交的地方绘制源图像，并且相交处的效果会受到源图像和目标图像alpha的影响；</strong><br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/8f684c7abec84b009050626104a60047.png?imageMogr2/thumbnail/!50p" alt="DST_ATOP"></p>
<h4 id="XOR">XOR</h4><p>[ Sa + Da - 2 <em> Sa </em> Da, Sc <em> ( 1 - Da ) + ( 1 - Sa ) </em> Dc ]<br><strong>在不相交的地方按原样绘制源图像和目标图像，相交的地方受到对应alpha和色值影响。</strong>按上面公式进行计算，如果都完全不透明则相交处完全不绘制；<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/6c6f1660106e7b28493e1b0d133fb65c.png?imageMogr2/thumbnail/!50p" alt="XOR"></p>
<h4 id="DARKEN">DARKEN</h4><p>[ Sa + Da - Sa <em> Da , Sc </em> ( 1 - Da ) + Dc * ( 1 - Sa ) + min(Sc , Dc) ]<br>从算法上看，alpha值变大，色值上如果都不透明则取较暗值，非完全不透明情况下使用上面算法进行计算，受到源图和目标图对应色值和alpha值影响；正如名字所说，会感觉效果变暗，即进行对应像素的比较，取较暗值，如果色值相同则进行混合；<br><img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/9f5083ff696b21876730d751ba59cd9b.png?imageMogr2/thumbnail/!50p" alt="DSARKEN"></p>
<p>####LIGHTEN<br> [ Sa + Da - Sa <em> Da , Sc </em> ( 1 -Da ) + Dc * ( 1 - Sa ) + max ( Sc , Dc ) ]<br> 与DARKEN相反，LIGHTEN 的目的则是变亮，如果在均完全不透明的情况下 ，色值取源色值和目标色值中的较大值，否则按上面算法进行计算；<br> <img src="http://7sbqce.com1.z0.glb.clouddn.com/markdown/32bf36e760b74332bb1e901df98e8334.png?imageMogr2/thumbnail/!50p" alt="LIGHTEN"></p>
<p>接下来四种 <strong>MULTIFY</strong>，<strong>SCREEN</strong>，<strong>ADD</strong>，<strong>OVERLAY</strong>就不说了，产生的结果不太确定。自己查阅文档吧。<br>emphasized text</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Xfermode有三个实现类：AvoidXfermode, PixelXorXfermode以及PorterDuffXfermode。<br>前两个类因为不支持硬件加速在API level 16被标记为Deprecated了，用也可以，但是需要关闭硬件加速，简单说下。</p>
<h2 id="AvoidXfermode">AvoidXfermode</h2><blockquote>
<p> AvoidXfermode xfermode will draw the src everywhere except on top of the<br> opColor or, depending on the Mode, draw only on top of the opColor.</p>
</blockquote>
<p>这话翻译成中文太别扭了，自己理解吧。举个栗子，如果你想对原来图像进行处理，把红色换成绿色，可以使用这个；或者，你想把不是红色的换成某个颜色，也行。这里有一个容差值的概念，比如红色是0xff0000 但是在一定范围内也都是红色，如果你设定一个容差值，那么“各种符合要求的红色”都会被处理。</p>]]>
    
    </summary>
    
      <category term="2D graphics" scheme="http://weishu.me/tags/2D-graphics/"/>
    
      <category term="Xfermode" scheme="http://weishu.me/tags/Xfermode/"/>
    
      <category term="Android" scheme="http://weishu.me/categories/Android/"/>
    
      <category term="UI" scheme="http://weishu.me/categories/Android/UI/"/>
    
  </entry>
  
</feed>
